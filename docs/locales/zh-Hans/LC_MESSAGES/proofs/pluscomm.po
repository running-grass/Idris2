# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 11:10+0800\n"
"PO-Revision-Date: 2022-07-13 15:23+0000\n"
"Language-Team: Chinese Simplified (https://www.transifex.com/idriszhong-wen/teams/140912/zh-Hans/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh-Hans\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../source/proofs/pluscomm.rst:3 a1ee37c9f81045f396c261464a51e54b
msgid "Running example: Addition of Natural Numbers"
msgstr ""

#: ../../source/proofs/pluscomm.rst:5 ac0e5631ab4947b4b17d33cc86e90106
msgid ""
"Throughout this tutorial, we will be working with the following function, "
"defined in the Idris prelude, which defines addition on natural numbers:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:15 ada92ff28ae3480cb4bc217b221967a8
msgid ""
"It is defined by the above equations, meaning that we have for free the "
"properties that adding ``m`` to zero always results in ``m``, and that "
"adding ``m`` to any non-zero number ``S k`` always results in ``S (plus k "
"m)``. We can see this by evaluation at the Idris REPL (i.e. the prompt, the "
"read-eval-print loop):"
msgstr ""

#: ../../source/proofs/pluscomm.rst:29 e3d829f5b2c74caf8344f2a8f0337096
msgid ""
"Note that unlike many other language REPLs, the Idris REPL performs "
"evaluation on *open* terms, meaning that it can reduce terms which appear "
"inside lambda bindings, like those above. Therefore, we can introduce "
"unknowns ``k`` and ``m`` as lambda bindings and see how ``plus`` reduces."
msgstr ""

#: ../../source/proofs/pluscomm.rst:35 bb370e5108094f9ea84aae6e197afb49
msgid ""
"The ``plus`` function has a number of other useful properties, for example:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:38 e5ba91e6876a4b398d64f1cd9901a612
msgid ""
"It is *commutative*, that is for all ``Nat`` inputs ``n`` and ``m``, we know"
" that ``plus n m = plus m n``."
msgstr ""

#: ../../source/proofs/pluscomm.rst:41 644ae49c4ebf430fa7ab33c04e9873a9
msgid ""
"It is *associative*, that is for all ``Nat`` inputs ``n``, ``m`` and ``p``, "
"we know that ``plus n (plus m p) = plus (plus m n) p``."
msgstr ""

#: ../../source/proofs/pluscomm.rst:44 6922d5ddc6fb43818abfc8b4177dcd18
msgid ""
"We can use these properties in an Idris program, but in order to do so we "
"must *prove* them."
msgstr ""

#: ../../source/proofs/pluscomm.rst:48 ec6a4359d848491993c03e1eb72322ff
msgid "Equality Proofs"
msgstr ""

#: ../../source/proofs/pluscomm.rst:50 f9e6b3b9a7f74d718dea6e1fb73e8622
msgid "Idris defines a propositional equality type as follows:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:57 9e6570b20fef45edae44643d3ddb30b4
msgid "As syntactic sugar, ``Equal x y`` can be written as ``x = y``."
msgstr ""

#: ../../source/proofs/pluscomm.rst:59 451b30c3e19f45c493076cbb949d6a79
msgid ""
"It is *propositional* equality, where the type states that any two values in"
" different types ``a`` and ``b`` may be proposed to be equal. There is only "
"one way to *prove* equality, however, which is by reflexivity (``Refl``)."
msgstr ""

#: ../../source/proofs/pluscomm.rst:64 96cec6fb2f5249c9b93805a648246be3
msgid ""
"We have a *type* for propositional equality here, and correspondingly a "
"*program* inhabiting an instance of this type can be seen as a proof of the "
"corresponding proposition [1]_. So, trivially, we can prove that ``4`` "
"equals ``4``:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:74 bf2e363a23ae4a69af3992898f191603
msgid "However, trying to prove that ``4 = 5`` results in failure:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:81 3fe2c62d4e074352b0427e2b790ddeec
msgid ""
"The type ``4 = 5`` is a perfectly valid type, but is uninhabited, so when "
"trying to type check this definition, Idris gives the following error:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:94 615951ec54e142768ca558274fd91a4f
msgid "Type checking equality proofs"
msgstr ""

#: ../../source/proofs/pluscomm.rst:96 3ee7ffd2cd6c42b18c8775943dd30e81
msgid ""
"An important step in type checking Idris programs is *unification*, which "
"attempts to resolve implicit arguments such as the implicit argument ``x`` "
"in ``Refl``. As far as our understanding of type checking proofs is "
"concerned, it suffices to know that unifying two terms involves reducing "
"both to normal form then trying to find an assignment to implicit arguments "
"which will make those normal forms equal."
msgstr ""

#: ../../source/proofs/pluscomm.rst:103 28baed77946a4d789d26c9b87ef17268
msgid ""
"When type checking ``Refl``, Idris requires that the type is of the form ``x"
" = x``, as we see from the type of ``Refl``. In the case of "
"``four_eq_five``, Idris will try to unify the expected type ``4 = 5`` with "
"the type of ``Refl``, ``x = x``, notice that a solution requires that ``x`` "
"be both ``4`` and ``5``, and therefore fail."
msgstr ""

#: ../../source/proofs/pluscomm.rst:109 9aaee3c26a114bea8a5755400b21b84c
msgid ""
"Since type checking involves reduction to normal form, we can write the "
"following equalities directly:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:124 67d79577f0f84178b4b89942f56ce740
msgid "Heterogeneous Equality"
msgstr ""

#: ../../source/proofs/pluscomm.rst:126 c03b36d64c3a4547b2408a1dea819f88
msgid ""
"Equality in Idris is *heterogeneous*, meaning that we can even propose "
"equalities between values in different types:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:133 83eaf6b5aff741cc8c573dd6a3dea9d8
msgid ""
"The type ``Z = \"Z\"`` is uninhabited, and one might wonder why it is useful"
" to be able to propose equalities between values in different types. "
"However, with dependent types, such equalities can arise naturally. For "
"example, if two vectors are equal, their lengths must be equal:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:143 0439457109d44068aaa917643f734069
msgid ""
"In the above declaration, ``xs`` and ``ys`` have different types because "
"their lengths are different, but we would still like to draw a conclusion "
"about the lengths if they happen to be equal. We can define "
"``vect_eq_length`` as follows:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:152 5e0dc5b664524b30844e2967a87a9224
msgid ""
"By matching on ``Refl`` for the third argument, we know that the only valid "
"value for ``ys`` is ``xs``, because they must be equal, and therefore their "
"types must be equal, so the lengths must be equal."
msgstr ""

#: ../../source/proofs/pluscomm.rst:156 63740d60559447a2a6318f116ee1f874
msgid ""
"Alternatively, we can put an underscore for the second ``xs``, since there "
"is only one value which will type check:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:164 a42bb3137843427b8da39d7293b5e2cc
msgid "Properties of ``plus``"
msgstr ""

#: ../../source/proofs/pluscomm.rst:166 57c5f5bba4904c2d89e62309ac574776
msgid ""
"Using the ``(=)`` type, we can now state the properties of ``plus`` given "
"above as Idris type declarations:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:174 ac9c9395c3ce45548ce280ab09f1b7dd
msgid ""
"Both of these properties (and many others) are proved for natural number "
"addition in the Idris standard library, using ``(+)`` from the ``Num`` "
"interface rather than using ``plus`` directly. They have the names "
"``plusCommutative`` and ``plusAssociative`` respectively."
msgstr ""

#: ../../source/proofs/pluscomm.rst:179 795cbc086a334c27ae81f45b6d8ac3a3
msgid ""
"In the remainder of this tutorial, we will explore several different ways of"
" proving ``plus_commutes`` (or, to put it another way, writing the "
"function.) We will also discuss how to use such equality proofs, and see "
"where the need for them arises in practice."
msgstr ""

#: ../../source/proofs/pluscomm.rst:185 220b1f9cd4b9450995d5b476d6e8e92a
msgid "This is known as the Curry-Howard correspondence."
msgstr ""
