# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 11:10+0800\n"
"PO-Revision-Date: 2022-07-13 15:23+0000\n"
"Language-Team: Chinese Simplified (https://www.transifex.com/idriszhong-wen/teams/140912/zh-Hans/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh-Hans\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../source/proofs/definitional.rst:1 f6f8dfd46afb4e2cba81ec195789a19a
msgid ""
"Before we discuss the details of theorem proving in Idris, we will describe "
"some fundamental concepts:"
msgstr ""

#: ../../source/proofs/definitional.rst:4 620529d98dc34f97a6ab592de3ac3bbf
msgid "Propositions and judgments"
msgstr ""

#: ../../source/proofs/definitional.rst:5 f4c7566a4bb64ba383e233cb5c180606
msgid "Boolean and constructive logic"
msgstr ""

#: ../../source/proofs/definitional.rst:6
#: ../../source/proofs/definitional.rst:57 c533ee7284584452a0ee48eb4fede9f9
#: 38875790dbb94dddac5b9e7278e9470e
msgid "Curry-Howard correspondence"
msgstr ""

#: ../../source/proofs/definitional.rst:7 10031a688ade4ab6901b826162a3aadd
msgid "Definitional and propositional equalities"
msgstr ""

#: ../../source/proofs/definitional.rst:8 e3ff19029b2a435c832dd1df912a9c27
msgid "Axiomatic and constructive approaches"
msgstr ""

#: ../../source/proofs/definitional.rst:11 3a01729242ac4424bacd651bc6f157c6
msgid "Propositions and Judgments"
msgstr ""

#: ../../source/proofs/definitional.rst:13 3a9f2d71e22343098b4fe1bb1623f473
msgid ""
"Propositions are the subject of our proofs. Before the proof, we can't "
"formally say if they are true or not. If the proof is successful then the "
"result is a 'judgment'.  For instance, if the ``proposition`` is,"
msgstr ""

#: ../../source/proofs/definitional.rst:18 bf094d0eacfc4fb4a061c094584a3851
msgid "1+1=2"
msgstr ""

#: ../../source/proofs/definitional.rst:21 0cddb9cba6e94b77acc788edf60204c2
msgid "When we prove it, the ``judgment`` is,"
msgstr ""

#: ../../source/proofs/definitional.rst:24 7821d580569a49bd9cc8a78c16fdf790
msgid "1+1=2 true"
msgstr ""

#: ../../source/proofs/definitional.rst:27 f09529d209f0435796d561e77dd719e5
msgid "Or if the ``proposition`` is,"
msgstr ""

#: ../../source/proofs/definitional.rst:30 bcb5e0e6ed8d448897a729952d6dd2b9
msgid "1+1=3"
msgstr ""

#: ../../source/proofs/definitional.rst:33 7806e113331b4d5082e05da8e7916ab2
msgid ""
"we can't prove it is true, but it is still a valid proposition and perhaps "
"we can prove it is false so the ``judgment`` is,"
msgstr ""

#: ../../source/proofs/definitional.rst:37 4d0031857013424db3bae132d8458102
msgid "1+1=3 false"
msgstr ""

#: ../../source/proofs/definitional.rst:40 259bf285701b47d9816cdef1c163d883
msgid ""
"This may seem a bit pedantic but it is important to be careful: in "
"mathematics not every proposition is true or false. For instance, a "
"proposition may be unproven or even unprovable."
msgstr ""

#: ../../source/proofs/definitional.rst:44 cdfb8afc6ed74df2b4b3783a051837d2
msgid ""
"So the logic here is different from the logic that comes from boolean "
"algebra. In that case what is not true is false and what is not false is "
"true. The logic we are using here does not have this law, the \"Law of "
"Excluded Middle\", so we cannot use it."
msgstr ""

#: ../../source/proofs/definitional.rst:49 d0b232d5142b4347a63ce634cd74396f
msgid ""
"A false proposition is taken to be a contradiction and if we have a "
"contradiction then we can prove anything, so we need to avoid this. Some "
"languages, used in proof assistants, prevent contradictions."
msgstr ""

#: ../../source/proofs/definitional.rst:53 e5ce5917881244e0908d1602337f97b2
msgid ""
"The logic we are using is called constructive (or sometimes intuitional) "
"because we are constructing a 'database' of judgments."
msgstr ""

#: ../../source/proofs/definitional.rst:59 b81882f85aba4c039dbf0539e4f659c0
msgid ""
"So how do we relate these proofs to Idris programs? It turns out that there "
"is a correspondence between constructive logic and type theory. They have "
"the same structure and we can switch back and forth between the two "
"notations."
msgstr ""

#: ../../source/proofs/definitional.rst:63 0e7aee9ced4d497d8205c960e6eebc17
msgid "The way that this works is that a proposition is a type so..."
msgstr ""

#: ../../source/proofs/definitional.rst:73 fc427e37d8a94e918bad5d868ff7a439
msgid ""
"...is a proposition and it is also a type. The following will also produce "
"an equality type:"
msgstr ""

#: ../../source/proofs/definitional.rst:82 7c8cf53371b24ffa8892db31f9286f98
msgid ""
"Both of these are valid propositions so both are valid equality types. But "
"how do we represent a true judgment? That is, how do we denote 1+1=2 is true"
" but not 1+1=3?  A type that is true is inhabited, that is, it can be "
"constructed. An equality type has only one constructor 'Refl' so a proof of "
"1+1=2 is"
msgstr ""

#: ../../source/proofs/definitional.rst:92 6cbca1ceec184b12ab1c3cf3a1afde95
msgid ""
"Now that we can represent propositions as types other aspects of "
"propositional logic can also be translated to types as follows:"
msgstr ""

#: ../../source/proofs/definitional.rst:96 a49dd4708ca74b28a4523b319be37bea
msgid "propositions"
msgstr ""

#: ../../source/proofs/definitional.rst:96 35260c373a6348c68a3924dcd57c231b
msgid "example of possible type"
msgstr ""

#: ../../source/proofs/definitional.rst:98 dfacef07cd4241c9a13a52897f69ac87
msgid "A"
msgstr ""

#: ../../source/proofs/definitional.rst:98 268911e8f1c84a4998fbc6cd527752ee
msgid "x=y"
msgstr ""

#: ../../source/proofs/definitional.rst:100 46a547d5706f489782882ab654db4957
msgid "B"
msgstr ""

#: ../../source/proofs/definitional.rst:100
#: ../../source/proofs/definitional.rst:108
#: ../../source/proofs/definitional.rst:110 e82f1b6eeed74bb486808bb2fa34b330
#: bb2f7ec4478c4ac3a1c24a3ce57a7c1e c1005b01c177496ea2d9fc4d16f7f0a4
msgid "y=z"
msgstr ""

#: ../../source/proofs/definitional.rst:102 562d62907ed2459fa6dd3c56eefe5427
msgid "and"
msgstr ""

#: ../../source/proofs/definitional.rst:102 294af761b83545f4854f039721d9190f
msgid "A /\\\\ B"
msgstr ""

#: ../../source/proofs/definitional.rst:102 58c62ce0dfbd478ebc43e06fd892c4ed
msgid "Pair(x=y,y=z)"
msgstr ""

#: ../../source/proofs/definitional.rst:104 f2d4bdc0bf9e4159adfc6a0ba3ffd81a
msgid "or"
msgstr ""

#: ../../source/proofs/definitional.rst:104 ad932ba63aa8442c95c66a016ef6a5c1
msgid "A \\\\/ B"
msgstr ""

#: ../../source/proofs/definitional.rst:104 174d118d1c954b1abac24a58d90c796b
msgid "Either(x=y,y=z)"
msgstr ""

#: ../../source/proofs/definitional.rst:106 c21becdedfc74404b84069f9d74a08d4
msgid "implies"
msgstr ""

#: ../../source/proofs/definitional.rst:106 ff3fb70105174921a7bb9d03b33b910f
msgid "A -> B"
msgstr ""

#: ../../source/proofs/definitional.rst:106 fc88669447164d0bb2907e76e9d40e89
msgid "(x=y) -> (y=z)"
msgstr ""

#: ../../source/proofs/definitional.rst:108 5811d85d8a7e456b975b085ed8846877
msgid "for all"
msgstr ""

#: ../../source/proofs/definitional.rst:110 81dc51647d6f4677990f2063bb2d134e
msgid "exists"
msgstr ""

#: ../../source/proofs/definitional.rst:115 f6bf7276a84943fe86622d048bfb0700
msgid "And (conjunction)"
msgstr ""

#: ../../source/proofs/definitional.rst:117 9a225b67a2d84866b5289de398016e08
msgid "We can have a type which corresponds to conjunction:"
msgstr ""

#: ../../source/proofs/definitional.rst:123 8178c23badeb432da29b5c06e7b80ca6
msgid "There is a built in type called 'Pair'."
msgstr ""

#: ../../source/proofs/definitional.rst:126 24e42d019ad24fb9b2fb8e9f7870b56d
msgid "Or (disjunction)"
msgstr ""

#: ../../source/proofs/definitional.rst:128 b665b1b6b2bd4e3bb863e51b4dd4cf37
msgid "We can have a type which corresponds to disjunction:"
msgstr ""

#: ../../source/proofs/definitional.rst:136 5d87c1fad23b479089160591c507a1f5
msgid "There is a built in type called 'Either'."
msgstr ""

#: ../../source/proofs/definitional.rst:139 3b3bb764f181430193671e0f80ed2566
msgid "Definitional and Propositional Equalities"
msgstr ""

#: ../../source/proofs/definitional.rst:141 f3d61f7b22b54cf39af5545825edb74b
msgid ""
"We have seen that  we can 'prove' a type by finding a way to construct a "
"term. In the case of equality types there is only one constructor which is "
"``Refl``. We have also seen that each side of the equation does not have to "
"be identical like '2=2'. It is enough that both sides are *definitionally "
"equal* like this:"
msgstr ""

#: ../../source/proofs/definitional.rst:151 f57acf4932bd4b02b02e79efd02e301e
msgid ""
"Both sides of this equation normalise to 2 and so Refl matches and the "
"proposition is proved."
msgstr ""

#: ../../source/proofs/definitional.rst:154 4eb6be3ec9a449df82fa70c152d8ba77
msgid ""
"We don't have to stick to terms; we can also use symbolic parameters so the "
"following type checks:"
msgstr ""

#: ../../source/proofs/definitional.rst:162 83a82d9af1514d9a90818dc08f59a5be
msgid ""
"If a proposition/equality type is not definitionally equal but is still true"
" then it is *propositionally equal*. In this case we may still be able to "
"prove it but some steps in the proof may require us to add something into "
"the terms or at least to take some sideways steps to get to a proof."
msgstr ""

#: ../../source/proofs/definitional.rst:167 160c5adaa3e3408bb970392676f0d020
msgid ""
"Especially when working with equalities containing variable terms (inside "
"functions) it can be hard to know which equality types are definitionally "
"equal, in this example ``plusReducesL`` is *definitionally equal* but "
"``plusReducesR`` is not (although it is *propositionally equal*). The only "
"difference between them is the order of the operands."
msgstr ""

#: ../../source/proofs/definitional.rst:181 d11d1307dd7b4bed8092395215a228c2
msgid "Checking ``plusReducesR`` gives the following error:"
msgstr ""

#: ../../source/proofs/definitional.rst:192 dcc5be93813f47448bcfb53c120a6428
msgid "So why is ``Refl`` able to prove some equality types but not others?"
msgstr ""

#: ../../source/proofs/definitional.rst:194 2f9c8141c9614234a5aba795d6192d0d
msgid ""
"The first answer is that ``plus`` is defined by recursion on its first "
"argument. So, when the first argument is ``Z``, it reduces, but not when the"
" second argument is ``Z``."
msgstr ""

#: ../../source/proofs/definitional.rst:198 bdc070b1ac2848078c038643036a5975
msgid ""
"If an equality type can be proved/constructed by using ``Refl`` alone it is "
"known as a *definitional equality*. In order to be definitionally equal both"
" sides of the equation must normalise to the same value."
msgstr ""

#: ../../source/proofs/definitional.rst:202 be721233a20e41c2985b229418dd3b5c
msgid ""
"So when we type ``1+1`` in Idris it is immediately reduced to 2 because "
"definitional equality is built in"
msgstr ""

#: ../../source/proofs/definitional.rst:210 9fe134edf8e04588a549030c1d59d2b2
msgid ""
"In the following pages we discuss how to resolve propositional equalities."
msgstr ""
