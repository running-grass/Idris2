# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 11:10+0800\n"
"PO-Revision-Date: 2022-07-13 15:22+0000\n"
"Language-Team: Chinese Simplified (https://www.transifex.com/idriszhong-wen/teams/140912/zh-Hans/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh-Hans\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../source/tutorial/typesfuns.rst:5 25f9a49e6a31495197f5141cd8dd0bb6
msgid "Types and Functions"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:8 476ccd0e15574f7bb673f6b7c6c40747
msgid "Primitive Types"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:10 6fc4e0ab8441460aa60cddd7b383e5a0
msgid ""
"Idris defines several primitive types: ``Int``, ``Integer`` and ``Double`` "
"for numeric operations, ``Char`` and ``String`` for text manipulation, and "
"``Ptr`` which represents foreign pointers. There are also several data types"
" declared in the library, including ``Bool``, with values ``True`` and "
"``False``. We can declare some constants with these types. Enter the "
"following into a file ``Prims.idr`` and load it into the Idris interactive "
"environment by typing ``idris2 Prims.idr``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:34 d2f6789c0a9141a7bd5e4cbca464089f
msgid ""
"An Idris file consists of an optional module declaration (here ``module "
"Prims``) followed by an optional list of imports and a collection of "
"declarations and definitions. In this example no imports have been "
"specified. However Idris programs can consist of several modules and the "
"definitions in each module each have their own namespace. This is discussed "
"further in Section :ref:`sect-namespaces`. When writing Idris programs both "
"the order in which definitions are given and indentation are significant. "
"Functions and data types must be defined before use, incidentally each "
"definition must have a type declaration, for example see ``x : Int``, ``foo "
": String``, from the above listing. New declarations must begin at the same "
"level of indentation as the preceding declaration. Alternatively, a "
"semicolon ``;`` can be used to terminate declarations."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:48 dacb93e27b324fb191373fd2bcc6d8ef
msgid ""
"A library module ``prelude`` is automatically imported by every Idris "
"program, including facilities for IO, arithmetic, data structures and "
"various common functions. The prelude defines several arithmetic and "
"comparison operators, which we can use at the prompt. Evaluating things at "
"the prompt gives an answer, for example:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:61 85ff232364184dbfafb0ca6da54cde08
msgid ""
"All of the usual arithmetic and comparison operators are defined for the "
"primitive types. They are overloaded using interfaces, as we will discuss in"
" Section :ref:`sect-interfaces` and can be extended to work on user defined "
"types. Boolean expressions can be tested with the ``if...then...else`` "
"construct, for example:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:73 0f8b86288a204a8090114c38d31197b5
msgid "Data Types"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:75 9f6bbef6026543df9b0e40cc71fc3b74
msgid ""
"Data types are declared in a similar way and with similar syntax to Haskell."
" Natural numbers and lists, for example, can be declared as follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:85 a0e134b23314405097c382fcfbf69ae8
msgid ""
"Data type names cannot begin with a lower case letter (we will see later why"
" not!).  The above declarations are taken from the standard library. Unary "
"natural numbers can be either zero (``Z``), or the successor of another "
"natural number (``S k``). Lists can either be empty (``Nil``) or a value "
"added to the front of another list (``x :: xs``). In the declaration for "
"``List``, we used an infix operator ``::``. New operators such as this can "
"be added using a fixity declaration, as follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:97 fffcbf84b2524a2d95249698fd4f3cfe
msgid ""
"Functions, data constructors and type constructors may all be given infix "
"operators as names. They may be used in prefix form if enclosed in brackets,"
" e.g. ``(::)``. Infix operators can use any of the symbols:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:106 85a8741c864d455c94a0c0d25bb80932
msgid ""
"Some operators built from these symbols can't be user defined. These are"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:108 1e7fa3b7966d4ebc90cc098b5988aa7d
msgid ""
"``%``, ``\\``, ``:``, ``=``, ``|``, ``|||``, ``<-``, ``->``, ``=>``, ``?``, "
"``!``, ``&``, ``**``, ``..``"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:112 72e2603c0d064ce995d010baa2cbddb5
msgid "Functions"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:114 451012a1ef754beca1d5b96185f5bb5c
msgid ""
"Functions are implemented by pattern matching, again using a similar syntax "
"to Haskell. The main difference is that Idris requires type declarations for"
" all functions, using a single colon ``:`` (rather than Haskell’s double "
"colon ``::``). Some natural number arithmetic functions can be defined as "
"follows, again taken from the standard library:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:133 1f494f35a2f0475c9b6662e759d0cafa
msgid ""
"The standard arithmetic operators ``+`` and ``*`` are also overloaded for "
"use by ``Nat``, and are implemented using the above functions. Unlike "
"Haskell, there is no restriction on whether function names must begin with a"
" capital letter or not. Function names (``plus`` and ``mult`` above), data "
"constructors (``Z``, ``S``, ``Nil`` and ``::``) and type constructors "
"(``Nat`` and ``List``) are all part of the same namespace. By convention, "
"however, data types and constructor names typically begin with a capital "
"letter. We can test these functions at the Idris prompt:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:150 0e433ef1748e4ccfa3d405f7ea757724
msgid ""
"Like arithmetic operations, integer literals are also overloaded using "
"interfaces, meaning that we can also test the functions as follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:160 388493f95afc4f7aa137be463c8bc4e7
msgid ""
"You may wonder, by the way, why we have unary natural numbers when our "
"computers have perfectly good integer arithmetic built in. The reason is "
"primarily that unary numbers have a very convenient structure which is easy "
"to reason about, and easy to relate to other data structures as we will see "
"later. Nevertheless, we do not want this convenience to be at the expense of"
" efficiency. Fortunately, Idris knows about the relationship between ``Nat``"
" (and similarly structured types) and numbers. This means it can optimise "
"the representation, and functions such as ``plus`` and ``mult``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:171 b06d281c2e83484abf4d56d2d9088c9b
msgid "``where`` clauses"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:173 22a0dbd0944645e19fc8fdcd8d27b2e1
msgid ""
"Functions can also be defined *locally* using ``where`` clauses. For "
"example, to define a function which reverses a list, we can use an auxiliary"
" function which accumulates the new, reversed list, and which does not need "
"to be visible globally:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:186 0f4accfaf6af48ad82667cc58c65272a
msgid ""
"Indentation is significant — functions in the ``where`` block must be "
"indented further than the outer function."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:189 69176313a1c14c33b241efbbfb304f82
msgid "Scope"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:191 ba6fa22c1ea24ebc932069ff305e51f2
msgid ""
"Any names which are visible in the outer scope are also visible in the "
"``where`` clause (unless they have been redefined, such as ``xs`` here). A "
"name which appears in the type will be in scope in the ``where`` clause."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:196 817faac30e224b868853486c3f0e0ddb
msgid ""
"As well as functions, ``where`` blocks can include local data declarations, "
"such as the following where ``MyLT`` is not accessible outside the "
"definition of ``foo``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:212 bd5bbff2377a4403b904204e744c1f97
msgid ""
"Functions defined in a ``where`` clause need a type declaration just like "
"any top level function. Here is another example of how this works in "
"practice:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:238 f790cba5c9694329aa72a3ba5f819e66
msgid "Totality and Covering"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:240 d7635c8fb8c546b1b96db92b526cdba6
msgid ""
"By default, functions in Idris must be ``covering``. That is, there must be "
"patterns which cover all possible values of the inputs types. For example, "
"the following definition will give an error:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:249 9319ddde3f194c4caf8c2b1e756af37b
msgid ""
"This gives an error because ``fromMaybe Nothing`` is not defined. Idris "
"reports:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:257 eb8e98e2c6e1412fb9b185ae56b14e64
msgid "You can override this with a ``partial`` annotation:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:264 d7408089ceb2472fbd6864f5645114ed
msgid ""
"However, this is not advisable, and in general you should only do this "
"during the initial development of a function, or during debugging.  If you "
"try to evaluate ``fromMaybe Nothing`` at run time you will get a run time "
"error."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:269 9daa5c0d1877453da71dc9593f31221f
msgid "Holes"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:271 dfde6615a3664969b0176b46173eb850
msgid ""
"Idris programs can contain *holes* which stand for incomplete parts of "
"programs. For example, we could leave a hole for the greeting in our \"Hello"
" world\" program:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:280 947dc6155feb4992aa89d594d2a6e68e
msgid ""
"The syntax ``?greeting`` introduces a hole, which stands for a part of a "
"program which is not yet written. This is a valid Idris program, and you can"
" check the type of ``greeting``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:290 ad37a003080441fdac3d0368a3fdb686
msgid ""
"Checking the type of a hole also shows the types of any variables in scope. "
"For example, given an incomplete definition of ``even``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:299 f6b964351d194e62b5278eadbacc496d
msgid ""
"We can check the type of ``even_rhs`` and see the expected return type, and "
"the type of the variable ``k``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:309 8238ee576bac4f3eb219b455ae46d5e9
msgid ""
"Holes are useful because they help us write functions *incrementally*. "
"Rather than writing an entire function in one go, we can leave some parts "
"unwritten and use Idris to tell us what is necessary to complete the "
"definition."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:315 72a41350538e4a0ba60d600762fcf4d4
msgid "Dependent Types"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:320 f22a2deeb24c4c5ca8bd3e916c3bde90
msgid "First Class Types"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:322 8c141ac06276419a8e0d27e573c354ca
msgid ""
"In Idris, types are first class, meaning that they can be computed and "
"manipulated (and passed to functions) just like any other language "
"construct. For example, we could write a function which computes a type:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:332 763e213763104c43bdcead06e88fde30
msgid ""
"This function calculates the appropriate type from a ``Bool`` which flags "
"whether the type should be a singleton or not. We can use this function to "
"calculate a type anywhere that a type can be used. For example, it can be "
"used to calculate a return type:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:343 9c71637b446e4591a403482a582e7eaf
msgid ""
"Or it can be used to have varying input types. The following function "
"calculates either the sum of a list of ``Nat``, or returns the given "
"``Nat``, depending on whether the singleton flag is true:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:355 c27428c4d14e4502b3cbf9fab71f63cc
msgid "Vectors"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:357 1375a5fd289842d58904c450db283229
msgid ""
"A standard example of a dependent data type is the type of “lists with "
"length”, conventionally called vectors in the dependent type literature. "
"They are available as part of the Idris library, by importing ``Data.Vect``,"
" or we can declare them as follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:368 47ddcc9590424be89ea76a891ae0a1f8
msgid ""
"Note that we have used the same constructor names as for ``List``. Ad-hoc "
"name overloading such as this is accepted by Idris, provided that the names "
"are declared in different namespaces (in practice, normally in different "
"modules). Ambiguous constructor names can normally be resolved from context."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:374 934800cf98ce4187a6523b606510fc49
msgid ""
"This declares a family of types, and so the form of the declaration is "
"rather different from the simple type declarations above. We explicitly "
"state the type of the type constructor ``Vect`` — it takes a ``Nat`` and a "
"type as an argument, where ``Type`` stands for the type of types. We say "
"that ``Vect`` is *indexed* over ``Nat`` and *parameterised* by ``Type``. "
"Each constructor targets a different part of the family of types. ``Nil`` "
"can only be used to construct vectors with zero length, and ``::`` to "
"construct vectors with non-zero length. In the type of ``::``, we state "
"explicitly that an element of type ``a`` and a tail of type ``Vect k a`` "
"(i.e., a vector of length ``k``) combine to make a vector of length ``S k``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:386 3f44841af1cb4874af25fc0c36e75e3a
msgid ""
"We can define functions on dependent types such as ``Vect`` in the same way "
"as on simple types such as ``List`` and ``Nat`` above, by pattern matching. "
"The type of a function over ``Vect`` will describe what happens to the "
"lengths of the vectors involved. For example, ``++``, defined as follows, "
"appends two ``Vect``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:398 781d8e93c57c49d78b8ff078510805e6
msgid ""
"The type of ``(++)`` states that the resulting vector’s length will be the "
"sum of the input lengths. If we get the definition wrong in such a way that "
"this does not hold, Idris will not accept the definition. For example:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:409 6c7ef4ccf70f4e44818a0a0c1465b174
msgid ""
"When run through the Idris type checker, this results in the following:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:423 ae11d12df29d4d79bdec4242dd274832
msgid ""
"This error message suggests that there is a length mismatch between two "
"vectors — we needed a vector of length ``k + m``, but provided a vector of "
"length ``k + k``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:428 1db6f0cf7ccd4053a6cc752b10b32837
msgid "The Finite Sets"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:430 e8bcf3cff7ca4b788b4a9852e841e4bd
msgid ""
"Finite sets, as the name suggests, are sets with a finite number of "
"elements. They are available as part of the Idris library, by importing "
"``Data.Fin``, or can be declared as follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:440 cefda7c92c044dda90401765534ac840
msgid ""
"From the signature,  we can see that this is a type constructor that takes a"
" ``Nat``, and produces a type. So this is not a set in the sense of a "
"collection that is a container of objects, rather it is the canonical set of"
" unnamed elements, as in \"the set of 5 elements,\" for example. "
"Effectively, it is a type that captures integers that fall into the range of"
" zero to ``(n - 1)`` where ``n`` is the argument used to instantiate the "
"``Fin`` type. For example, ``Fin 5`` can be thought of as the type of "
"integers between 0 and 4."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:447 13d6f4a8b5ba4e5abf2cabd9f8ad596f
msgid "Let us look at the constructors in greater detail."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:449 feea9a1d7bfd4266ac82a4930318118b
msgid ""
"``FZ`` is the zeroth element of a finite set with ``S k`` elements; ``FS n``"
" is the ``n+1``\\ th element of a finite set with ``S k`` elements. ``Fin`` "
"is indexed by a ``Nat``, which represents the number of elements in the set."
" Since we can’t construct an element of an empty set, neither constructor "
"targets ``Fin Z``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:455 e748f68b31894b4daf18edb2675a375e
msgid ""
"As mentioned above, a useful application of the ``Fin`` family is to "
"represent bounded natural numbers. Since the first ``n`` natural numbers "
"form a finite set of ``n`` elements, we can treat ``Fin n`` as the set of "
"integers greater than or equal to zero and less than ``n``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:460 c136bd411f7d4d89abe61d78026642f1
msgid ""
"For example, the following function which looks up an element in a ``Vect``,"
" by a bounded index given as a ``Fin n``, is defined in the prelude:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:470 881fd15c022d4f20bd4bc2e1021bd78c
msgid ""
"This function looks up a value at a given location in a vector. The location"
" is bounded by the length of the vector (``n`` in each case), so there is no"
" need for a run-time bounds check. The type checker guarantees that the "
"location is no larger than the length of the vector, and of course no less "
"than zero."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:476 12b69facc3844d56a438aa99fe7a9184
msgid ""
"Note also that there is no case for ``Nil`` here. This is because it is "
"impossible. Since there is no element of ``Fin Z``, and the location is a "
"``Fin n``, then ``n`` can not be ``Z``. As a result, attempting to look up "
"an element in an empty vector would give a compile time type error, since it"
" would force ``n`` to be ``Z``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:483 4e23351f9f8844b5b1f7d527dbb09ca8
msgid "Implicit Arguments"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:485 ae548052c79947c2be510074c3a00625
msgid "Let us take a closer look at the type of ``index``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:491 4a594a3643764932a4c652685b55e56e
msgid ""
"It takes two arguments, an element of the finite set of ``n`` elements, and "
"a vector with ``n`` elements of type ``a``. But there are also two names, "
"``n`` and ``a``, which are not declared explicitly. These are *implicit* "
"arguments to ``index``. We could also write the type of ``index`` as:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:501 fc9ce79eb8444839bf3b9cd0f43a4ced
msgid ""
"Implicit arguments, given with the ``forall`` declaration, are not given in "
"applications of ``index``; their values can be inferred from the types of "
"the ``Fin n`` and ``Vect n a`` arguments. Any name beginning with a lower "
"case letter which appears as a parameter or index in a type declaration, "
"which is not applied to any arguments, will *always* be automatically bound "
"as an implicit argument; this is why data type names cannot begin with a "
"lower case letter. Implicit arguments can still be given explicitly in "
"applications, using ``{a=value}`` and ``{n=value}``, for example:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:517 4e8fb1578718437fa86bcec0ac4b6187
msgid ""
"In fact, any argument, implicit or explicit, may be given a name. We could "
"have declared the type of ``index`` as:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:524 dd8a6197dbd74bcbadd0e1ba1b49aca9
msgid ""
"It is a matter of taste whether you want to do this — sometimes it can help "
"document a function by making the purpose of an argument more clear."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:528 1f2a2065d25d407cb0e34d25b4cbeb43
msgid ""
"The names of implicit arguments are in scope in the body of the function, "
"although they cannot be used at run time. There is much more to say about "
"implicit arguments - we will discuss the question of what is available at "
"run time, among other things, in Section :ref:`sect-multiplicities`"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:534 71e6159ac136491aac4349def4471c74
msgid "Note: Declaration Order and ``mutual`` blocks"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:536 9d0e5d7dfa384a3ab45076b980e5e295
msgid ""
"In general, functions and data types must be defined before use, since "
"dependent types allow functions to appear as part of types, and type "
"checking can rely on how particular functions are defined (though this is "
"only true of total functions; see Section :ref:`sect-totality`). However, "
"this restriction can be relaxed by using a ``mutual`` block, which allows "
"data types and functions to be defined simultaneously:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:554 1e50740f260e49f2ab49222ecf839c49
msgid ""
"In a ``mutual`` block, first all of the type declarations are added, then "
"the function bodies. As a result, none of the function types can depend on "
"the reduction behaviour of any of the functions in the block."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:559 04b890f801174aaa9e0961da9bb4856c
msgid ""
"Forward declarations can allow you to have more fine-grained control over "
"the order in which mutually defined concepts are declared. This can be "
"useful if you need to mention a datatype's constructor in the type of a "
"mutually defined function, or need to rely on the behaviour of a mutually "
"defined function for something to typecheck."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:602 9a6da6537c214a3c89c9a1930ea6ada1
msgid ""
"Placing signature declarations forward can suggest Idris to detect their "
"corresponding mutual definitions."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:606 953a639c17834b1686f9573889674ab0
msgid "I/O"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:608 56090831dece46eab178e8fb8804fce6
msgid ""
"Computer programs are of little use if they do not interact with the user or"
" the system in some way. The difficulty in a pure language such as Idris — "
"that is, a language where expressions do not have side-effects — is that I/O"
" is inherently side-effecting. So, Idris provides a parameterised type "
"``IO`` which *describes* the interactions that the run-time system will "
"perform when executing a function:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:619 bce1c9fbc69a419abc441e0c646ce49f
msgid ""
"We’ll leave the definition of ``IO`` abstract, but effectively it describes "
"what the I/O operations to be executed are, rather than how to execute them."
" The resulting operations are executed externally, by the run-time system. "
"We’ve already seen one I/O program:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:629 2104b38ba729467a9948e21b0b306463
msgid ""
"The type of ``putStrLn`` explains that it takes a string, and returns an I/O"
" action which produces an element of the unit type ``()``. There is a "
"variant ``putStr`` which decribes the output of a string without a newline:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:638 167aeaa70acb41eca9d4da707eff3f5a
msgid "We can also read strings from user input:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:644 05d47899721f42de9e4ee1af29a8df9d
msgid ""
"A number of other I/O operations are available. For example, by adding "
"``import System.File`` to your program, you get access to functions for "
"reading and writing files, including:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:660 e1ff4240c38344418678188d3403d271
msgid "Note that several of these return ``Either``, since they may fail."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:665 26845935c3f34b5d840b2472cf71cbad
msgid "“``do``” notation"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:667 be067a6585db4e6190b9f454d03f2540
msgid ""
"I/O programs will typically need to sequence actions, feeding the output of "
"one computation into the input of the next. ``IO`` is an abstract type, "
"however, so we can’t access the result of a computation directly. Instead, "
"we sequence operations with ``do`` notation:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:679 e780cd06647947fca9a6a0d5bfcd2a42
msgid ""
"The syntax ``x <- iovalue`` executes the I/O operation ``iovalue``, of type "
"``IO a``, and puts the result, of type ``a`` into the variable ``x``. In "
"this case, ``getLine`` returns an ``IO String``, so ``name`` has type "
"``String``. Indentation is significant — each statement in the do block must"
" begin in the same column. The ``pure`` operation allows us to inject a "
"value directly into an IO operation:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:690 ce1239b7bee44ffda8a9b64182a01540
msgid ""
"As we will see later, ``do`` notation is more general than this, and can be "
"overloaded."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:693 99430d8183424ffaac44b96cca37c168
msgid ""
"You can try executing ``greet`` at the Idris 2 REPL by running the command "
"``:exec greet``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:704 acfc5853bc714e2486d52ffe1f8d3dbf
msgid "Laziness"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:706 f15aea90d4af444aa4c9fc5e3b6358bc
msgid ""
"Normally, arguments to functions are evaluated before the function itself "
"(that is, Idris uses *eager* evaluation). However, this is not always the "
"best approach. Consider the following function:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:716 3fb52069e24e4347a7fff0db1207d161
msgid ""
"This function uses one of the ``t`` or ``e`` arguments, but not both. We "
"would prefer if *only* the argument which was used was evaluated. To achieve"
" this, Idris provides a ``Lazy`` primitive, which allows evaluation to be "
"suspended. It is a primitive, but conceptually we can think of it as "
"follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:728 4e2d0b0c32ed4cb68641a618f879bdad
msgid ""
"A value of type ``Lazy a`` is unevaluated until it is forced by ``Force``. "
"The Idris type checker knows about the ``Lazy`` type, and inserts "
"conversions where necessary between ``Lazy a`` and ``a``, and vice versa. We"
" can therefore write ``ifThenElse`` as follows, without any explicit use of "
"``Force`` or ``Delay``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:741 04aa9becff1c4b85a6d8acd23dcaf6f7
msgid "Infinite data Types"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:743 ad922d31944c4268838987581a4e442e
msgid ""
"Infinite data types (codata) allow us to define infinite data structures by "
"marking recursive arguments as potentially infinite. One example of an "
"infinite type is Stream, which is defined as follows."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:752 8cff199642994bd2817412349742decc
msgid ""
"The following is an example of how the codata type ``Stream`` can be used to"
" form an infinite data structure. In this case we are creating an infinite "
"stream of ones."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:762 95fcb491526f4a6291cbe89212c044e6
msgid "Useful Data Types"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:764 d9d717ff9a7f42aaaa5b909219f311dd
msgid ""
"Idris includes a number of useful data types and library functions (see the "
"``libs/`` directory in the distribution, and the `documentation "
"<https://www.idris-lang.org/pages/documentation.html>`_). This section "
"describes a few of these, and how to import them."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:770 f941eb88370a4f879cab81d65a055ea1
msgid "``List`` and ``Vect``"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:772 6b4f156154774d08b4e6b4def62ee12e
msgid "We have already seen the ``List`` and ``Vect`` data types:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:782 8fcb81d9105e4256807c356d7cf76b5a
msgid ""
"You can get access to ``Vect`` with ``import Data.Vect``. Note that the "
"constructor names are the same for each — constructor names (in fact, names "
"in general) can be overloaded, provided that they are declared in different "
"namespaces (see Section :ref:`sect-namespaces`), and will typically be "
"resolved according to their type. As syntactic sugar, any implementation of "
"the names ``Nil`` and ``::`` can be written in list form. For example:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:790 eb69b09b95004211b338ef6671326e86
msgid "``[]`` means ``Nil``"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:792 f015e033a7e24cebbdc40405d9fc5b3e
msgid "``[1,2,3]`` means ``1 :: 2 :: 3 :: Nil``"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:794 982881bbb15848469cd544228014c986
msgid ""
"Similarly, any implementation of the names ``Lin`` and ``:<`` can be written"
" in **snoc**-list form:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:797 c8d0fed7baa24419bac0e19b2794cd23
msgid "``[<]`` mean ``Lin``"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:798 75b47c6b9beb45988f633a5742d3d2a5
msgid "``[< 1, 2, 3]`` means ``Lin :< 1 :< 2 :< 3``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:800 098d8b70cb7f4d4486b6ba6030a1d270
msgid "and the prelude includes a pre-defined datatype for snoc-lists:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:807 49bf5786e5e640e78c9482799a5d6d68
msgid ""
"The library also defines a number of functions for manipulating these types."
" ``map`` is overloaded both for ``List`` and ``Vect`` (we'll see more "
"details of precisely how later when we cover interfaces in Section "
":ref:`sect-interfaces`) and applies a function to every element of the list "
"or vector."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:823 bc8a8c9d31054a708b6b46cac54a8d52
msgid ""
"For example, given the following vector of integers, and a function to "
"double an integer:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:834 f57027a4ca364d389cf8294a3eca512a
msgid ""
"the function ``map`` can be used as follows to double every element in the "
"vector:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:842 9ea28e896f3a4868b7dd2691cdef12bf
msgid ""
"For more details of the functions available on ``List`` and ``Vect``, look "
"in the library files:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:845 7cbb428e4e7e4e498b79beab99354ed1
msgid "``libs/base/Data/List.idr``"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:847 f673be1f92f448b2934f5313e307fb7d
msgid "``libs/base/Data/Vect.idr``"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:849 c1e4503ef26d42c19d60e8bcb3099326
msgid "Functions include filtering, appending, reversing, and so on."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:852 9f489d65f9c745488a9d0df659914b90
msgid "Aside: Anonymous functions and operator sections"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:854 24e99de770934f85aad67f87d872b030
msgid ""
"There are neater ways to write the above expression. One way would be to use"
" an anonymous function:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:862 7d303ad031f249b9a2f2410b1a40cb28
msgid ""
"The notation ``\\x => val`` constructs an anonymous function which takes one"
" argument, ``x`` and returns the expression ``val``. Anonymous functions may"
" take several arguments, separated by commas, e.g. ``\\x, y, z => val``. "
"Arguments may also be given explicit types, e.g. ``\\x : Int => x * 2``, and"
" can pattern match, e.g. ``\\(x, y) => x + y``. We could also use an "
"operator section:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:874 d7f4ebc9ea8e4340983573571dcd8fec
msgid ""
"``(*2)`` is shorthand for a function which multiplies a number by 2. It "
"expands to ``\\x => x * 2``. Similarly, ``(2*)`` would expand to ``\\x => 2 "
"* x``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:879 20efa38f81cf4e4ea0dd6c5bcbb618cf
msgid "Maybe"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:881 4f0a128a65f24d6eb502e65dd3185622
msgid ""
"``Maybe``, defined in the Prelude, describes an optional value. Either there"
" is a value of the given type, or there isn’t:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:888 fed64e0ba27d419e9fc0edda14fe1bc1
msgid ""
"``Maybe`` is one way of giving a type to an operation that may fail. For "
"example, looking something up in a ``List`` (rather than a vector) may "
"result in an out of bounds error:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:899 2e0800df643541da8a5376c671638cf6
msgid ""
"The ``maybe`` function is used to process values of type ``Maybe``, either "
"by applying a function to the value, if there is one, or by providing a "
"default value:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:907 48c7af1270ad4fcf8fb48e9e2e04c300
msgid ""
"Note that the types of the first two arguments are wrapped in ``Lazy``. "
"Since only one of the two arguments will actually be used, we mark them as "
"``Lazy`` in case they are large expressions where it would be wasteful to "
"compute and then discard them."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:913 6d70c805747e499584cb4ea5f43fcc86
msgid "Tuples"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:915 ecf6a07d811a4237a37aecb5bce9bbff
msgid "Values can be paired with the following built-in data type:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:921 ac809c323b1344c7beb774ccbfd2a232
msgid ""
"As syntactic sugar, we can write ``(a, b)`` which, according to context, "
"means either ``Pair a b`` or ``MkPair a b``. Tuples can contain an arbitrary"
" number of values, represented as nested pairs:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:943 0fcb1040b4a74bfe8a7cada2ab105d21
msgid "Dependent Pairs"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:945 0b4c7ed80bb5422a81eed99ac16d08d8
msgid ""
"Dependent pairs allow the type of the second element of a pair to depend on "
"the value of the first element:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:953 5c63122fd5fb4027bf9eb971bb50ba87
msgid ""
"Again, there is syntactic sugar for this. ``(x : a ** p)`` is the type of a "
"pair of A and P, where the name ``x`` can occur inside ``p``. ``( x ** p )``"
" constructs a value of this type. For example, we can pair a number with a "
"``Vect`` of a particular length:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:963 35c72bdb524e42758b6127018c9e3d16
msgid ""
"If you like, you can write it out the long way; the two are equivalent:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:970 4233363971c34981bb776c2b05876250
msgid ""
"The type checker could infer the value of the first element from the length "
"of the vector. We can write an underscore ``_`` in place of values which we "
"expect the type checker to fill in, so the above definition could also be "
"written as:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:980 fea3898488db4a6896d40826c8e808d2
msgid ""
"We might also prefer to omit the type of the first element of the pair, "
"since, again, it can be inferred:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:988 9007eb7b50904e00b8d36580d0c28062
msgid ""
"One use for dependent pairs is to return values of dependent types where the"
" index is not necessarily known in advance. For example, if we filter "
"elements out of a ``Vect`` according to some predicate, we will not know in "
"advance what the length of the resulting vector will be:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:998 400d194ae9db4cb8afc4a78918b77043
msgid "If the ``Vect`` is empty, the result is:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1004 85aa89279b714475874c74806028ac17
msgid ""
"In the ``::`` case, we need to inspect the result of a recursive call to "
"``filter`` to extract the length and the vector from the result. To do this,"
" we use a ``case`` expression, which allows pattern matching on intermediate"
" values:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1018 a496b587cce14aaab826e16dfc4575d8
msgid "Dependent pairs are sometimes referred to as “Sigma types”."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1021 28445edc00d643e6823bf866a729603b
msgid "Records"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1023 40a2362ff76345d5a1800a92f8194b17
msgid ""
"*Records* are data types which collect several values (the record's "
"*fields*) together. Idris provides syntax for defining records and "
"automatically generating field access and update functions. Unlike the "
"syntax used for data structures, records in Idris follow a different syntax "
"to that seen with Haskell. For example, we can represent a person’s name and"
" age in a record:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1039 a947b4cd326547f3ad88d8362b573eaa
msgid ""
"The constructor name is provided using the ``constructor`` keyword, and the "
"*fields* are then given which are in an indented block following the `where`"
" keyword (here, ``firstName``, ``middleName``, ``lastName``, and ``age``). "
"You can declare multiple fields on a single line, provided that they have "
"the same type. The field names can be used to access the field values:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1054 68b1d9c12a394ce58e1adf5aa2f63678
msgid "We can use prefix field projections, like in Haskell:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1065 0fce4a72adad480398e993b59840f6cc
msgid ""
"Prefix field projections can be disabled per record definition using pragma "
"``%prefix_record_projections off``, which makes all subsequently defined "
"records generate only dotted projections. This pragma has effect until the "
"end of the module or until the closest occurrence of "
"``%prefix_record_projections on``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1071 995a715813a34304997415f145164a89
msgid ""
"We can also use the field names to update a record (or, more precisely, "
"produce a copy of the record with the given fields updated):"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1082 ce305d2931554c7997d513c850e58f1e
msgid ""
"The syntax ``{ field := val, ... }`` generates a function which updates the "
"given fields in a record. ``:=`` assigns a new value to a field, and ``$=`` "
"applies a function to update its value."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1086 7d31a9d2baf540ba9f6364793d667712
msgid ""
"Each record is defined in its own namespace, which means that field names "
"can be reused in multiple records."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1089 6924d0833a404fffac4a875198f19de8
msgid ""
"Records, and fields within records, can have dependent types. Updates are "
"allowed to change the type of a field, provided that the result is well-"
"typed."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1100 15398f26f5004171a8ad62eaae799b54
msgid ""
"It is safe to update the ``students`` field to a vector of a different "
"length because it will not affect the type of the record:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1113 f48564e4b0c34ce4977035a2970d4c23
msgid "We could also use ``$=`` to define ``addStudent`` more concisely:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1121 ec04b75a38814eb89ec6fcc84712e923
msgid "Nested record projection"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1123 4bef749c9f6843a9aa0d46cbed900e9f
msgid "Nested record fields can be accessed using the dot notation:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1130 e5d54a42c57e4d69bf1f3bafb7a9f3e9
msgid ""
"For the dot notation, there must be no spaces after the dots but there may "
"be spaces before the dots. The composite projection must be parenthesised, "
"otherwise ``map .a.b.c xs`` would be understood as ``map.a.b.c xs``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1134 817ef356681a4a61bf84956997e4afeb
msgid "Nested record fields can be accessed using the prefix notation, too:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1141 3f06e1a701d4471ca504d6a69bfbd265
msgid "Dots with spaces around them stand for function composition operators."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1144 0fd3955931304f789e1afe3963433820
msgid "Nested record update"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1146 b2f42aaeb6334a10a335a656d7f33c20
msgid ""
"Idris also provides a convenient syntax for accessing and updating nested "
"records. For example, if a field is accessible with the expression "
"``x.a.b.c``, it can be updated using the following syntax:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1155 9f818b412b304e74a9781b40fc2a8519
msgid ""
"This returns a new record, with the field accessed by the path ``a.b.c`` set"
" to ``val``. The syntax is first class, i.e. ``{ a.b.c := val }`` itself has"
" a function type."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1159 06afaf4616a343b9ab02eb9b9d5dbaf9
msgid "The ``$=`` notation is also valid for nested record updates."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1162 3e23ba2e75c94e539ef5b131309a5e77
msgid "Dependent Records"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1164 21b8885897c94070b2027651d39c8fc5
msgid ""
"Records can also be dependent on values. Records have *parameters*, which "
"cannot be updated like the other fields. The parameters appear as arguments "
"to the resulting type, and are written following the record type name. For "
"example, a pair type could be defined as follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1176 e8d4293d7ced44a7b26a747a2695f1c7
msgid ""
"Using the ``Class`` record from earlier, the size of the class can be "
"restricted using a ``Vect`` and the size included in the type by "
"parameterising the record with the size.  For example:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1187 3c41a582cff942fd83f522e1b63dbfab
msgid ""
"In the case of ``addStudent`` earlier, we can still add a student to a "
"``SizedClass`` since the size is implicit, and will be updated when a "
"student is added:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1196 7f6bb7f6983048ed9fa19df59ebf6981
msgid ""
"In fact, the dependent pair type we have just seen is, in practice, defined "
"as a record, with fields ``fst`` and ``snd`` which allow projecting values "
"out of the pair:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1207 96664233dfc34452866e642d2182cf70
msgid ""
"It is possible to use record update syntax to update dependent fields, "
"provided that all related fields are updated at once. For example:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1217 a4fabe57d83d46789eefa55a8da7e11d
msgid "Or even:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1230 93de1bc4e2b44c48add6c81eb0a8874d
msgid "More Expressions"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1235 a8ad953aea2d437ead4629e36d8a64c9
msgid "``let`` bindings"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1237 c9dfea52d92d4441b5124c084afb468e
msgid "Intermediate values can be calculated using ``let`` bindings:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1245 1310dc4f599a40dbbaf44a23735148d4
msgid ""
"We can do pattern matching in ``let`` bindings too. For example, we can "
"extract fields from a record as follows, as well as by pattern matching at "
"the top level:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1257 3bf8f73ce1d347528186622c946b4347
msgid "These let bindings can be annotated with a type:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1265 626950aa096d40198f9e4f3ef5d253ad
msgid ""
"We can also use the symbol ``:=`` instead of ``=`` to, among other things, "
"avoid ambiguities with propositional equality:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1273 320ce9d23fe44b618f5c67837838d1a3
msgid ""
"Local definitions can also be introduced using ``let``. Just like top level "
"ones and ones defined in a ``where`` clause you need to:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1276 931452047f1e465783ce1c68cc845b54
msgid "declare the function and its type"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1277 7e8e7402b8d9433b9b86bf8ebe1800dc
msgid "define the function by pattern matching"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1286 23745cd6553d4241a3fe87dd94be9414
msgid ""
"The symbol ``:=`` cannot be used in a local function definition. Which means"
" that it can be used to interleave let bindings and local definitions "
"without introducing ambiguities."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1301 ecb9ee3b06434a3398737baa4b6d680d
msgid "List comprehensions"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1303 4b8eca59e8c0479ab354bb84e71d5741
msgid ""
"Idris provides *comprehension* notation as a convenient shorthand for "
"building lists. The general form is:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1310 01912b4d531948c4a651ba234d9c3b1e
msgid ""
"This generates the list of values produced by evaluating the ``expression``,"
" according to the conditions given by the comma separated ``qualifiers``. "
"For example, we can build a list of Pythagorean triples as follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1321 ee8f4055a6ea4cb19080b0fa9ac0fc06
msgid ""
"The ``[a..b]`` notation is another shorthand which builds a list of numbers "
"between ``a`` and ``b``. Alternatively ``[a,b..c]`` builds a list of numbers"
" between ``a`` and ``c`` with the increment specified by the difference "
"between ``a`` and ``b``. This works for type ``Nat``, ``Int`` and "
"``Integer``, using the ``enumFromTo`` and ``enumFromThenTo`` function from "
"the prelude."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1329 c65bd7ee4ecf495683fac1f44f2c6893
msgid "``case`` expressions"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1331 d58b9a65a8724a4bb1388afca4b73cf0
msgid ""
"Another way of inspecting intermediate values is to use a ``case`` "
"expression. The following function, for example, splits a string into two at"
" a given character:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1341 b560b76f54974170b4c885947eb6e180
msgid ""
"``break`` is a library function which breaks a string into a pair of strings"
" at the point where the given function returns true. We then deconstruct the"
" pair it returns, and remove the first character of the second string."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1346 47b16651478d482dae41b64cce1b4fb8
msgid ""
"A ``case`` expression can match several cases, for example, to inspect an "
"intermediate value of type ``Maybe a``. Recall ``list_lookup`` which looks "
"up an index in a list, returning ``Nothing`` if the index is out of bounds. "
"We can use this to write ``lookup_default``, which looks up an index and "
"returns a default value if the index is out of bounds:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1360 49d74dbf54694b438a5e42efff7c9a64
msgid ""
"If the index is in bounds, we get the value at that index, otherwise we get "
"a default value:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1371 ca3e1b4036f64f53a4fb368424cc27d3
msgid "Totality"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1373 ca6a64671d7741968d6a1969349d2fee
msgid ""
"Idris distinguishes between *total* and *partial* functions. A total "
"function is a function that either:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1376 8dc3d4b9b72d47e3ae5a6f03db477920
msgid "Terminates for all possible inputs, or"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1377 24e4f60d592b4928b93e5b3e08fb7d5a
msgid "Produces a non-empty, finite, prefix of a possibly infinite result"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1379 20d0805b2961422db9a485b895444f5b
msgid ""
"If a function is total, we can consider its type a precise description of "
"what that function will do. For example, if we have a function with a return"
" type of ``String`` we know something different, depending on whether or not"
" it's total:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1384 901b2dfeebb64ed5919f86f8872d5fdd
msgid ""
"If it's total, it will return a value of type ``String`` in finite time;"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1385 2108596dfc394d14a211e36f356bf708
msgid ""
"If it's partial, then as long as it doesn't crash or enter an infinite loop,"
" it will return a ``String``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1388 0e3052f7dc1248f7a3e28fa3a5238a21
msgid ""
"Idris makes this distinction so that it knows which functions are safe to "
"evaluate while type checking (as we've seen with :ref:`sect-fctypes`). After"
" all, if it tries to evaluate a function during type checking which doesn't "
"terminate, then type checking won't terminate! Therefore, only total "
"functions will be evaluated during type checking. Partial functions can "
"still be used in types, but will not be evaluated further."
msgstr ""
