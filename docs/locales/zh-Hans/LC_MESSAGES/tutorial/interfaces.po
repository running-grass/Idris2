# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 11:10+0800\n"
"PO-Revision-Date: 2022-07-13 15:21+0000\n"
"Language-Team: Chinese Simplified (https://www.transifex.com/idriszhong-wen/teams/140912/zh-Hans/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh-Hans\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../source/tutorial/interfaces.rst:5 81fbbe3ced404f2e958f4187a9ae2f95
msgid "Interfaces"
msgstr ""

#: ../../source/tutorial/interfaces.rst:7 566e24c6903c4ababf8db67d773da361
msgid ""
"We often want to define functions which work across several different data "
"types. For example, we would like arithmetic operators to work on ``Int``, "
"``Integer`` and ``Double`` at the very least. We would like ``==`` to work "
"on the majority of data types. We would like to be able to display different"
" types in a uniform way."
msgstr ""

#: ../../source/tutorial/interfaces.rst:13 906ac8e6c8ea482dbaab2d38b7e3e8d4
msgid ""
"To achieve this, we use *interfaces*, which are similar to type classes in "
"Haskell or traits in Rust. To define an interface, we provide a collection "
"of overloadable functions. A simple example is the ``Show`` interface, which"
" is defined in the prelude and provides an interface for converting values "
"to ``String``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:24 fde6b8de03e0413783a2aee66143cb3f
msgid ""
"This generates a function of the following type (which we call a *method* of"
" the ``Show`` interface):"
msgstr ""

#: ../../source/tutorial/interfaces.rst:31 cba4291529ca40e28dd73a3ffdf5931c
msgid ""
"We can read this as: “under the constraint that ``a`` has an implementation "
"of ``Show``, take an input ``a`` and return a ``String``.” An implementation"
" of an interface is defined by giving definitions of the methods of the "
"interface. For example, the ``Show`` implementation for ``Nat`` could be "
"defined as:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:47 62533bca142b4e9abed6d18e26944f9b
msgid ""
"Only one implementation of an interface can be given for a type — "
"implementations may not overlap. Implementation declarations can themselves "
"have constraints. To help with resolution, the arguments of an "
"implementation must be constructors (either data or type constructors) or "
"variables (i.e. you cannot give an implementation for a function). For "
"example, to define a ``Show`` implementation for vectors, we need to know "
"that there is a ``Show`` implementation for the element type, because we are"
" going to use it to convert each element to a ``String``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:65 a671917f2d7c4d46a6389450da4ac414
msgid ""
"Note that we need the explicit ``forall n .`` in the ``show'`` function "
"because otherwise the ``n`` is already in scope, and fixed to the value of "
"the top level ``n``."
msgstr ""

#: ../../source/tutorial/interfaces.rst:70 f2c909f0a12c4e65920882c48cf9286e
msgid "Default Definitions"
msgstr ""

#: ../../source/tutorial/interfaces.rst:72 221f953472f842bfb4c5b1ec62393589
msgid ""
"The Prelude defines an ``Eq`` interface which provides methods for comparing"
" values for equality or inequality, with implementations for all of the "
"built-in types:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:82 f99cd84e47694bdd9061ba3f78a42dd9
msgid ""
"To declare an implementation for a type, we have to give definitions of all "
"of the methods. For example, for an implementation of ``Eq`` for ``Nat``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:95 58a43c45e21b4d71adb87f5cfeacc471
msgid ""
"It is hard to imagine many cases where the ``/=`` method will be anything "
"other than the negation of the result of applying the ``==`` method. It is "
"therefore convenient to give a default definition for each method in the "
"interface declaration, in terms of the other method:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:109 ce304bb0625d4388bef25f8373ccdecd
msgid ""
"A minimal complete implementation of ``Eq`` requires either ``==`` or ``/=``"
" to be defined, but does not require both. If a method definition is "
"missing, and there is a default definition for it, then the default is used "
"instead."
msgstr ""

#: ../../source/tutorial/interfaces.rst:115 c46b0c29e4514f89af1e9c203d480876
msgid "Extending Interfaces"
msgstr ""

#: ../../source/tutorial/interfaces.rst:117 12b1417231224d8ca6a3de8b93de86db
msgid ""
"Interfaces can also be extended. A logical next step from an equality "
"relation ``Eq`` is to define an ordering relation ``Ord``. We can define an "
"``Ord`` interface which inherits methods from ``Eq`` as well as defining "
"some of its own:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:138 3a0e24c5a63248c8ac8505d74cd56767
msgid ""
"The ``Ord`` interface allows us to compare two values and determine their "
"ordering. Only the ``compare`` method is required; every other method has a "
"default definition. Using this we can write functions such as ``sort``, a "
"function which sorts a list into increasing order, provided that the element"
" type of the list is in the ``Ord`` interface. We give the constraints on "
"the type variables left of the fat arrow ``=>``, and the function type to "
"the right of the fat arrow:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:150 d722f474afa449bf85af6b4514a9c712
msgid ""
"Functions, interfaces and implementations can have multiple constraints. "
"Multiple constraints are written in brackets in a comma separated list, for "
"example:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:159 e89d437d9a504e94875bbcfa43f112e5
msgid ""
"Constraints are, like types, first class objects in the language. You can "
"see this at the REPL:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:167 fad2cba11f6542229ed53bc8d23efc77
msgid ""
"So, ``(Ord a, Show a)`` is an ordinary pair of ``Types``, with two "
"constraints as the first and second element of the pair."
msgstr ""

#: ../../source/tutorial/interfaces.rst:171 0cd32f24e362491ab5b3101ca157e2c9
msgid "Note: Interfaces and ``mutual`` blocks"
msgstr ""

#: ../../source/tutorial/interfaces.rst:173 a087799745c7400eaab97bdbd6e3fed1
msgid ""
"Idris is strictly \"define before use\", except in ``mutual`` blocks. In a "
"``mutual`` block, Idris elaborates in two passes: types on the first pass "
"and definitions on the second. When the mutual block contains an interface "
"declaration, it elaborates the interface header but none of the method types"
" on the first pass, and elaborates the method types and any default "
"definitions on the second pass."
msgstr ""

#: ../../source/tutorial/interfaces.rst:181 a32915be6a044927b1d9945f195854bd
msgid "Quantities for Parameters"
msgstr ""

#: ../../source/tutorial/interfaces.rst:183 ded9ef99e3034d5abc1ed3f233d6b4ec
msgid ""
"By default parameters that are not explicitly ascribed a type in an "
"``interface`` declaration are assigned the quantity ``0``. This means that "
"the parameter is not available to use at runtime in the methods' "
"definitions."
msgstr ""

#: ../../source/tutorial/interfaces.rst:187 f19074a07efa4ca29601314ccbef3a9e
msgid ""
"For instance, ``Show a`` gives rise to a ``0``-quantified type variable "
"``a`` in the type of the ``show`` method:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:196 ae85e4217a964e8db905f7288755cee6
msgid ""
"However some use cases require that some of the parameters are available at "
"runtime. We may for instance want to declare an interface for ``Storable`` "
"types. The constraint ``Storable a size`` means that we can store values of "
"type ``a`` in a ``Buffer`` in exactly ``size`` bytes."
msgstr ""

#: ../../source/tutorial/interfaces.rst:201 069ddb0da6cd4c3db5ebf897a3ab65c4
msgid ""
"If the user provides a method to read a value for such a type ``a`` at a "
"given offset, then we can read the ``k`` th element stored in the buffer by "
"computing the appropriate offset from ``k`` and ``size``. This is "
"demonstrated by providing a default implementation for the method "
"``peekElementOff`` implemented in terms of ``peekByteOff`` and the parameter"
" ``size``."
msgstr ""

#: ../../source/tutorial/interfaces.rst:219 e2b0bdcfcf774c0688b57fc7e92633fd
msgid ""
"Note that ``a`` is explicitly marked as runtime irrelevant so that it is "
"erased by the compiler. Equivalently we could have written ``interface "
"Storable a (size : Nat)``. The meaning of ``| a`` is explained in "
":ref:`DeterminingParameters`."
msgstr ""

#: ../../source/tutorial/interfaces.rst:225 ebf30f75c5b54c04a97cdba5a01637e7
msgid "Functors and Applicatives"
msgstr ""

#: ../../source/tutorial/interfaces.rst:227 bc7fccbb6e0e458999fbec8556596edb
msgid ""
"So far, we have seen single parameter interfaces, where the parameter is of "
"type ``Type``. In general, there can be any number of parameters (even "
"zero), and the parameters can have *any* type. If the type of the parameter "
"is not ``Type``, we need to give an explicit type declaration. For example, "
"the ``Functor`` interface is defined in the prelude:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:240 181134a62ae04fc7b7c21815ea9122df
msgid ""
"A functor allows a function to be applied across a structure, for example to"
" apply a function to every element in a ``List``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:254 423c2b3b3c804eef92deb0fcd907b7fa
msgid ""
"Having defined ``Functor``, we can define ``Applicative`` which abstracts "
"the notion of function application:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:268 307e973a6baf4a62be4d79b0846e7daf
msgid "Monads and ``do``-notation"
msgstr ""

#: ../../source/tutorial/interfaces.rst:270 ae6ef1d127834140b68d9d43985b8759
msgid ""
"The ``Monad`` interface allows us to encapsulate binding and computation, "
"and is the basis of ``do``-notation introduced in Section :ref:`sect-do`. It"
" extends ``Applicative`` as defined above, and is defined as follows:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:280 1399f771dbaa478fba0cbe31846bb244
msgid ""
"There is also a non-binding sequencing operator, defined for ``Monad`` as:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:286 e6eea63f4b3b4c7c90dd9efec2834d1d
msgid ""
"Inside a ``do`` block, the following syntactic transformations are applied:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:289 d300beded1f14630b1b405d8c66bee01
msgid "``x <- v; e`` becomes ``v >>= (\\x => e)``"
msgstr ""

#: ../../source/tutorial/interfaces.rst:291 3f8f4e38bd154b89aaa14dfe4969849e
msgid "``v; e`` becomes ``v >> e``"
msgstr ""

#: ../../source/tutorial/interfaces.rst:293 a5afb6c9805a4bb49712cc38b37f8a2a
msgid "``let x = v; e`` becomes ``let x = v in e``"
msgstr ""

#: ../../source/tutorial/interfaces.rst:295 89a88ee3fa2a41858215e02d6a9542ce
msgid ""
"``IO`` has an implementation of ``Monad``, defined using primitive "
"functions. We can also define an implementation for ``Maybe``, as follows:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:304 36f9312460c04e4dbf0481f3a69fca43
msgid ""
"Using this we can, for example, define a function which adds two ``Maybe "
"Int``, using the monad to encapsulate the error handling:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:314 60519b1a5083484a9d634a762ae528ef
msgid ""
"This function will extract the values from ``x`` and ``y``, if they are both"
" available, or return ``Nothing`` if one or both are not (\"fail fast\"). "
"Managing the ``Nothing`` cases is achieved by the ``>>=`` operator, hidden "
"by the ``do`` notation."
msgstr ""

#: ../../source/tutorial/interfaces.rst:326 7f4a5136b74540b093dc791088c09078
msgid ""
"The translation of ``do`` notation is entirely syntactic, so there is no "
"need for the ``(>>=)`` and ``(>>)`` operators to be the operator defined in "
"the ``Monad`` interface. Idris will, in general, try to disambiguate which "
"operators you mean by type, but you can explicitly choose with qualified do "
"notation, for example:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:340 10499e87429a4ba0b16ea45a305b31a3
msgid ""
"The ``Prelude.do`` means that Idris will use the ``(>>=)`` and ``(>>)`` "
"operators defined in the ``Prelude``."
msgstr ""

#: ../../source/tutorial/interfaces.rst:344 7aee92002658430193635000c4f410a3
msgid "Pattern Matching Bind"
msgstr ""

#: ../../source/tutorial/interfaces.rst:346 025d801000d44b7eb9119c9e87b3ce4c
msgid ""
"Sometimes we want to pattern match immediately on the result of a function "
"in ``do`` notation. For example, let's say we have a function ``readNumber``"
" which reads a number from the console, returning a value of the form ``Just"
" x`` if the number is valid, or ``Nothing`` otherwise:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:362 6c7bc2681cc744dfbb59c3db5c2860b7
msgid ""
"If we then use it to write a function to read two numbers, returning "
"``Nothing`` if neither are valid, then we would like to pattern match on the"
" result of ``readNumber``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:378 3b5ab2f4927f4e61864506487c3cc3ca
msgid ""
"If there's a lot of error handling, this could get deeply nested very "
"quickly! So instead, we can combine the bind and the pattern match in one "
"line. For example, we could try pattern matching on values of the form "
"``Just x_ok``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:390 80a04eed40434f3ebb64bb48827d5b83
msgid ""
"There is still a problem, however, because we've now omitted the case for "
"``Nothing`` so ``readNumbers`` is no longer total! We can add the "
"``Nothing`` case back as follows:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:404 4e35b0e17db944a5b500e27d7c024d04
msgid ""
"The effect of this version of ``readNumbers`` is identical to the first (in "
"fact, it is syntactic sugar for it and directly translated back into that "
"form). The first part of each statement (``Just x_ok <-`` and ``Just y_ok "
"<-``) gives the preferred binding - if this matches, execution will continue"
" with the rest of the ``do`` block. The second part gives the alternative "
"bindings, of which there may be more than one."
msgstr ""

#: ../../source/tutorial/interfaces.rst:412 c205e892b58644a5b1e5bdea5b32d829
msgid "``!``-notation"
msgstr ""

#: ../../source/tutorial/interfaces.rst:414 bd46d0a105504a2faf90c8bc5f1816d8
msgid ""
"In many cases, using ``do``-notation can make programs unnecessarily "
"verbose, particularly in cases such as ``m_add`` above where the value bound"
" is used once, immediately. In these cases, we can use a shorthand version, "
"as follows:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:424 65bbba0f39ff4a8cb1e2b14b13efe45a
msgid ""
"The notation ``!expr`` means that the expression ``expr`` should be "
"evaluated and then implicitly bound. Conceptually, we can think of ``!`` as "
"being a prefix function with the following type:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:432 08b78155de284f53ad320f60c6ed327a
msgid ""
"Note, however, that it is not really a function, merely syntax! In practice,"
" a subexpression ``!expr`` will lift ``expr`` as high as possible within its"
" current scope, bind it to a fresh name ``x``, and replace ``!expr`` with "
"``x``. Expressions are lifted depth first, left to right. In practice, "
"``!``-notation allows us to program in a more direct style, while still "
"giving a notational clue as to which expressions are monadic."
msgstr ""

#: ../../source/tutorial/interfaces.rst:440 c2cb7425acd443979d6141a05963d348
msgid "For example, the expression:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:446 0bfc477745244d0793c1023d4ce90899
msgid "is lifted to:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:456 cbf17c7ee1a54f37853dab45fd2587fd
msgid "Monad comprehensions"
msgstr ""

#: ../../source/tutorial/interfaces.rst:458 c8fed3127e524a75a158836517cefd3d
msgid ""
"The list comprehension notation we saw in Section :ref:`sect-more-expr` is "
"more general, and applies to anything which has an implementation of both "
"``Monad`` and ``Alternative``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:468 80a4cd37176b40d5b61be397ba5374d0
msgid ""
"In general, a comprehension takes the form ``[ exp | qual1, qual2, …, qualn "
"]`` where ``quali`` can be one of:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:471 e38801720f384c8a946492d0b8761513
msgid "A generator ``x <- e``"
msgstr ""

#: ../../source/tutorial/interfaces.rst:473 1752ddd62ab4444cbb475c6c0b83ad00
msgid "A *guard*, which is an expression of type ``Bool``"
msgstr ""

#: ../../source/tutorial/interfaces.rst:475 3aca342faabd47d88d89ae795dd3c7ba
msgid "A let binding ``let x = e``"
msgstr ""

#: ../../source/tutorial/interfaces.rst:477 f16893c568c2479fb186528e9c41e48f
msgid ""
"To translate a comprehension ``[exp | qual1, qual2, …, qualn]``, first any "
"qualifier ``qual`` which is a *guard* is translated to ``guard qual``, using"
" the following function:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:485 458eef3eb89d4ab8bfb122405f7473a2
msgid "Then the comprehension is converted to ``do`` notation:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:491 a4f838b9a8404e3e824feef2bc195a01
msgid ""
"Using monad comprehensions, an alternative definition for ``m_add`` would "
"be:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:500 3640d3d3d16c41419cd3d2c22cd17cbb
msgid "Interfaces and IO"
msgstr ""

#: ../../source/tutorial/interfaces.rst:502 32e5a6e0e04a456d9f5d010a4b9af39d
msgid ""
"In general, ``IO`` operations in the libraries aren't written using ``IO`` "
"directly, but rather via the ``HasIO`` interface:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:510 e6d32ed7c79643f292239d5bab5b8855
msgid ""
"``HasIO`` explains, via ``liftIO``, how to convert a primitive ``IO`` "
"operation to an operation in some underlying type, as long as that type has "
"a ``Monad`` implementation.  These interface allows a programmer to define "
"some more expressive notion of interactive program, while still giving "
"direct access to ``IO`` primitives."
msgstr ""

#: ../../source/tutorial/interfaces.rst:517 71d1f6bb991641ffad850fbfe18ef0f3
msgid "Idiom brackets"
msgstr ""

#: ../../source/tutorial/interfaces.rst:519 42e699b9d169438aa39bda2eff8ee85b
msgid ""
"While ``do`` notation gives an alternative meaning to sequencing, idioms "
"give an alternative meaning to *application*. The notation and larger "
"example in this section is inspired by Conor McBride and Ross Paterson’s "
"paper “Applicative Programming with Effects” [#ConorRoss]_."
msgstr ""

#: ../../source/tutorial/interfaces.rst:524 f23ee8f7139a42878688702848cdb4bc
msgid ""
"First, let us revisit ``m_add`` above. All it is really doing is applying an"
" operator to two values extracted from ``Maybe Int``. We could abstract out "
"the application:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:534 df6c67324f794cdab45bd14fe305245c
msgid ""
"Using this, we can write an alternative ``m_add`` which uses this "
"alternative notion of function application, with explicit calls to "
"``m_app``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:543 f32f68f7f47a479797404b97b91c327a
msgid ""
"Rather than having to insert ``m_app`` everywhere there is an application, "
"we can use idiom brackets to do the job for us. To do this, we can give "
"``Maybe`` an implementation of ``Applicative`` as follows, where ``<*>`` is "
"defined in the same way as ``m_app`` above (this is defined in the Idris "
"library):"
msgstr ""

#: ../../source/tutorial/interfaces.rst:557 70dedcf94e73405b953ba88f03fde493
msgid ""
"Using ``<*>`` we can use this implementation as follows, where a function "
"application ``[| f a1 …an |]`` is translated into ``pure f <*> a1 <*> … <*> "
"an``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:567 98c8feb8cb6d4d58ad4297549d70444e
msgid "An error-handling interpreter"
msgstr ""

#: ../../source/tutorial/interfaces.rst:569 5bfe6fce5aea4766a4ae475fe5e5cd8d
msgid ""
"Idiom notation is commonly useful when defining evaluators. McBride and "
"Paterson describe such an evaluator [#ConorRoss]_, for a language similar to"
" the following:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:579 945077148afb43fdaac6c256bc9b0124
msgid ""
"Evaluation will take place relative to a context mapping variables "
"(represented as ``String``\\s) to ``Int`` values, and can possibly fail. We "
"define a data type ``Eval`` to wrap an evaluator:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:588 43d8aa22651c4e4d89fbf57439e41eab
msgid ""
"Wrapping the evaluator in a data type means we will be able to provide "
"implementations of interfaces for it later. We begin by defining a function "
"to retrieve values from the context during evaluation:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:602 b7c058ac22064ea9a8bd2a387aba7c4f
msgid ""
"When defining an evaluator for the language, we will be applying functions "
"in the context of an ``Eval``, so it is natural to give ``Eval`` an "
"implementation of ``Applicative``. Before ``Eval`` can have an "
"implementation of ``Applicative`` it is necessary for ``Eval`` to have an "
"implementation of ``Functor``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:621 1d899f91135f4ebb992bf22c1e03e161
msgid ""
"Evaluating an expression can now make use of the idiomatic application to "
"handle errors:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:635 db05884c4fb04c7ebbd305cfd63915d7
msgid "For example:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:645 8e92b68cc29c4e1e9a0449c54f9943ce
msgid "Named Implementations"
msgstr ""

#: ../../source/tutorial/interfaces.rst:647 a47a1e3e76074607a23d04dc781e6d24
msgid ""
"It can be desirable to have multiple implementations of an interface for the"
" same type, for example to provide alternative methods for sorting or "
"printing values. To achieve this, implementations can be *named* as follows:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:659 34209e8462844c2088e068fb8c1fe24d
msgid ""
"This declares an implementation as normal, but with an explicit name, "
"``myord``. The syntax ``compare @{myord}`` gives an explicit implementation "
"to ``compare``, otherwise it would use the default implementation for "
"``Nat``. We can use this, for example, to sort a list of ``Nat`` in reverse."
" Given the following list:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:670 09570ce79d0344049489bbb27844d96e
msgid ""
"We can sort it using the default ``Ord`` implementation, by using the "
"``sort`` function available with ``import Data.List``, then we can try with "
"the named implementation ``myord`` as follows, at the Idris prompt:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:681 49557cdb09d341b58b35f90e5df0f381
msgid ""
"Sometimes, we also need access to a named parent implementation. For "
"example, the prelude defines the following ``Semigroup`` interface:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:689 3fb53545ba9f416b84785698337e5b83
msgid ""
"Then it defines ``Monoid``, which extends ``Semigroup`` with a “neutral” "
"value:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:697 0425bcbb85684dea977abb3f8c476a37
msgid ""
"We can define two different implementations of ``Semigroup`` and ``Monoid`` "
"for ``Nat``, one based on addition and one on multiplication:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:708 bf0794ee96c142a5967cd547345fe166
msgid ""
"The neutral value for addition is ``0``, but the neutral value for "
"multiplication is ``1``. It's important, therefore, that when we define "
"implementations of ``Monoid`` they extend the correct ``Semigroup`` "
"implementation. We can do this with a ``using`` clause in the implementation"
" as follows:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:721 dd69e50300124dad9dec7903d81f5475
msgid ""
"The ``using PlusNatSemi`` clause indicates that ``PlusNatMonoid`` should "
"extend ``PlusNatSemi`` specifically."
msgstr ""

#: ../../source/tutorial/interfaces.rst:727 186f671c6c5845e7bfe8795d9d22fbc7
msgid "Interface Constructors"
msgstr ""

#: ../../source/tutorial/interfaces.rst:729 f697ec2c2b394fe283c0af8e1eed83e6
msgid ""
"Interfaces, just like records, can be declared with a user-defined "
"constructor."
msgstr ""

#: ../../source/tutorial/interfaces.rst:741 ed15701e4b0d4f018578eaaa02490e76
msgid "Then ``MkB : A t => t -> B t``."
msgstr ""

#: ../../source/tutorial/interfaces.rst:746 7554788d615a40158845f6a04abe1d0b
msgid "Determining Parameters"
msgstr ""

#: ../../source/tutorial/interfaces.rst:748 e2eeeb462ec5474a892fa8d4457065e1
msgid ""
"When an interface has more than one parameter, it can help resolution if the"
" parameters used to find an implementation are restricted. For example:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:757 385da1a30dd44954b326326da76bbe96
msgid ""
"In this interface, only ``m`` needs to be known to find an implementation of"
" this interface, and ``s`` can then be determined from the implementation. "
"This is declared with the ``| m`` after the interface declaration. We call "
"``m`` a *determining parameter* of the ``MonadState`` interface, because it "
"is the parameter used to find an implementation. This is similar to the "
"concept of *functional dependencies* `in Haskell "
"<https://wiki.haskell.org/Functional_dependencies>`_."
msgstr ""

#: ../../source/tutorial/interfaces.rst:764 80536cee5caf4ba492536a5e1c840645
msgid ""
"Conor McBride and Ross Paterson. 2008. Applicative programming with effects."
" J. Funct. Program. 18, 1 (January 2008), 1-13. "
"DOI=10.1017/S0956796807006326 https://dx.doi.org/10.1017/S0956796807006326"
msgstr ""
