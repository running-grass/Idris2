# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 11:10+0800\n"
"PO-Revision-Date: 2022-07-13 15:24+0000\n"
"Language-Team: Chinese Simplified (https://www.transifex.com/idriszhong-wen/teams/140912/zh-Hans/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh-Hans\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../source/reference/strings.rst:2 cb135f891e0544138d79ad4b391ca065
msgid "String literals in Idris"
msgstr ""

#: ../../source/reference/strings.rst:4 64ebd44a25644bcfa9d246380bba1f25
msgid ""
"To facilitate the use of string literals, idris provides three features in "
"addition to plain string literals: multiline strings, raw strings and "
"interpolated strings."
msgstr ""

#: ../../source/reference/strings.rst:9 b4e681ed14314b7386789a8fe678046d
msgid "Plain string literals"
msgstr ""

#: ../../source/reference/strings.rst:11 8212dd1f0ca04fdc993095508dd688e9
msgid ""
"String literals behave the way you expect from other programming language. "
"Use quotation marks ``\"`` around the piece of text that you want to use as "
"a string:"
msgstr ""

#: ../../source/reference/strings.rst:14 48199fbf05a548429492486216bff645
msgid "``\"hello world\"``"
msgstr ""

#: ../../source/reference/strings.rst:16 71a169df17c84f4aa6ead8cb1558e901
msgid ""
"As explained in :doc:`overloadedlit`, string literals can be overloaded to "
"return a type different than string."
msgstr ""

#: ../../source/reference/strings.rst:19 f9489d8477694a61964cd452b0cef1ed
msgid "Multiline string literals"
msgstr ""

#: ../../source/reference/strings.rst:21 1e3d27b9ee91468db39b82ede93d2179
msgid ""
"In some cases you will have to display a large string literal that spans "
"multiple lines. For this you can use *multiline string literals*, they allow"
" you to span a string across multiple vertical lines, preserving the line "
"returns and the indentation. Additionally they allow you to indent your "
"multiline string with the surrounding code, without breaking the intended "
"format of the string."
msgstr ""

#: ../../source/reference/strings.rst:26 577aab4068654671aea3297e8219f00c
msgid ""
"To use multiline strings, start with a triple quote ``\"\"\"`` followed by a"
" line return, then enter your text and close it with another triple quote "
"``\"\"\"`` with whitespace on its left. The indentation of the closing "
"triple quote will determine how much whitespace should be cropped from each "
"line of the text."
msgstr ""

#: ../../source/reference/strings.rst:33 d2bf60deaca0461cb990504b2d0be1d5
msgid ""
"Multiline strings use triple quotes to enable the automatic cropping of "
"leading whitespace when the multiline block is indented."
msgstr ""

#: ../../source/reference/strings.rst:48 fdf8208c3d8244d284885e3ab0c24fbc
msgid "printing the variable `welcome` will result in the following text:"
msgstr ""

#: ../../source/reference/strings.rst:58 c5f442ec12e9431591fbb54d38c50a97
msgid ""
"As you can see, each line has been stripped of its leading 4 space, that is "
"because the closing delimiter was indented with 4 spaces."
msgstr ""

#: ../../source/reference/strings.rst:61 fb639e009f464af6be87e37bfa4cc343
msgid "In order to use multiline string literals, remember the following:"
msgstr ""

#: ../../source/reference/strings.rst:63 342555b408f14417a9721f79c4aa08bd
msgid "The starting delimited must be followed by a line return"
msgstr ""

#: ../../source/reference/strings.rst:64 2a89777ad6204d1c8bd501ee781188a1
msgid ""
"The ending delimiter's intendation level must not exceed the indentation of "
"any line"
msgstr ""

#: ../../source/reference/strings.rst:67 ddb994468c784c029edaf8d9d9cbaa14
msgid "Raw string literals"
msgstr ""

#: ../../source/reference/strings.rst:69 d83780d931f3465abe7210335b4cb319
msgid ""
"It is not uncommon to write string literals that require some amount of "
"escaping. For plain string literals the characters ``\\\\`` and ``\"`` must "
"be escaped, for multiline strings the characters ``\"\"\"`` must be escaped."
" Raw string literals allow you to dynamically change the required escaped "
"sequence in order to avoid having to escape those very common sets of "
"characters. For this, use ``#\"`` as starting delimiter and ``\"#`` as "
"closing delimiter. The number of ``#`` symbols can be increased in order to "
"accomodate for edge cases where ``\"#`` would be a valid symbol. In the "
"following example we are able to match on ``\\{`` by using half as many "
"``\\\\`` characters as if we didn't use raw string literals:"
msgstr ""

#: ../../source/reference/strings.rst:84 8d06195e9c544efeb8d1ee7ae9042b15
msgid ""
"If you need to escape characters you still can by using a ``\\\\`` followed "
"by the same number of ``#`` that you used for your string delimiters. In the"
" following example we are using two ``#`` characters as our escape sequence "
"and want to print a line return:"
msgstr ""

#: ../../source/reference/strings.rst:93 b594ca402fd140d485c76def2bccd4b6
msgid ""
"This last example could be implemented by combining raw string literals with"
" multiline strings:"
msgstr ""

#: ../../source/reference/strings.rst:105 fff97dca20cf42b9ae2d870659bab00e
msgid "Interpolated strings"
msgstr ""

#: ../../source/reference/strings.rst:107 9b87a1a65409481890a06139744fc219
msgid ""
"Concatenating string literals with runtime values happens all the time, but "
"sprinkling our code with lots of ``\"`` and ``++`` symbols sometimes hurts "
"legibility which in turn can introduce bugs that are hard to detect for "
"human eyes. Interpolated strings allow to inline the execution of programs "
"that evaluate to strings with a string literals in order to avoid manually "
"writing out the concatenation of those expressions. To use interpolated "
"strings, use ``\\{`` to start an interpolation slice in which you can write "
"an idris expression. Close it with ``}``"
msgstr ""

#: ../../source/reference/strings.rst:130 418171ea1b9f4f0381311a2ebde933bf
msgid ""
"As you can see in the second line, raw string literals and interpolated "
"strings can be combined. The starting and closing delimiters indicate how "
"many ``#`` must be used as escape sequence in the string, since interpolated"
" strings require the first ``{`` to be escaped, an interpolated slice in a "
"raw string uses ``\\#{`` as starting delimiter."
msgstr ""

#: ../../source/reference/strings.rst:135 617e70c7d20b4ef3a537459b3540c685
msgid ""
"Additionally multiline strings can also be combined with string "
"interpolation in the way you expect, as shown with the ``Decl`` pattern. "
"Finally all three features can be combined together in the last branch of "
"the example, where a multiline string has a custom escape sequence and "
"includes an interpolated slice."
msgstr ""

#: ../../source/reference/strings.rst:141 944ae61d583d4a0db0f5278517410492
msgid "Interpolation Interface"
msgstr ""

#: ../../source/reference/strings.rst:143 e28856cba136430989463f59f59c3001
msgid ""
"The Prelude exposes an ``Interpolation`` interface with one function "
"``interpolate``. This function is used within every interpolation slice to "
"convert an arbitrary expression into a string that can be concatenated with "
"the rest of the interpolated string."
msgstr ""

#: ../../source/reference/strings.rst:147 b8bcc8b24909470e88dabb79826615c6
msgid ""
"To go into more details, when you write ``\"hello \\{username}\"`` the "
"compiler translates the expression into ``concat [interpolate \"hello \", "
"interpolate username]`` so that the concatenation is fast and so that if "
"``username`` implement the ``Interpolation`` interface, you don't have to "
"convert it to a string manually."
msgstr ""

#: ../../source/reference/strings.rst:151 4df8607e83f94a5cae22d3fa9faa1ea0
msgid ""
"Here is an example where we reuse the ``Expr`` type but instead of "
"implementing a ``print`` function we implement ``Interpolation``:"
msgstr ""

#: ../../source/reference/strings.rst:170 ad5b8d0bd9be4592b5ecce3d4c4e948e
msgid ""
"As you can see we avoid repeated calls to ``print`` since the slices are "
"automatically applied to ``interpolate``."
msgstr ""

#: ../../source/reference/strings.rst:173 4199bc9d0d964ef4989a88b5fb894c8d
msgid ""
"We use ``Interpolation`` instead of ``Show`` for interpolation slices "
"because the semantics of ``show`` are not necessarily the same as "
"``interpolate``. Typically the implementation of ``show`` for ``String`` "
"adds double quotes around the text, but for ``interpolate`` what we want is "
"to return the string as is. In the previous example, ``\"hello "
"\\{username}\"``, if we were to use ``show`` we would end up with the string"
" ``\"hello \"Susan`` which displays an extra pair of double quotes. That is "
"why the implementation of ``interpolate`` for ``String`` is the identity "
"function: ``interpolate x = x``. This way the desugared code looks like: "
"``concat [id \"hello \", interpolate username]``."
msgstr ""
