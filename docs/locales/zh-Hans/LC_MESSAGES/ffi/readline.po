# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 11:10+0800\n"
"PO-Revision-Date: 2022-07-13 15:24+0000\n"
"Language-Team: Chinese Simplified (https://www.transifex.com/idriszhong-wen/teams/140912/zh-Hans/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh-Hans\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../source/ffi/readline.rst:5 f524346a286344ecbd290871706453c4
msgid "Example: Minimal Readline Bindings"
msgstr ""

#: ../../source/ffi/readline.rst:7 595a4aef696f45c389befdf60dcccf2e
msgid ""
"In this section, we'll see how to create bindings for a C library (the `GNU "
"Readline <https://tiswww.case.edu/php/chet/readline/rltop.html>`_ library) "
"in Idris, and make them available in a package. We'll only create the most "
"minimal bindings, but nevertheless they demonstrate some of the trickier "
"problems in creating bindings to a C library, in that they need to handle "
"memory allocation of ``String``."
msgstr ""

#: ../../source/ffi/readline.rst:14 293dc248da32440ea52d363a113ae15a
msgid ""
"You can find the example in full in the Idris 2 source repository, in "
"`samples/FFI-readline "
"<https://github.com/edwinb/Idris2/tree/master/samples/FFI-readline>`_. As a "
"minimal example, this can be used as a starting point for other C library "
"bindings."
msgstr ""

#: ../../source/ffi/readline.rst:20 7cf87bdd50e042b58607f84507344cf4
msgid ""
"We are going to provide bindings to the following functions in the Readline "
"API, available via ``#include <readline/readline.h>``:"
msgstr ""

#: ../../source/ffi/readline.rst:28 06d2240e834943dabe4a27d1a850c311
msgid ""
"Additionally, we are going to support tab completion, which in the Readline "
"API is achieved by setting a global variable to a callback function (see "
"Section :ref:`sect-callbacks`) which explains how to handle the completion:"
msgstr ""

#: ../../source/ffi/readline.rst:38 759cedd2a43b4163a27017f59cd1fb04
msgid ""
"A completion function takes a ``String``, which is the text to complete, and"
" an ``Int``, which is the number of times it has asked for a completion so "
"far. In Idris, this could be a function ``complete : String -> Int -> IO "
"String``. So, for example, if the text so far is ``\"id\"``, and the "
"possible completions are ``idiomatic`` and ``idris``, then ``complete \"id\""
" 0`` would produce the string ``\"idiomatic\"`` and ``complete \"id\" 1`` "
"would produce ``\"idris\"``."
msgstr ""

#: ../../source/ffi/readline.rst:45 128f38cb0193484e9b440dc76511ee76
msgid ""
"We will define *glue* functions in a C file ``idris_readline.c``, which "
"compiles to a shared object ``libidrisreadline``, so we write a function for"
" locating the C functions:"
msgstr ""

#: ../../source/ffi/readline.rst:54 f42fdf1d354148c29d1d56129147c33f
msgid ""
"Each of the foreign bindings will have a ``%foreign`` specifier which "
"locates functions via ``rlib``."
msgstr ""

#: ../../source/ffi/readline.rst:58 664ca9444fd74d6db5b3d1798defb33d
msgid "Basic behaviour: Reading input, and history"
msgstr ""

#: ../../source/ffi/readline.rst:60 ce5d7f4324674d978abec9aa3919f7c7
msgid ""
"We can start by writing a binding for ``readline`` directly. It's "
"interactive, so needs to return a ``PrimIO``:"
msgstr ""

#: ../../source/ffi/readline.rst:68 680661abd5f74916872b0ae487020668
msgid "Then, we can write an ``IO`` wrapper:"
msgstr ""

#: ../../source/ffi/readline.rst:75 445b4164fedd4efb898cf64ec21e5224
msgid ""
"Unfortunately, this isn't quite good enough! The C ``readline`` function "
"returns a ``NULL`` string if there is no input due to encountering an end of"
" file. So, we need to handle that - if we don't, we'll get a crash on "
"encountering end of file (remember: it's the Idris programmer's "
"responsibility to give an appropriate type to the C binding!)"
msgstr ""

#: ../../source/ffi/readline.rst:81 76ca58f433284e86bb14f78a0f2a2f28
msgid ""
"Instead, we need to use a ``Ptr`` to say that it might be a ``NULL`` pointer"
" (see Section :ref:`sect-ffi-string`):"
msgstr ""

#: ../../source/ffi/readline.rst:89 307fec4172834ab7b31bbaaf2072983f
msgid ""
"We also need to provide a way to check whether the returned ``Ptr String`` "
"is ``NULL``. To do so, we'll write some glue code to convert back and forth "
"between ``Ptr String`` and ``String``, in a file ``idris_readline.c`` and a "
"corresponding header ``idris_readline.h``. In ``idris_readline.h`` we have:"
msgstr ""

#: ../../source/ffi/readline.rst:101 66f96d417c9a41239fa2e26031ae0a34
msgid "Correspondingly, in ``idris_readline.c``:"
msgstr ""

#: ../../source/ffi/readline.rst:121 b5fa04c65ffe488290a2062ef6ff3f39
msgid ""
"Now, we can use ``prim__readline`` as follows, with a safe API, checking "
"whether the result it returns is ``NULL`` or a concrete ``String``:"
msgstr ""

#: ../../source/ffi/readline.rst:141 bd4f82d0f5c743358470d83d53fc9e32
msgid ""
"We'll need ``nullString`` and ``mkString`` later, for dealing with "
"completions."
msgstr ""

#: ../../source/ffi/readline.rst:143 0c1c7b28cd2f452faffd28c5a1b826c4
msgid ""
"Once we've read a string, we'll want to add it to the input history. We can "
"provide a binding to ``add_history`` as follows:"
msgstr ""

#: ../../source/ffi/readline.rst:155 19898d4f7677413ebabb8428a3d1931b
msgid ""
"In this case, since Idris is in control of the ``String``, we know it's not "
"going to be ``NULL``, so we can add it directly."
msgstr ""

#: ../../source/ffi/readline.rst:158 b21ee2b29f0b4b4ba91f8514b518ed8a
msgid ""
"A small ``readline`` program that reads input, and echoes it, recording "
"input history for non-empty inputs, can be written as follows:"
msgstr ""

#: ../../source/ffi/readline.rst:173 b43e7535676849febc2f6af5f865561b
msgid ""
"This gives us command history, and command line editing, but Readline "
"becomes much more useful when we add tab completion. The default tab "
"completion, which is available even in the small example above, is to tab "
"complete file names in the current working directory. But for any realistic "
"application, we probably want to tab complete other commands, such as "
"function names, references to local data, or anything that is appropriate "
"for the application."
msgstr ""

#: ../../source/ffi/readline.rst:181 263698477e634cff9e24f78309aff796
msgid "Completions"
msgstr ""

#: ../../source/ffi/readline.rst:183 c511c5855b4f4637a367d4f64cd22dc1
msgid ""
"Readline has a large API, with several ways of supporting tab completion, "
"typically involving setting a global variable to an appropriate completion "
"function. We'll use the following:"
msgstr ""

#: ../../source/ffi/readline.rst:192 a8cc3380a70f4350aa59ab1f5640f4d6
msgid ""
"The completion function takes the prefix of the completion, and the number "
"of times it has been called so far on this prefix, and returns the next "
"completion, or ``NULL`` if there are no more completions. An Idris "
"equivalent would therefore have the following type:"
msgstr ""

#: ../../source/ffi/readline.rst:201 3f95b7aba8584940a5b7512074be9798
msgid ""
"The function returns ``Nothing`` if there are no more completions, or ``Just"
" str`` for some ``str`` if there is another one for the current input."
msgstr ""

#: ../../source/ffi/readline.rst:205 16a7c895e3314f2a9a0a94e905256403
msgid ""
"We might hope that it's a matter of defining a function to assign the "
"completion function..."
msgstr ""

#: ../../source/ffi/readline.rst:214 a757d58294b64f16b7d45a96fb492179
msgid ""
"...then defining the Idris binding, which needs to take into account that "
"the Readline library expects ``NULL`` when there are no more completions:"
msgstr ""

#: ../../source/ffi/readline.rst:231 e7cd746d15fd4e6c9cb4fd7e5f4f394c
msgid ""
"So, we turn ``Nothing`` into ``nullString`` and ``Just str`` into ``mkString"
" str``. Unfortunately, this doesn't quite work. To see what goes wrong, "
"let's try it for the most basic completion function that returns one "
"completion no matter what the input:"
msgstr ""

#: ../../source/ffi/readline.rst:242 d846cfe2bceb497da4c6eb27c2d62ba5
msgid ""
"We'll try this in a small modification of ``echoLoop`` above, setting a "
"completion function first:"
msgstr ""

#: ../../source/ffi/readline.rst:251 0dc7f565b24e44cca865b50a7496c78c
msgid ""
"We see that there is a problem when we try running it, and hitting TAB "
"before entering anything:"
msgstr ""

#: ../../source/ffi/readline.rst:259 5640c5f611864aa7a38848082732dd69
msgid ""
"The Idris code which sets up the completion is fine, but there is a problem "
"with the memory allocation in the C glue code."
msgstr ""

#: ../../source/ffi/readline.rst:262 9f5fd9a0493a4ad2839c562c1545afb3
msgid ""
"This problem arises because we haven't thought carefully enough about which "
"parts of our program are responsible for allocating and freeing strings. "
"When Idris calls a foreign function that returns a string, it copies the "
"string to the Idris heap and frees it immediately. But, if the foreign "
"library also frees the string, it ends up being freed twice. This is what's "
"happening here: the callback passed to ``prim__setCompletion`` frees the "
"string and puts it onto the Idris heap, but Readline also frees the string "
"returned by ``prim__setCompletion`` once it has processed it. We can solve "
"this problem by writing a wrapper for the completion function which "
"reallocates the string, and using that in ``idrisrl_setCompletion`` instead."
msgstr ""

#: ../../source/ffi/readline.rst:296 9e22e78093be41a2953a9d522140e530
msgid ""
"So, we define the completion function in C, which calls the Idris completion"
" function then makes sure the string returned by the Idris function is "
"copied to the C heap."
msgstr ""

#: ../../source/ffi/readline.rst:300 d3d3fd277f6742d0976fe4944203f5fe
msgid ""
"We now have a primitive API that covers the most fundamental features of the"
" readline API:"
msgstr ""
