# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 09:08+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/tutorial/conclusions.rst:5
msgid "Further Reading"
msgstr ""

#: ../../source/tutorial/conclusions.rst:7
msgid ""
"Further information about Idris programming, and programming with "
"dependent types in general, can be obtained from various sources:"
msgstr ""

#: ../../source/tutorial/conclusions.rst:10
msgid ""
"`Type-Driven Development with Idris <https://www.manning.com/books/type-"
"driven-development-with-idris>`_ by Edwin Brady, available from `Manning "
"<https://www.manning.com>`_."
msgstr ""

#: ../../source/tutorial/conclusions.rst:13
msgid ""
"The Idris web site (https://www.idris-lang.org/) and by asking questions "
"on the mailing list."
msgstr ""

#: ../../source/tutorial/conclusions.rst:16
msgid ""
"The IRC channel ``#idris``, on `webchat.freenode.net "
"<https://webchat.freenode.net/>`__."
msgstr ""

#: ../../source/tutorial/conclusions.rst:19
msgid ""
"The wiki (https://github.com/idris-lang/Idris-dev/wiki/) has further user"
" provided information, in particular:"
msgstr ""

#: ../../source/tutorial/conclusions.rst:22
msgid "https://github.com/idris-lang/Idris-dev/wiki/Manual"
msgstr ""

#: ../../source/tutorial/conclusions.rst:24
msgid "https://github.com/idris-lang/Idris-dev/wiki/Language-Features"
msgstr ""

#: ../../source/tutorial/conclusions.rst:26
msgid ""
"Examining the prelude and exploring the ``samples`` in the distribution. "
"The Idris 2 source can be found online at:"
msgstr ""

#: ../../source/tutorial/conclusions.rst:29
msgid "https://github.com/edwinb/Idris2."
msgstr ""

#: ../../source/tutorial/conclusions.rst:31
msgid "Existing projects on the ``Idris Hackers`` web space:"
msgstr ""

#: ../../source/tutorial/conclusions.rst:33
msgid "https://idris-hackers.github.io."
msgstr ""

#: ../../source/tutorial/conclusions.rst:35
msgid ""
"Various papers (e.g. [#BradyHammond2012]_, [#Brady]_, and "
"[#BradyHammond2010]_).  Although these mostly describe older versions of "
"Idris."
msgstr ""

#: ../../source/tutorial/conclusions.rst:38
msgid ""
"Edwin Brady and Kevin Hammond. 2012. Resource-Safe systems programming "
"with embedded domain specific languages. In Proceedings of the 14th "
"international conference on Practical Aspects of Declarative Languages "
"(PADL'12), Claudio Russo and Neng-Fa Zhou (Eds.). Springer-Verlag, "
"Berlin, Heidelberg, 242-257. DOI=10.1007/978-3-642-27694-1_18 "
"https://dx.doi.org/10.1007/978-3-642-27694-1_18"
msgstr ""

#: ../../source/tutorial/conclusions.rst:46
msgid ""
"Edwin C. Brady. 2011. IDRIS ---: systems programming meets full dependent"
" types. In Proceedings of the 5th ACM workshop on Programming languages "
"meets program verification (PLPV '11). ACM, New York, NY, USA, 43-54. "
"DOI=10.1145/1929529.1929536 https://doi.acm.org/10.1145/1929529.1929536"
msgstr ""

#: ../../source/tutorial/conclusions.rst:53
msgid ""
"Edwin C. Brady and Kevin Hammond. 2010. Scrapping your inefficient "
"engine: using partial evaluation to improve domain-specific language "
"implementation. In Proceedings of the 15th ACM SIGPLAN international "
"conference on Functional programming (ICFP '10). ACM, New York, NY, USA, "
"297-308. DOI=10.1145/1863543.1863587 "
"https://doi.acm.org/10.1145/1863543.1863587"
msgstr ""

#: ../../source/tutorial/index.rst:5
msgid "A Crash Course in Idris 2"
msgstr ""

#: ../../source/tutorial/index.rst:7
msgid ""
"This is a crash course in Idris 2 (sort of a tutorial, but rather less "
"gentle I'm afraid!). It provides a brief introduction to programming in "
"the Idris Language. It covers the core language features, assuming some "
"experience with an existing functional programming language such as "
"Haskell or OCaml."
msgstr ""

#: ../../source/tutorial/index.rst:13
msgid ""
"This has been revised and updated from the Idris 1 tutorial. For details "
"of changes since Idris 1, see :ref:`updates-index`."
msgstr ""

#: ../../source/tutorial/index.rst:17
msgid ""
"The documentation for Idris has been published under the Creative Commons"
" CC0 License. As such to the extent possible under law, *The Idris "
"Community* has waived all copyright and related or neighboring rights to "
"Documentation for Idris."
msgstr ""

#: ../../source/tutorial/index.rst:22
msgid ""
"More information concerning the CC0 can be found online at: "
"http://creativecommons.org/publicdomain/zero/1.0/"
msgstr ""

#: ../../source/tutorial/interactive.rst:5
msgid "Interactive Editing"
msgstr ""

#: ../../source/tutorial/interactive.rst:7
msgid ""
"By now, we have seen several examples of how Idris’ dependent type system"
" can give extra confidence in a function’s correctness by giving a more "
"precise description of its intended behaviour in its *type*. We have also"
" seen an example of how the type system can help with embedded DSL "
"development by allowing a programmer to describe the type system of an "
"object language. However, precise types give us more than verification of"
" programs — we can also use the type system to help write programs which "
"are *correct by construction*, interactively."
msgstr ""

#: ../../source/tutorial/interactive.rst:16
msgid ""
"The Idris REPL provides several commands for inspecting and modifying "
"parts of programs, based on their types, such as case splitting on a "
"pattern variable, inspecting the type of a hole, and even a basic proof "
"search mechanism. In this section, we explain how these features can be "
"exploited by a text editor, and specifically how to do so in `Vim "
"<https://github.com/edwinb/idris2-vim>`_. An interactive mode for `Emacs "
"<https://github.com/idris-hackers/idris-mode>`_ is also available, "
"updated for Idris 2 compatibility as of 23 February 2021."
msgstr ""

#: ../../source/tutorial/interactive.rst:27
msgid "Editing at the REPL"
msgstr ""

#: ../../source/tutorial/interactive.rst:30
msgid ""
"The Idris2 repl does not support readline in the interest of keeping "
"dependencies minimal. Unfortunately this precludes some niceties such as "
"line editing, persistent history and completion. A useful work around is "
"to install `rlwrap <https://linux.die.net/man/1/rlwrap>`_, this utility "
"provides all the aforementioned features simply by invoking the Idris2 "
"repl as an argument to the utility ``rlwrap idris2``"
msgstr ""

#: ../../source/tutorial/interactive.rst:37
msgid ""
"The REPL provides a number of commands, which we will describe shortly, "
"which generate new program fragments based on the currently loaded "
"module. These take the general form:"
msgstr ""

#: ../../source/tutorial/interactive.rst:45
msgid ""
"That is, each command acts on a specific source line, at a specific name,"
" and outputs a new program fragment. Each command has an alternative "
"form, which *updates* the source file in-place:"
msgstr ""

#: ../../source/tutorial/interactive.rst:53
msgid ""
"It is also possible to invoke Idris in a mode which runs a REPL command, "
"displays the result, then exits, using ``idris2 --client``. For example:"
msgstr ""

#: ../../source/tutorial/interactive.rst:63
msgid ""
"A text editor can take advantage of this, along with the editing "
"commands, in order to provide interactive editing support."
msgstr ""

#: ../../source/tutorial/interactive.rst:67
msgid "Editing Commands"
msgstr ""

#: ../../source/tutorial/interactive.rst:70
msgid ":addclause"
msgstr ""

#: ../../source/tutorial/interactive.rst:72
msgid ""
"The ``:addclause n f`` command, abbreviated ``:ac n f``, creates a "
"template definition for the function named ``f`` declared on line ``n``. "
"For example, if the code beginning on line 94 contains:"
msgstr ""

#: ../../source/tutorial/interactive.rst:81
msgid "then ``:ac 94 vzipWith`` will give:"
msgstr ""

#: ../../source/tutorial/interactive.rst:87
msgid ""
"The names are chosen according to hints which may be given by a "
"programmer, and then made unique by the machine by adding a digit if "
"necessary. Hints can be given as follows:"
msgstr ""

#: ../../source/tutorial/interactive.rst:95
msgid ""
"This declares that any names generated for types in the ``Vect`` family "
"should be chosen in the order ``xs``, ``ys``, ``zs``, ``ws``."
msgstr ""

#: ../../source/tutorial/interactive.rst:99
msgid ":casesplit"
msgstr ""

#: ../../source/tutorial/interactive.rst:101
msgid ""
"The ``:casesplit n x`` command, abbreviated ``:cs n x``, splits the "
"pattern variable ``x`` on line ``n`` into the various pattern forms it "
"may take, removing any cases which are impossible due to unification "
"errors. For example, if the code beginning on line 94 is:"
msgstr ""

#: ../../source/tutorial/interactive.rst:112
msgid "then ``:cs 96 xs`` will give:"
msgstr ""

#: ../../source/tutorial/interactive.rst:119
msgid ""
"That is, the pattern variable ``xs`` has been split into the two possible"
" cases ``[]`` and ``x :: xs``. Again, the names are chosen according to "
"the same heuristic. If we update the file (using ``:cs!``) then case "
"split on ``ys`` on the same line, we get:"
msgstr ""

#: ../../source/tutorial/interactive.rst:128
msgid ""
"That is, the pattern variable ``ys`` has been split into one case ``[]``,"
" Idris having noticed that the other possible case ``y :: ys`` would lead"
" to a unification error."
msgstr ""

#: ../../source/tutorial/interactive.rst:133
msgid ":addmissing"
msgstr ""

#: ../../source/tutorial/interactive.rst:135
msgid ""
"The ``:addmissing n f`` command, abbreviated ``:am n f``, adds the "
"clauses which are required to make the function ``f`` on line ``n`` cover"
" all inputs. For example, if the code beginning on line 94 is:"
msgstr ""

#: ../../source/tutorial/interactive.rst:145
msgid "then ``:am 96 vzipWith`` gives:"
msgstr ""

#: ../../source/tutorial/interactive.rst:151
msgid ""
"That is, it notices that there are no cases for empty vectors, generates "
"the required clauses, and eliminates the clauses which would lead to "
"unification errors."
msgstr ""

#: ../../source/tutorial/interactive.rst:156
msgid ":proofsearch"
msgstr ""

#: ../../source/tutorial/interactive.rst:158
msgid ""
"The ``:proofsearch n f`` command, abbreviated ``:ps n f``, attempts to "
"find a value for the hole ``f`` on line ``n`` by proof search, trying "
"values of local variables, recursive calls and constructors of the "
"required family. Optionally, it can take a list of *hints*, which are "
"functions it can try applying to solve the hole. For example, if the code"
" beginning on line 94 is:"
msgstr ""

#: ../../source/tutorial/interactive.rst:172
msgid "then ``:ps 96 vzipWith_rhs_1`` will give"
msgstr ""

#: ../../source/tutorial/interactive.rst:178
msgid ""
"This works because it is searching for a ``Vect`` of length 0, of which "
"the empty vector is the only possibility. Similarly, and perhaps "
"surprisingly, there is only one possibility if we try to solve ``:ps 97 "
"vzipWith_rhs_2``:"
msgstr ""

#: ../../source/tutorial/interactive.rst:187
msgid ""
"This works because ``vzipWith`` has a precise enough type: The resulting "
"vector has to be non-empty (a ``::``); the first element must have type "
"``c`` and the only way to get this is to apply ``f`` to ``x`` and ``y``; "
"finally, the tail of the vector can only be built recursively."
msgstr ""

#: ../../source/tutorial/interactive.rst:194
msgid ":makewith"
msgstr ""

#: ../../source/tutorial/interactive.rst:196
msgid ""
"The ``:makewith n f`` command, abbreviated ``:mw n f``, adds a ``with`` "
"to a pattern clause. For example, recall ``parity``. If line 10 is:"
msgstr ""

#: ../../source/tutorial/interactive.rst:204
msgid "then ``:mw 10 parity`` will give:"
msgstr ""

#: ../../source/tutorial/interactive.rst:211
msgid ""
"If we then fill in the placeholder ``_`` with ``parity k`` and case split"
" on ``with_pat`` using ``:cs 11 with_pat`` we get the following patterns:"
msgstr ""

#: ../../source/tutorial/interactive.rst:220
msgid ""
"Note that case splitting has normalised the patterns here (giving "
"``plus`` rather than ``+``). In any case, we see that using interactive "
"editing significantly simplifies the implementation of dependent pattern "
"matching by showing a programmer exactly what the valid patterns are."
msgstr ""

#: ../../source/tutorial/interactive.rst:227
msgid "Interactive Editing in Vim"
msgstr ""

#: ../../source/tutorial/interactive.rst:229
msgid ""
"The editor mode for Vim provides syntax highlighting, indentation and "
"interactive editing support using the commands described above. "
"Interactive editing is achieved using the following editor commands, each"
" of which update the buffer directly:"
msgstr ""

#: ../../source/tutorial/interactive.rst:235
msgid "``\\a`` adds a template definition for the name declared on the"
msgstr ""

#: ../../source/tutorial/interactive.rst:235
msgid "current line (using ``:addclause``)."
msgstr ""

#: ../../source/tutorial/interactive.rst:238
msgid "``\\c`` case splits the variable at the cursor (using"
msgstr ""

#: ../../source/tutorial/interactive.rst:238
msgid "``:casesplit``)."
msgstr ""

#: ../../source/tutorial/interactive.rst:241
msgid "``\\m`` adds the missing cases for the name at the cursor (using"
msgstr ""

#: ../../source/tutorial/interactive.rst:241
msgid "``:addmissing``)."
msgstr ""

#: ../../source/tutorial/interactive.rst:243
msgid "``\\w`` adds a ``with`` clause (using ``:makewith``)."
msgstr ""

#: ../../source/tutorial/interactive.rst:246
msgid "``\\s`` invokes a proof search to solve the hole under the"
msgstr ""

#: ../../source/tutorial/interactive.rst:246
msgid "cursor (using ``:proofsearch``)."
msgstr ""

#: ../../source/tutorial/interactive.rst:248
msgid "There are also commands to invoke the type checker and evaluator:"
msgstr ""

#: ../../source/tutorial/interactive.rst:252
msgid "``\\t`` displays the type of the (globally visible) name under the"
msgstr ""

#: ../../source/tutorial/interactive.rst:251
msgid ""
"cursor. In the case of a hole, this displays the context and the expected"
" type."
msgstr ""

#: ../../source/tutorial/interactive.rst:254
msgid "``\\e`` prompts for an expression to evaluate."
msgstr ""

#: ../../source/tutorial/interactive.rst:256
msgid "``\\r`` reloads and type checks the buffer."
msgstr ""

#: ../../source/tutorial/interactive.rst:258
msgid ""
"Corresponding commands are also available in the Emacs mode. Support for "
"other editors can be added in a relatively straightforward manner by "
"using ``idris2 -–client``. More sophisticated support can be added by "
"using the IDE protocol (yet to be documented for Idris 2, but which "
"mostly extends to protocol documented for `Idris 1 <https://docs.idris-"
"lang.org/en/latest/reference/ide-protocol.html>`_."
msgstr ""

#: ../../source/tutorial/interfaces.rst:5
msgid "Interfaces"
msgstr ""

#: ../../source/tutorial/interfaces.rst:7
msgid ""
"We often want to define functions which work across several different "
"data types. For example, we would like arithmetic operators to work on "
"``Int``, ``Integer`` and ``Double`` at the very least. We would like "
"``==`` to work on the majority of data types. We would like to be able to"
" display different types in a uniform way."
msgstr ""

#: ../../source/tutorial/interfaces.rst:13
msgid ""
"To achieve this, we use *interfaces*, which are similar to type classes "
"in Haskell or traits in Rust. To define an interface, we provide a "
"collection of overloadable functions. A simple example is the ``Show`` "
"interface, which is defined in the prelude and provides an interface for "
"converting values to ``String``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:24
msgid ""
"This generates a function of the following type (which we call a *method*"
" of the ``Show`` interface):"
msgstr ""

#: ../../source/tutorial/interfaces.rst:31
msgid ""
"We can read this as: “under the constraint that ``a`` has an "
"implementation of ``Show``, take an input ``a`` and return a ``String``.”"
" An implementation of an interface is defined by giving definitions of "
"the methods of the interface. For example, the ``Show`` implementation "
"for ``Nat`` could be defined as:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:47
msgid ""
"Only one implementation of an interface can be given for a type — "
"implementations may not overlap. Implementation declarations can "
"themselves have constraints. To help with resolution, the arguments of an"
" implementation must be constructors (either data or type constructors) "
"or variables (i.e. you cannot give an implementation for a function). For"
" example, to define a ``Show`` implementation for vectors, we need to "
"know that there is a ``Show`` implementation for the element type, "
"because we are going to use it to convert each element to a ``String``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:65
msgid ""
"Note that we need the explicit ``forall n .`` in the ``show'`` function "
"because otherwise the ``n`` is already in scope, and fixed to the value "
"of the top level ``n``."
msgstr ""

#: ../../source/tutorial/interfaces.rst:70
msgid "Default Definitions"
msgstr ""

#: ../../source/tutorial/interfaces.rst:72
msgid ""
"The Prelude defines an ``Eq`` interface which provides methods for "
"comparing values for equality or inequality, with implementations for all"
" of the built-in types:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:82
msgid ""
"To declare an implementation for a type, we have to give definitions of "
"all of the methods. For example, for an implementation of ``Eq`` for "
"``Nat``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:95
msgid ""
"It is hard to imagine many cases where the ``/=`` method will be anything"
" other than the negation of the result of applying the ``==`` method. It "
"is therefore convenient to give a default definition for each method in "
"the interface declaration, in terms of the other method:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:109
msgid ""
"A minimal complete implementation of ``Eq`` requires either ``==`` or "
"``/=`` to be defined, but does not require both. If a method definition "
"is missing, and there is a default definition for it, then the default is"
" used instead."
msgstr ""

#: ../../source/tutorial/interfaces.rst:115
msgid "Extending Interfaces"
msgstr ""

#: ../../source/tutorial/interfaces.rst:117
msgid ""
"Interfaces can also be extended. A logical next step from an equality "
"relation ``Eq`` is to define an ordering relation ``Ord``. We can define "
"an ``Ord`` interface which inherits methods from ``Eq`` as well as "
"defining some of its own:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:138
msgid ""
"The ``Ord`` interface allows us to compare two values and determine their"
" ordering. Only the ``compare`` method is required; every other method "
"has a default definition. Using this we can write functions such as "
"``sort``, a function which sorts a list into increasing order, provided "
"that the element type of the list is in the ``Ord`` interface. We give "
"the constraints on the type variables left of the fat arrow ``=>``, and "
"the function type to the right of the fat arrow:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:150
msgid ""
"Functions, interfaces and implementations can have multiple constraints. "
"Multiple constraints are written in brackets in a comma separated list, "
"for example:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:159
msgid ""
"Constraints are, like types, first class objects in the language. You can"
" see this at the REPL:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:167
msgid ""
"So, ``(Ord a, Show a)`` is an ordinary pair of ``Types``, with two "
"constraints as the first and second element of the pair."
msgstr ""

#: ../../source/tutorial/interfaces.rst:171
msgid "Note: Interfaces and ``mutual`` blocks"
msgstr ""

#: ../../source/tutorial/interfaces.rst:173
msgid ""
"Idris is strictly \"define before use\", except in ``mutual`` blocks. In "
"a ``mutual`` block, Idris elaborates in two passes: types on the first "
"pass and definitions on the second. When the mutual block contains an "
"interface declaration, it elaborates the interface header but none of the"
" method types on the first pass, and elaborates the method types and any "
"default definitions on the second pass."
msgstr ""

#: ../../source/tutorial/interfaces.rst:181
msgid "Quantities for Parameters"
msgstr ""

#: ../../source/tutorial/interfaces.rst:183
msgid ""
"By default parameters that are not explicitly ascribed a type in an "
"``interface`` declaration are assigned the quantity ``0``. This means "
"that the parameter is not available to use at runtime in the methods' "
"definitions."
msgstr ""

#: ../../source/tutorial/interfaces.rst:187
msgid ""
"For instance, ``Show a`` gives rise to a ``0``-quantified type variable "
"``a`` in the type of the ``show`` method:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:196
msgid ""
"However some use cases require that some of the parameters are available "
"at runtime. We may for instance want to declare an interface for "
"``Storable`` types. The constraint ``Storable a size`` means that we can "
"store values of type ``a`` in a ``Buffer`` in exactly ``size`` bytes."
msgstr ""

#: ../../source/tutorial/interfaces.rst:201
msgid ""
"If the user provides a method to read a value for such a type ``a`` at a "
"given offset, then we can read the ``k`` th element stored in the buffer "
"by computing the appropriate offset from ``k`` and ``size``. This is "
"demonstrated by providing a default implementation for the method "
"``peekElementOff`` implemented in terms of ``peekByteOff`` and the "
"parameter ``size``."
msgstr ""

#: ../../source/tutorial/interfaces.rst:219
msgid ""
"Note that ``a`` is explicitly marked as runtime irrelevant so that it is "
"erased by the compiler. Equivalently we could have written ``interface "
"Storable a (size : Nat)``. The meaning of ``| a`` is explained in "
":ref:`DeterminingParameters`."
msgstr ""

#: ../../source/tutorial/interfaces.rst:225
msgid "Functors and Applicatives"
msgstr ""

#: ../../source/tutorial/interfaces.rst:227
msgid ""
"So far, we have seen single parameter interfaces, where the parameter is "
"of type ``Type``. In general, there can be any number of parameters (even"
" zero), and the parameters can have *any* type. If the type of the "
"parameter is not ``Type``, we need to give an explicit type declaration. "
"For example, the ``Functor`` interface is defined in the prelude:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:240
msgid ""
"A functor allows a function to be applied across a structure, for example"
" to apply a function to every element in a ``List``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:254
msgid ""
"Having defined ``Functor``, we can define ``Applicative`` which abstracts"
" the notion of function application:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:268
msgid "Monads and ``do``-notation"
msgstr ""

#: ../../source/tutorial/interfaces.rst:270
msgid ""
"The ``Monad`` interface allows us to encapsulate binding and computation,"
" and is the basis of ``do``-notation introduced in Section :ref:`sect-"
"do`. It extends ``Applicative`` as defined above, and is defined as "
"follows:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:280
msgid "There is also a non-binding sequencing operator, defined for ``Monad`` as:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:286
msgid ""
"Inside a ``do`` block, the following syntactic transformations are "
"applied:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:289
msgid "``x <- v; e`` becomes ``v >>= (\\x => e)``"
msgstr ""

#: ../../source/tutorial/interfaces.rst:291
msgid "``v; e`` becomes ``v >> e``"
msgstr ""

#: ../../source/tutorial/interfaces.rst:293
msgid "``let x = v; e`` becomes ``let x = v in e``"
msgstr ""

#: ../../source/tutorial/interfaces.rst:295
msgid ""
"``IO`` has an implementation of ``Monad``, defined using primitive "
"functions. We can also define an implementation for ``Maybe``, as "
"follows:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:304
msgid ""
"Using this we can, for example, define a function which adds two ``Maybe "
"Int``, using the monad to encapsulate the error handling:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:314
msgid ""
"This function will extract the values from ``x`` and ``y``, if they are "
"both available, or return ``Nothing`` if one or both are not (\"fail "
"fast\"). Managing the ``Nothing`` cases is achieved by the ``>>=`` "
"operator, hidden by the ``do`` notation."
msgstr ""

#: ../../source/tutorial/interfaces.rst:326
msgid ""
"The translation of ``do`` notation is entirely syntactic, so there is no "
"need for the ``(>>=)`` and ``(>>)`` operators to be the operator defined "
"in the ``Monad`` interface. Idris will, in general, try to disambiguate "
"which operators you mean by type, but you can explicitly choose with "
"qualified do notation, for example:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:340
msgid ""
"The ``Prelude.do`` means that Idris will use the ``(>>=)`` and ``(>>)`` "
"operators defined in the ``Prelude``."
msgstr ""

#: ../../source/tutorial/interfaces.rst:344
msgid "Pattern Matching Bind"
msgstr ""

#: ../../source/tutorial/interfaces.rst:346
msgid ""
"Sometimes we want to pattern match immediately on the result of a "
"function in ``do`` notation. For example, let's say we have a function "
"``readNumber`` which reads a number from the console, returning a value "
"of the form ``Just x`` if the number is valid, or ``Nothing`` otherwise:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:362
msgid ""
"If we then use it to write a function to read two numbers, returning "
"``Nothing`` if neither are valid, then we would like to pattern match on "
"the result of ``readNumber``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:378
msgid ""
"If there's a lot of error handling, this could get deeply nested very "
"quickly! So instead, we can combine the bind and the pattern match in one"
" line. For example, we could try pattern matching on values of the form "
"``Just x_ok``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:390
msgid ""
"There is still a problem, however, because we've now omitted the case for"
" ``Nothing`` so ``readNumbers`` is no longer total! We can add the "
"``Nothing`` case back as follows:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:404
msgid ""
"The effect of this version of ``readNumbers`` is identical to the first "
"(in fact, it is syntactic sugar for it and directly translated back into "
"that form). The first part of each statement (``Just x_ok <-`` and ``Just"
" y_ok <-``) gives the preferred binding - if this matches, execution will"
" continue with the rest of the ``do`` block. The second part gives the "
"alternative bindings, of which there may be more than one."
msgstr ""

#: ../../source/tutorial/interfaces.rst:412
msgid "``!``-notation"
msgstr ""

#: ../../source/tutorial/interfaces.rst:414
msgid ""
"In many cases, using ``do``-notation can make programs unnecessarily "
"verbose, particularly in cases such as ``m_add`` above where the value "
"bound is used once, immediately. In these cases, we can use a shorthand "
"version, as follows:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:424
msgid ""
"The notation ``!expr`` means that the expression ``expr`` should be "
"evaluated and then implicitly bound. Conceptually, we can think of ``!`` "
"as being a prefix function with the following type:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:432
msgid ""
"Note, however, that it is not really a function, merely syntax! In "
"practice, a subexpression ``!expr`` will lift ``expr`` as high as "
"possible within its current scope, bind it to a fresh name ``x``, and "
"replace ``!expr`` with ``x``. Expressions are lifted depth first, left to"
" right. In practice, ``!``-notation allows us to program in a more direct"
" style, while still giving a notational clue as to which expressions are "
"monadic."
msgstr ""

#: ../../source/tutorial/interfaces.rst:440
msgid "For example, the expression:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:446
msgid "is lifted to:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:456
msgid "Monad comprehensions"
msgstr ""

#: ../../source/tutorial/interfaces.rst:458
msgid ""
"The list comprehension notation we saw in Section :ref:`sect-more-expr` "
"is more general, and applies to anything which has an implementation of "
"both ``Monad`` and ``Alternative``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:468
msgid ""
"In general, a comprehension takes the form ``[ exp | qual1, qual2, …, "
"qualn ]`` where ``quali`` can be one of:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:471
msgid "A generator ``x <- e``"
msgstr ""

#: ../../source/tutorial/interfaces.rst:473
msgid "A *guard*, which is an expression of type ``Bool``"
msgstr ""

#: ../../source/tutorial/interfaces.rst:475
msgid "A let binding ``let x = e``"
msgstr ""

#: ../../source/tutorial/interfaces.rst:477
msgid ""
"To translate a comprehension ``[exp | qual1, qual2, …, qualn]``, first "
"any qualifier ``qual`` which is a *guard* is translated to ``guard "
"qual``, using the following function:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:485
msgid "Then the comprehension is converted to ``do`` notation:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:491
msgid ""
"Using monad comprehensions, an alternative definition for ``m_add`` would"
" be:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:500
msgid "Interfaces and IO"
msgstr ""

#: ../../source/tutorial/interfaces.rst:502
msgid ""
"In general, ``IO`` operations in the libraries aren't written using "
"``IO`` directly, but rather via the ``HasIO`` interface:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:510
msgid ""
"``HasIO`` explains, via ``liftIO``, how to convert a primitive ``IO`` "
"operation to an operation in some underlying type, as long as that type "
"has a ``Monad`` implementation.  These interface allows a programmer to "
"define some more expressive notion of interactive program, while still "
"giving direct access to ``IO`` primitives."
msgstr ""

#: ../../source/tutorial/interfaces.rst:517
msgid "Idiom brackets"
msgstr ""

#: ../../source/tutorial/interfaces.rst:519
msgid ""
"While ``do`` notation gives an alternative meaning to sequencing, idioms "
"give an alternative meaning to *application*. The notation and larger "
"example in this section is inspired by Conor McBride and Ross Paterson’s "
"paper “Applicative Programming with Effects” [#ConorRoss]_."
msgstr ""

#: ../../source/tutorial/interfaces.rst:524
msgid ""
"First, let us revisit ``m_add`` above. All it is really doing is applying"
" an operator to two values extracted from ``Maybe Int``. We could "
"abstract out the application:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:534
msgid ""
"Using this, we can write an alternative ``m_add`` which uses this "
"alternative notion of function application, with explicit calls to "
"``m_app``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:543
msgid ""
"Rather than having to insert ``m_app`` everywhere there is an "
"application, we can use idiom brackets to do the job for us. To do this, "
"we can give ``Maybe`` an implementation of ``Applicative`` as follows, "
"where ``<*>`` is defined in the same way as ``m_app`` above (this is "
"defined in the Idris library):"
msgstr ""

#: ../../source/tutorial/interfaces.rst:557
msgid ""
"Using ``<*>`` we can use this implementation as follows, where a function"
" application ``[| f a1 …an |]`` is translated into ``pure f <*> a1 <*> … "
"<*> an``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:567
msgid "An error-handling interpreter"
msgstr ""

#: ../../source/tutorial/interfaces.rst:569
msgid ""
"Idiom notation is commonly useful when defining evaluators. McBride and "
"Paterson describe such an evaluator [#ConorRoss]_, for a language similar"
" to the following:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:579
msgid ""
"Evaluation will take place relative to a context mapping variables "
"(represented as ``String``\\s) to ``Int`` values, and can possibly fail. "
"We define a data type ``Eval`` to wrap an evaluator:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:588
msgid ""
"Wrapping the evaluator in a data type means we will be able to provide "
"implementations of interfaces for it later. We begin by defining a "
"function to retrieve values from the context during evaluation:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:602
msgid ""
"When defining an evaluator for the language, we will be applying "
"functions in the context of an ``Eval``, so it is natural to give "
"``Eval`` an implementation of ``Applicative``. Before ``Eval`` can have "
"an implementation of ``Applicative`` it is necessary for ``Eval`` to have"
" an implementation of ``Functor``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:621
msgid ""
"Evaluating an expression can now make use of the idiomatic application to"
" handle errors:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:635
msgid "For example:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:645
msgid "Named Implementations"
msgstr ""

#: ../../source/tutorial/interfaces.rst:647
msgid ""
"It can be desirable to have multiple implementations of an interface for "
"the same type, for example to provide alternative methods for sorting or "
"printing values. To achieve this, implementations can be *named* as "
"follows:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:659
msgid ""
"This declares an implementation as normal, but with an explicit name, "
"``myord``. The syntax ``compare @{myord}`` gives an explicit "
"implementation to ``compare``, otherwise it would use the default "
"implementation for ``Nat``. We can use this, for example, to sort a list "
"of ``Nat`` in reverse. Given the following list:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:670
msgid ""
"We can sort it using the default ``Ord`` implementation, by using the "
"``sort`` function available with ``import Data.List``, then we can try "
"with the named implementation ``myord`` as follows, at the Idris prompt:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:681
msgid ""
"Sometimes, we also need access to a named parent implementation. For "
"example, the prelude defines the following ``Semigroup`` interface:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:689
msgid ""
"Then it defines ``Monoid``, which extends ``Semigroup`` with a “neutral” "
"value:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:697
msgid ""
"We can define two different implementations of ``Semigroup`` and "
"``Monoid`` for ``Nat``, one based on addition and one on multiplication:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:708
msgid ""
"The neutral value for addition is ``0``, but the neutral value for "
"multiplication is ``1``. It's important, therefore, that when we define "
"implementations of ``Monoid`` they extend the correct ``Semigroup`` "
"implementation. We can do this with a ``using`` clause in the "
"implementation as follows:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:721
msgid ""
"The ``using PlusNatSemi`` clause indicates that ``PlusNatMonoid`` should "
"extend ``PlusNatSemi`` specifically."
msgstr ""

#: ../../source/tutorial/interfaces.rst:727
msgid "Interface Constructors"
msgstr ""

#: ../../source/tutorial/interfaces.rst:729
msgid ""
"Interfaces, just like records, can be declared with a user-defined "
"constructor."
msgstr ""

#: ../../source/tutorial/interfaces.rst:741
msgid "Then ``MkB : A t => t -> B t``."
msgstr ""

#: ../../source/tutorial/interfaces.rst:746
msgid "Determining Parameters"
msgstr ""

#: ../../source/tutorial/interfaces.rst:748
msgid ""
"When an interface has more than one parameter, it can help resolution if "
"the parameters used to find an implementation are restricted. For "
"example:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:757
msgid ""
"In this interface, only ``m`` needs to be known to find an implementation"
" of this interface, and ``s`` can then be determined from the "
"implementation. This is declared with the ``| m`` after the interface "
"declaration. We call ``m`` a *determining parameter* of the "
"``MonadState`` interface, because it is the parameter used to find an "
"implementation. This is similar to the concept of *functional "
"dependencies* `in Haskell "
"<https://wiki.haskell.org/Functional_dependencies>`_."
msgstr ""

#: ../../source/tutorial/interfaces.rst:764
msgid ""
"Conor McBride and Ross Paterson. 2008. Applicative programming with "
"effects. J. Funct. Program. 18, 1 (January 2008), 1-13. "
"DOI=10.1017/S0956796807006326 "
"https://dx.doi.org/10.1017/S0956796807006326"
msgstr ""

#: ../../source/tutorial/interp.rst:5
msgid "Example: The Well-Typed Interpreter"
msgstr ""

#: ../../source/tutorial/interp.rst:7
msgid ""
"In this section, we’ll use the features we’ve seen so far to write a "
"larger example, an interpreter for a simple functional programming "
"language, with variables, function application, binary operators and an "
"``if...then...else`` construct. We will use the dependent type system to "
"ensure that any programs which can be represented are well-typed."
msgstr ""

#: ../../source/tutorial/interp.rst:15
msgid "Representing Languages"
msgstr ""

#: ../../source/tutorial/interp.rst:17
msgid ""
"First, let us define the types in the language. We have integers, "
"booleans, and functions, represented by ``Ty``:"
msgstr ""

#: ../../source/tutorial/interp.rst:24
msgid ""
"We can write a function to translate these representations to a concrete "
"Idris type — remember that types are first class, so can be calculated "
"just like any other value:"
msgstr ""

#: ../../source/tutorial/interp.rst:35
msgid ""
"We're going to define a representation of our language in such a way that"
" only well-typed programs can be represented. We'll index the "
"representations of expressions by their type, **and** the types of local "
"variables (the context). The context can be represented using the "
"``Vect`` data type, so we'll need to import ``Data.Vect`` at the top of "
"our source file:"
msgstr ""

#: ../../source/tutorial/interp.rst:46
msgid ""
"Expressions are indexed by the types of the local variables, and the type"
" of the expression itself:"
msgstr ""

#: ../../source/tutorial/interp.rst:53
msgid "The full representation of expressions is:"
msgstr ""

#: ../../source/tutorial/interp.rst:72
msgid ""
"The code above makes use of the ``Vect`` and ``Fin`` types from the base "
"libraries. ``Fin`` is available as part of ``Data.Vect``. Throughout, "
"``ctxt`` refers to the local variable context."
msgstr ""

#: ../../source/tutorial/interp.rst:76
msgid ""
"Since expressions are indexed by their type, we can read the typing rules"
" of the language from the definitions of the constructors. Let us look at"
" each constructor in turn."
msgstr ""

#: ../../source/tutorial/interp.rst:80
msgid ""
"We use a nameless representation for variables — they are *de Bruijn "
"indexed*. Variables are represented by a proof of their membership in the"
" context, ``HasType i ctxt T``, which is a proof that variable ``i`` in "
"context ``ctxt`` has type ``T``. This is defined as follows:"
msgstr ""

#: ../../source/tutorial/interp.rst:91
msgid ""
"We can treat *Stop* as a proof that the most recently defined variable is"
" well-typed, and *Pop n* as a proof that, if the ``n``\\ th most recently"
" defined variable is well-typed, so is the ``n+1``\\ th. In practice, "
"this means we use ``Stop`` to refer to the most recently defined "
"variable, ``Pop Stop`` to refer to the next, and so on, via the ``Var`` "
"constructor:"
msgstr ""

#: ../../source/tutorial/interp.rst:102
msgid ""
"So, in an expression ``\\x. \\y. x y``, the variable ``x`` would have a "
"de Bruijn index of 1, represented as ``Pop Stop``, and ``y 0``, "
"represented as ``Stop``. We find these by counting the number of lambdas "
"between the definition and the use."
msgstr ""

#: ../../source/tutorial/interp.rst:107
msgid "A value carries a concrete representation of an integer:"
msgstr ""

#: ../../source/tutorial/interp.rst:113
msgid ""
"A lambda creates a function. In the scope of a function of type ``a -> "
"t``, there is a new local variable of type ``a``, which is expressed by "
"the context index:"
msgstr ""

#: ../../source/tutorial/interp.rst:121
msgid ""
"Function application produces a value of type ``t`` given a function from"
" ``a`` to ``t`` and a value of type ``a``:"
msgstr ""

#: ../../source/tutorial/interp.rst:128
msgid ""
"We allow arbitrary binary operators, where the type of the operator "
"informs what the types of the arguments must be:"
msgstr ""

#: ../../source/tutorial/interp.rst:136
msgid ""
"Finally, ``If`` expressions make a choice given a boolean. Each branch "
"must have the same type, and we will evaluate the branches lazily so that"
" only the branch which is taken need be evaluated:"
msgstr ""

#: ../../source/tutorial/interp.rst:148
msgid "Writing the Interpreter"
msgstr ""

#: ../../source/tutorial/interp.rst:150
msgid ""
"When we evaluate an ``Expr``, we'll need to know the values in scope, as "
"well as their types. ``Env`` is an environment, indexed over the types in"
" scope. Since an environment is just another form of list, albeit with a "
"strongly specified connection to the vector of local variable types, we "
"use the usual ``::`` and ``Nil`` constructors so that we can use the "
"usual list syntax. Given a proof that a variable is defined in the "
"context, we can then produce a value from the environment:"
msgstr ""

#: ../../source/tutorial/interp.rst:169
msgid ""
"Given this, an interpreter is a function which translates an ``Expr`` "
"into a concrete Idris value with respect to a specific environment:"
msgstr ""

#: ../../source/tutorial/interp.rst:177
msgid ""
"The complete interpreter is defined as follows, for reference. For each "
"constructor, we translate it into the corresponding Idris value:"
msgstr ""

#: ../../source/tutorial/interp.rst:190
msgid ""
"Let us look at each case in turn. To translate a variable, we simply look"
" it up in the environment:"
msgstr ""

#: ../../source/tutorial/interp.rst:197
msgid ""
"To translate a value, we just return the concrete representation of the "
"value:"
msgstr ""

#: ../../source/tutorial/interp.rst:204
msgid ""
"Lambdas are more interesting. In this case, we construct a function which"
" interprets the scope of the lambda with a new value in the environment. "
"So, a function in the object language is translated to an Idris function:"
msgstr ""

#: ../../source/tutorial/interp.rst:213
msgid ""
"For an application, we interpret the function and its argument and apply "
"it directly. We know that interpreting ``f`` must produce a function, "
"because of its type:"
msgstr ""

#: ../../source/tutorial/interp.rst:221
msgid ""
"Operators and conditionals are, again, direct translations into the "
"equivalent Idris constructs. For operators, we apply the function to its "
"operands directly, and for ``If``, we apply the Idris "
"``if...then...else`` construct directly."
msgstr ""

#: ../../source/tutorial/interp.rst:233
msgid "Testing"
msgstr ""

#: ../../source/tutorial/interp.rst:235
msgid ""
"We can make some simple test functions. Firstly, adding two inputs ``\\x."
" \\y. y + x`` is written as follows:"
msgstr ""

#: ../../source/tutorial/interp.rst:243
msgid ""
"More interestingly, a factorial function ``fact`` (e.g. ``\\x. if (x == "
"0) then 1 else (fact (x-1) * x)``), can be written as:"
msgstr ""

#: ../../source/tutorial/interp.rst:256
msgid "Running"
msgstr ""

#: ../../source/tutorial/interp.rst:258
msgid ""
"To finish, we write a ``main`` program which interprets the factorial "
"function on user input:"
msgstr ""

#: ../../source/tutorial/interp.rst:268
msgid ""
"Here, ``cast`` is an overloaded function which converts a value from one "
"type to another if possible. Here, it converts a string to an integer, "
"giving 0 if the input is invalid. An example run of this program at the "
"Idris interactive environment is:"
msgstr ""

#: ../../source/tutorial/interp.rst:278
msgid "Aside: ``cast``"
msgstr ""

#: ../../source/tutorial/interp.rst:280
msgid ""
"The prelude defines an interface ``Cast`` which allows conversion between"
" types:"
msgstr ""

#: ../../source/tutorial/interp.rst:288
msgid ""
"It is a *multi-parameter* interface, defining the source type and object "
"type of the cast. It must be possible for the type checker to infer "
"*both* parameters at the point where the cast is applied. There are casts"
" defined between all of the primitive types, as far as they make sense."
msgstr ""

#: ../../source/tutorial/introduction.rst:5
msgid "Introduction"
msgstr ""

#: ../../source/tutorial/introduction.rst:7
msgid ""
"In conventional programming languages, there is a clear distinction "
"between *types* and *values*. For example, in `Haskell "
"<https://www.haskell.org>`_, the following are types, representing "
"integers, characters, lists of characters, and lists of any value "
"respectively:"
msgstr ""

#: ../../source/tutorial/introduction.rst:13
msgid "``Int``, ``Char``, ``[Char]``, ``[a]``"
msgstr ""

#: ../../source/tutorial/introduction.rst:15
msgid ""
"Correspondingly, the following values are examples of inhabitants of "
"those types:"
msgstr ""

#: ../../source/tutorial/introduction.rst:18
msgid "``42``, ``’a’``, ``\"Hello world!\"``, ``[2,3,4,5,6]``"
msgstr ""

#: ../../source/tutorial/introduction.rst:20
msgid ""
"In a language with *dependent types*, however, the distinction is less "
"clear. Dependent types allow types to “depend” on values — in other "
"words, types are a *first class* language construct and can be "
"manipulated like any other value. The standard example is the type of "
"lists of a given length [#fn1]_, ``Vect n a``, where ``a`` is the element"
" type and ``n`` is the length of the list and can be an arbitrary term."
msgstr ""

#: ../../source/tutorial/introduction.rst:27
msgid ""
"When types can contain values, and where those values describe "
"properties, for example the length of a list, the type of a function can "
"begin to describe its own properties. Take for example the concatenation "
"of two lists. This operation has the property that the resulting list's "
"length is the sum of the lengths of the two input lists. We can therefore"
" give the following type to the ``app`` function, which concatenates "
"vectors:"
msgstr ""

#: ../../source/tutorial/introduction.rst:39
msgid ""
"This tutorial introduces Idris, a general purpose functional programming "
"language with dependent types. The goal of the Idris project is to build "
"a dependently typed language suitable for verifiable general purpose "
"programming. To this end, Idris is a compiled language which aims to "
"generate efficient executable code. It also has a lightweight foreign "
"function interface which allows easy interaction with external libraries."
msgstr ""

#: ../../source/tutorial/introduction.rst:48
msgid "Intended Audience"
msgstr ""

#: ../../source/tutorial/introduction.rst:50
msgid ""
"This tutorial is intended as a brief introduction to the language, and is"
" aimed at readers already familiar with a functional language such as "
"`Haskell <https://www.haskell.org>`_ or `OCaml <https://ocaml.org>`_. In "
"particular, a certain amount of familiarity with Haskell syntax is "
"assumed, although most concepts will at least be explained briefly. The "
"reader is also assumed to have some interest in using dependent types for"
" writing and verifying software."
msgstr ""

#: ../../source/tutorial/introduction.rst:58
msgid ""
"For a more in-depth introduction to Idris, which proceeds at a much "
"slower pace, covering interactive program development, with many more "
"examples, see `Type-Driven Development with Idris "
"<https://www.manning.com/books/type-driven-development-with-idris>`_ by "
"Edwin Brady, available from `Manning <https://www.manning.com>`_."
msgstr ""

#: ../../source/tutorial/introduction.rst:64
msgid "Example Code"
msgstr ""

#: ../../source/tutorial/introduction.rst:66
msgid ""
"This tutorial includes some example code, which has been tested against "
"Idris 2. These files are available with the Idris 2 distribution, so that"
" you can try them out easily. They can be found under ``samples``. It is,"
" however, strongly recommended that you type them in yourself, rather "
"than simply loading and reading them."
msgstr ""

#: ../../source/tutorial/introduction.rst:73
msgid "Footnotes"
msgstr ""

#: ../../source/tutorial/introduction.rst:74
msgid ""
"Typically, and perhaps confusingly, referred to in the dependently typed "
"programming literature as \"vectors\"."
msgstr ""

#: ../../source/tutorial/miscellany.rst:5
msgid "Miscellany"
msgstr ""

#: ../../source/tutorial/miscellany.rst:7
msgid "In this section we discuss a variety of additional features:"
msgstr ""

#: ../../source/tutorial/miscellany.rst:9
msgid "auto, implicit, and default arguments;"
msgstr ""

#: ../../source/tutorial/miscellany.rst:10
msgid "literate programming; and"
msgstr ""

#: ../../source/tutorial/miscellany.rst:11
msgid "the universe hierarchy."
msgstr ""

#: ../../source/tutorial/miscellany.rst:14
msgid "Implicit arguments"
msgstr ""

#: ../../source/tutorial/miscellany.rst:16
msgid ""
"We have already seen implicit arguments, which allows arguments to be "
"omitted when they can be inferred by the type checker [#IdrisType]_, e.g."
msgstr ""

#: ../../source/tutorial/miscellany.rst:24
msgid "Auto implicit arguments"
msgstr ""

#: ../../source/tutorial/miscellany.rst:26
msgid ""
"In other situations, it may be possible to infer arguments not by type "
"checking but by searching the context for an appropriate value, or "
"constructing a proof. For example, the following definition of ``head`` "
"which requires a proof that the list is non-empty:"
msgstr ""

#: ../../source/tutorial/miscellany.rst:40
msgid ""
"If the list is statically known to be non-empty, either because its value"
" is known or because a proof already exists in the context, the proof can"
" be constructed automatically. Auto implicit arguments allow this to "
"happen silently. We define ``head`` as follows:"
msgstr ""

#: ../../source/tutorial/miscellany.rst:50
msgid ""
"The ``auto`` annotation on the implicit argument means that Idris will "
"attempt to fill in the implicit argument by searching for a value of the "
"appropriate type. In fact, internally, this is exactly how interface "
"resolution works. It will try the following, in order:"
msgstr ""

#: ../../source/tutorial/miscellany.rst:55
msgid ""
"Local variables, i.e. names bound in pattern matches or ``let`` bindings,"
" with exactly the right type."
msgstr ""

#: ../../source/tutorial/miscellany.rst:57
msgid ""
"The constructors of the required type. If they have arguments, it will "
"search recursively up to a maximum depth of 100."
msgstr ""

#: ../../source/tutorial/miscellany.rst:59
msgid ""
"Local variables with function types, searching recursively for the "
"arguments."
msgstr ""

#: ../../source/tutorial/miscellany.rst:61
#, python-format
msgid ""
"Any function with the appropriate return type which is marked with the "
"``%hint`` annotation."
msgstr ""

#: ../../source/tutorial/miscellany.rst:64
msgid ""
"In the case that a proof is not found, it can be provided explicitly as "
"normal:"
msgstr ""

#: ../../source/tutorial/miscellany.rst:71
msgid "Default implicit arguments"
msgstr ""

#: ../../source/tutorial/miscellany.rst:73
msgid ""
"Besides having Idris automatically find a value of a given type, "
"sometimes we want to have an implicit argument with a specific default "
"value. In Idris, we can do this using the ``default`` annotation. While "
"this is primarily intended to assist in automatically constructing a "
"proof where auto fails, or finds an unhelpful value, it might be easier "
"to first consider a simpler case, not involving proofs."
msgstr ""

#: ../../source/tutorial/miscellany.rst:79
msgid ""
"If we want to compute the n'th fibonacci number (and defining the 0th "
"fibonacci number as 0), we could write:"
msgstr ""

#: ../../source/tutorial/miscellany.rst:88
msgid ""
"After this definition, ``fibonacci 5`` is equivalent to ``fibonacci "
"{lag=0} {lead=1} 5``, and will return the 5th fibonacci number. Note that"
" while this works, this is not the intended use of the ``default`` "
"annotation. It is included here for illustrative purposes only. Usually, "
"``default`` is used to provide things like a custom proof search script."
msgstr ""

#: ../../source/tutorial/miscellany.rst:94
msgid "Literate programming"
msgstr ""

#: ../../source/tutorial/miscellany.rst:96
msgid ""
"Like Haskell, Idris supports *literate* programming. If a file has an "
"extension of ``.lidr`` then it is assumed to be a literate file. In "
"literate programs, everything is assumed to be a comment unless the line "
"begins with a greater than sign ``>``, for example:"
msgstr ""

#: ../../source/tutorial/miscellany.rst:110
msgid ""
"An additional restriction is that there must be a blank line between a "
"program line (beginning with ``>``) and a comment line (beginning with "
"any other character)."
msgstr ""

#: ../../source/tutorial/miscellany.rst:115
msgid "Cumulativity"
msgstr ""

#: ../../source/tutorial/miscellany.rst:119
msgid "NOT YET IN IDRIS 2"
msgstr ""

#: ../../source/tutorial/miscellany.rst:121
msgid ""
"Since values can appear in types and *vice versa*, it is natural that "
"types themselves have types. For example:"
msgstr ""

#: ../../source/tutorial/miscellany.rst:131
msgid "But what about the type of ``Type``? If we ask Idris it reports:"
msgstr ""

#: ../../source/tutorial/miscellany.rst:138
msgid ""
"If ``Type`` were its own type, it would lead to an inconsistency due to "
"`Girard’s paradox "
"<https://www.cs.cmu.edu/afs/cs.cmu.edu/user/kw/www/scans/girard72thesis.pdf>`_,"
" so internally there is a *hierarchy* of types (or *universes*):"
msgstr ""

#: ../../source/tutorial/miscellany.rst:146
msgid ""
"Universes are *cumulative*, that is, if ``x : Type n`` we can also have "
"that ``x : Type m``, as long as ``n < m``. The typechecker generates such"
" universe constraints and reports an error if any inconsistencies are "
"found. Ordinarily, a programmer does not need to worry about this, but it"
" does prevent (contrived) programs such as the following:"
msgstr ""

#: ../../source/tutorial/miscellany.rst:160
msgid ""
"The application of ``myid`` to itself leads to a cycle in the universe "
"hierarchy — ``myid``\\ ’s first argument is a ``Type``, which cannot be "
"at a lower level than required if it is applied to itself."
msgstr ""

#: ../../source/tutorial/miscellany.rst:164
msgid "https://github.com/david-christiansen/idris-type-providers"
msgstr ""

#: ../../source/tutorial/modules.rst:5
msgid "Modules and Namespaces"
msgstr ""

#: ../../source/tutorial/modules.rst:7
msgid ""
"An Idris program consists of a collection of modules. Each module "
"includes an optional ``module`` declaration giving the name of the "
"module, a list of ``import`` statements giving the other modules which "
"are to be imported, and a collection of declarations and definitions of "
"types, interfaces and functions. For example, the listing below gives a "
"module which defines a binary tree type ``BTree`` (in a file "
"``BTree.idr``):"
msgstr ""

#: ../../source/tutorial/modules.rst:39
msgid ""
"The modifiers ``export`` and ``public export`` say which names are "
"visible from other namespaces. These are explained further below."
msgstr ""

#: ../../source/tutorial/modules.rst:42
msgid ""
"Then, this gives a main program (in a file ``bmain.idr``) which uses the "
"``BTree`` module to sort a list:"
msgstr ""

#: ../../source/tutorial/modules.rst:55
msgid ""
"The same names can be defined in multiple modules: names are *qualified* "
"with the name of the module. The names defined in the ``BTree`` module "
"are, in full:"
msgstr ""

#: ../../source/tutorial/modules.rst:58
msgid "``BTree.BTree``"
msgstr ""

#: ../../source/tutorial/modules.rst:59
msgid "``BTree.Leaf``"
msgstr ""

#: ../../source/tutorial/modules.rst:60
msgid "``BTree.Node``"
msgstr ""

#: ../../source/tutorial/modules.rst:61
msgid "``BTree.insert``"
msgstr ""

#: ../../source/tutorial/modules.rst:62
msgid "``BTree.toList``"
msgstr ""

#: ../../source/tutorial/modules.rst:63
msgid "``BTree.toTree``"
msgstr ""

#: ../../source/tutorial/modules.rst:65
msgid ""
"If names are otherwise unambiguous, there is no need to give the fully "
"qualified name. Names can be disambiguated either by giving an explicit "
"qualification, using the ``with`` keyword, or according to their type."
msgstr ""

#: ../../source/tutorial/modules.rst:69
msgid "The ``with`` keyword in expressions comes in two variants:"
msgstr ""

#: ../../source/tutorial/modules.rst:71
msgid "``with BTree.insert (insert x empty)`` for one name"
msgstr ""

#: ../../source/tutorial/modules.rst:72
msgid "``with [BTree.insert, BTree.empty] (insert x empty)`` for multiple names"
msgstr ""

#: ../../source/tutorial/modules.rst:74
msgid ""
"This is particularly useful with ``do`` notation, where it can often "
"improve error messages: ``with MyModule.(>>=) do ...``"
msgstr ""

#: ../../source/tutorial/modules.rst:77
msgid ""
"There is no formal link between the module name and its filename, "
"although it is generally advisable to use the same name for each. An "
"``import`` statement refers to a filename, using dots to separate "
"directories. For example, ``import foo.bar`` would import the file "
"``foo/bar.idr``, which would conventionally have the module declaration "
"``module foo.bar``. The only requirement for module names is that the "
"main module, with the ``main`` function, must be called ``Main`` — "
"although its filename need not be ``Main.idr``."
msgstr ""

#: ../../source/tutorial/modules.rst:87
msgid "Export Modifiers"
msgstr ""

#: ../../source/tutorial/modules.rst:89
msgid ""
"Idris allows for fine-grained control over the visibility of a "
"namespace's contents. By default, all names defined in a namespace are "
"kept private.  This aids in specification of a minimal interface and for "
"internal details to be left hidden. Idris allows for functions, types, "
"and interfaces to be marked as: ``private``, ``export``, or ``public "
"export``. Their general meaning is as follows:"
msgstr ""

#: ../../source/tutorial/modules.rst:96
msgid "``private`` meaning that it is not exported at all. This is the default."
msgstr ""

#: ../../source/tutorial/modules.rst:98
msgid "``export`` meaning that its top level type is exported."
msgstr ""

#: ../../source/tutorial/modules.rst:100
msgid "``public export`` meaning that the entire definition is exported."
msgstr ""

#: ../../source/tutorial/modules.rst:102
msgid ""
"A further restriction in modifying the visibility is that definitions "
"must not refer to anything within a lower level of visibility. For "
"example, ``public export`` definitions cannot use ``private`` or "
"``export`` names, and ``export`` types cannot use ``private`` names. This"
" is to prevent private names leaking into a module's interface."
msgstr ""

#: ../../source/tutorial/modules.rst:109
msgid "Meaning for Functions"
msgstr ""

#: ../../source/tutorial/modules.rst:111
msgid "``export`` the type is exported"
msgstr ""

#: ../../source/tutorial/modules.rst:113
msgid ""
"``public export`` the type and definition are exported, and the "
"definition can be used after it is imported. In other words, the "
"definition itself is considered part of the module's interface. The long "
"name ``public export`` is intended to make you think twice about doing "
"this."
msgstr ""

#: ../../source/tutorial/modules.rst:121
msgid ""
"Type synonyms in Idris are created by writing a function. When setting "
"the visibility for a module, it is usually a good idea to ``public "
"export`` all type synonyms if they are to be used outside the module. "
"Otherwise, Idris won't know what the synonym is a synonym for."
msgstr ""

#: ../../source/tutorial/modules.rst:127
msgid ""
"Since ``public export`` means that a function's definition is exported, "
"this effectively makes the function definition part of the module's API. "
"Therefore, it's generally a good idea to avoid using ``public export`` "
"for functions unless you really mean to export the full definition."
msgstr ""

#: ../../source/tutorial/modules.rst:133
msgid ""
"*For beginners*: If the function needs to be accessed only at runtime, "
"use ``export``. However, if it's also meant to be used at *compile* time "
"(e.g. to prove a theorem), use ``public export``. For example, consider "
"the function ``plus : Nat -> Nat -> Nat`` discussed previously, and the "
"following theorem: ``thm : plus Z m = m``. In order to prove it, the type"
" checker needs to reduce ``plus Z m`` to ``m`` (and hence obtain ``thm : "
"m = m``). To achieve this, it will need access to the *definition* of "
"``plus``, which includes the equation ``plus Z m = m``. Therefore, in "
"this case, ``plus`` has to be marked as ``public export``."
msgstr ""

#: ../../source/tutorial/modules.rst:146
msgid "Meaning for Data Types"
msgstr ""

#: ../../source/tutorial/modules.rst:148
msgid "For data types, the meanings are:"
msgstr ""

#: ../../source/tutorial/modules.rst:150
msgid "``export`` the type constructor is exported"
msgstr ""

#: ../../source/tutorial/modules.rst:152
msgid "``public export`` the type constructor and data constructors are exported"
msgstr ""

#: ../../source/tutorial/modules.rst:156
msgid "Meaning for Interfaces"
msgstr ""

#: ../../source/tutorial/modules.rst:158
msgid "For interfaces, the meanings are:"
msgstr ""

#: ../../source/tutorial/modules.rst:160
msgid "``export`` the interface name is exported"
msgstr ""

#: ../../source/tutorial/modules.rst:162
msgid ""
"``public export`` the interface name, method names and default "
"definitions are exported"
msgstr ""

#: ../../source/tutorial/modules.rst:166
msgid "Propagating Inner Module API's"
msgstr ""

#: ../../source/tutorial/modules.rst:168
msgid ""
"Additionally, a module can re-export a module it has imported, by using "
"the ``public`` modifier on an ``import``. For example:"
msgstr ""

#: ../../source/tutorial/modules.rst:178
msgid ""
"The module ``A`` will export the name ``a``, as well as any public or "
"abstract names in module ``C``, but will not re-export anything from "
"module ``B``."
msgstr ""

#: ../../source/tutorial/modules.rst:183
msgid "Renaming imports"
msgstr ""

#: ../../source/tutorial/modules.rst:185
msgid ""
"Sometimes it is convenient to be able to access the names in another "
"module via a different namespace (typically, a shorter one). For this, "
"you can use `import...as`. For example:"
msgstr ""

#: ../../source/tutorial/modules.rst:195
msgid ""
"This module ``A`` has access to the exported names from module "
"``Data.List``, but can also explicitly access them via the module name "
"``L``. ``import...as`` can also be combined with ``import public`` to "
"create a module which exports a larger API from other sub-modules:"
msgstr ""

#: ../../source/tutorial/modules.rst:207
msgid ""
"Here, any module which imports ``Books`` will have access to the exported"
" interfaces of ``Books.Hardback`` and ``Books.Comic`` both under the "
"namespace ``Books``."
msgstr ""

#: ../../source/tutorial/modules.rst:212
msgid "Explicit Namespaces"
msgstr ""

#: ../../source/tutorial/modules.rst:214
msgid ""
"Defining a module also defines a namespace implicitly. However, "
"namespaces can also be given *explicitly*. This is most useful if you "
"wish to overload names within the same module:"
msgstr ""

#: ../../source/tutorial/modules.rst:232
msgid ""
"This (admittedly contrived) module defines two functions with fully "
"qualified names ``Foo.X.test`` and ``Foo.Y.test``, which can be "
"disambiguated by their types:"
msgstr ""

#: ../../source/tutorial/modules.rst:243
msgid ""
"The export rules, ``public export`` and ``export``, are *per namespace*, "
"not *per file*, so the two ``test`` definitions above need the ``export``"
" flag to be visible outside their own namespaces."
msgstr ""

#: ../../source/tutorial/modules.rst:248
msgid "Parameterised blocks"
msgstr ""

#: ../../source/tutorial/modules.rst:250
msgid ""
"Groups of functions can be parameterised over a number of arguments using"
" a ``parameters`` declaration, for example:"
msgstr ""

#: ../../source/tutorial/modules.rst:259
msgid ""
"The effect of a ``parameters`` block is to add the declared parameters to"
" every function, type and data constructor within the block. "
"Specifically, adding the parameters to the front of the argument list. "
"Outside the block, the parameters must be given explicitly. The "
"``addAll`` function, when called from the REPL, will thus have the "
"following type signature."
msgstr ""

#: ../../source/tutorial/modules.rst:271
msgid "and the following definition."
msgstr ""

#: ../../source/tutorial/modules.rst:278
msgid ""
"Parameters blocks can be nested, and can also include data declarations, "
"in which case the parameters are added explicitly to all type and data "
"constructors. They may also be dependent types with implicit arguments:"
msgstr ""

#: ../../source/tutorial/modules.rst:291
msgid ""
"To use ``Vects`` or ``append`` outside the block, we must also give the "
"``xs`` and ``y`` arguments. Here, we can use placeholders for the values "
"which can be inferred by the type checker:"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:5
msgid "Multiplicities"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:7
msgid ""
"Idris 2 is based on `Quantitative Type Theory (QTT) <https://bentnib.org"
"/quantitative-type-theory.html>`_, a core language developed by Bob Atkey"
" and Conor McBride. In practice, this means that every variable in Idris "
"2 has a *quantity* associated with it. A quantity is one of:"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:13
msgid "``0``, meaning that the variable is *erased* at run time"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:14
msgid "``1``, meaning that the variable is used *exactly once* at run time"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:15
msgid "*Unrestricted*, which is the same behaviour as Idris 1"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:17
msgid ""
"We can see the multiplicities of variables by inspecting holes. For "
"example, if we have the following skeleton definition of ``append`` on "
"vectors..."
msgstr ""

#: ../../source/tutorial/multiplicities.rst:25
msgid "...we can look at the hole ``append_rhs``:"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:38
msgid ""
"The ``0`` next to ``m``, ``a`` and ``n`` mean that they are in scope, but"
" there will be ``0`` occurrences at run-time. That is, it is "
"**guaranteed** that they will be erased at run-time."
msgstr ""

#: ../../source/tutorial/multiplicities.rst:42
msgid "Multiplicities can be explicitly written in function types as follows:"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:44
msgid ""
"``ignoreN : (0 n : Nat) -> Vect n a -> Nat`` - this function cannot look "
"at ``n`` at run time"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:46
msgid ""
"``duplicate : (1 x : a) -> (a, a)`` - this function must use ``x`` "
"exactly once (so good luck implementing it, by the way. There is no "
"implementation because it would need to use ``x`` twice!)"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:50
msgid ""
"If there is no multiplicity annotation, the argument is unrestricted. If,"
" on the other hand, a name is implicitly bound (like ``a`` in both "
"examples above) the argument is erased. So, the above types could also be"
" written as:"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:54
msgid "``ignoreN : {0 a : _} -> (0 n : Nat) -> Vect n a -> Nat``"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:55
msgid "``duplicate : {0 a : _} -> (1 x : a) -> (a, a)``"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:57
msgid ""
"This section describes what this means for your Idris 2 programs in "
"practice, with several examples. In particular, it describes:"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:60
msgid ""
":ref:`sect-erasure` - how to know what is relevant at run time and what "
"is erased"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:61
msgid ""
":ref:`sect-linearity` - using the type system to encode *resource usage "
"protocols*"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:62
msgid ":ref:`sect-pmtypes` - truly first class types"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:64
msgid ""
"The most important of these for most programs, and the thing you'll need "
"to know about if converting Idris 1 programs to work with Idris 2, is "
"erasure_. The most interesting, however, and the thing which gives Idris "
"2 much more expressivity, is linearity_, so we'll start there."
msgstr ""

#: ../../source/tutorial/multiplicities.rst:72
msgid "Linearity"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:74
msgid ""
"The ``1`` multiplicity expresses that a variable must be used exactly "
"once. By \"used\" we mean either:"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:77
msgid ""
"if the variable is a data type or primitive value, it is pattern matched "
"against, ex. by being the subject of a *case* statement, or a function "
"argument that is pattern matched against, etc.,"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:78
msgid ""
"if the variable is a function, that function is applied (i.e. ran with an"
" argument)"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:80
msgid ""
"First, we'll see how this works on some small examples of functions and "
"data types, then see how it can be used to encode `resource protocols`_."
msgstr ""

#: ../../source/tutorial/multiplicities.rst:83
msgid ""
"Above, we saw the type of ``duplicate``. Let's try to write it "
"interactively, and see what goes wrong. We'll start by giving the type "
"and a skeleton definition with a hole"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:92
msgid ""
"Checking the type of a hole tells us the multiplicity of each variable in"
" scope. If we check the type of ``?help`` we'll see that we can't use "
"``a`` at run time, and we have to use ``x`` exactly once::"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:102
msgid "If we use ``x`` for one part of the pair..."
msgstr ""

#: ../../source/tutorial/multiplicities.rst:109
msgid ""
"...then the type of the remaining hole tells us we can't use it for the "
"other::"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:117
msgid ""
"The same happens if we try defining ``duplicate x = (?help, x)`` (try "
"it!)."
msgstr ""

#: ../../source/tutorial/multiplicities.rst:119
msgid ""
"In order to avoid parsing ambiguities, if you give an explicit "
"multiplicity for a variable as with the argument to ``duplicate``, you "
"need to give it a name too. But, if the name isn't used in the scope of "
"the type, you can use ``_`` instead of a name, as follows:"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:128
msgid ""
"The intution behind multiplicity ``1`` is that if we have a function with"
" a type of the following form..."
msgstr ""

#: ../../source/tutorial/multiplicities.rst:135
msgid ""
"...then the guarantee given by the type system is that *if* ``f x`` *is "
"used exactly once, then* ``x`` *is used exactly once*. So, if we insist "
"on trying to define ``duplicate``...::"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:141
msgid "...then Idris will complain::"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:146
msgid ""
"A similar intuition applies for data types. Consider the following types,"
" ``Lin`` which wraps an argument that must be used once, and ``Unr`` "
"which wraps an argument with unrestricted use"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:158
msgid ""
"If ``MkLin x`` is used once, then ``x`` is used once. But if ``MkUnr x`` "
"is used once, there is no guarantee on how often ``x`` is used. We can "
"see this a bit more clearly by starting to write projection functions for"
" ``Lin`` and ``Unr`` to extract the argument"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:171
msgid ""
"Checking the types of the holes shows us that, for ``getLin``, we must "
"use ``x`` exactly once (Because the ``val`` argument is used once, by "
"pattern matching on it as ``MkLin x``, and if ``MkLin x`` is used once, "
"``x`` must be used once)::"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:182
msgid ""
"For ``getUnr``, however, we still have to use ``val`` once, again by "
"pattern matching on it, but using ``MkUnr x`` once doesn't place any "
"restrictions on ``x``. So, ``x`` has unrestricted use in the body of "
"``getUnr``::"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:192
msgid "If ``getLin`` has an unrestricted argument..."
msgstr ""

#: ../../source/tutorial/multiplicities.rst:199
msgid "...then ``x`` is unrestricted in ``howmanyLin``::"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:207
msgid ""
"Remember the intuition from the type of ``MkLin`` is that if ``MkLin x`` "
"is used exactly once, ``x`` is used exactly once. But, we didn't say that"
" ``MkLin x`` would be used exactly once, so there is no restriction on "
"``x``."
msgstr ""

#: ../../source/tutorial/multiplicities.rst:212
msgid "Resource protocols"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:214
msgid ""
"One way to take advantage of being able to express linear usage of an "
"argument is in defining resource usage protocols, where we can use "
"linearity to ensure that any unique external resource has only one "
"instance, and we can use functions which are linear in their arguments to"
" represent state transitions on that resource. A door, for example, can "
"be in one of two states, ``Open`` or ``Closed``"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:228
msgid ""
"(Okay, we're just pretending here - imagine the ``doorId`` is a reference"
" to an external resource!)"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:231
msgid ""
"We can define functions for opening and closing the door which explicitly"
" describe how they change the state of a door, and that they are linear "
"in the door"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:240
msgid ""
"Remember, the intuition is that if ``openDoor d`` is used exactly once, "
"then ``d`` is used exactly once. So, provided that a door ``d`` has "
"multiplicity ``1`` when it's created, we *know* that once we call "
"``openDoor`` on it, we won't be able to use ``d`` again. Given that ``d``"
" is an external resource, and ``openDoor`` has changed it's state, this "
"is a good thing!"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:247
msgid ""
"We can ensure that any door we create has multiplicity ``1`` by creating "
"them with a ``newDoor`` function with the following type"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:254
msgid ""
"That is, ``newDoor`` takes a function, which it runs exactly once. That "
"function takes a door, which is used exactly once. We'll run it in ``IO``"
" to suggest that there is some interaction with the outside world going "
"on when we create the door. Since the multiplicity ``1`` means the door "
"has to be used exactly once, we need to be able to delete the door when "
"we're finished"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:265
msgid "So an example correct door protocol usage would be"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:276
msgid ""
"It's instructive to build this program interactively, with holes along "
"the way, and see how the multiplicities of ``d``, ``d'`` etc change. For "
"example"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:288
msgid ""
"Checking the type of ``?whatnow`` shows that ``d`` is now spent, but we "
"still have to use ``d'`` exactly once::"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:297
msgid ""
"Note that the ``0`` multiplicity for ``d`` means that we can still *talk*"
" about it - in particular, we can still reason about it in types - but we"
" can't use it again in a relevant position in the rest of the program. "
"It's also fine to shadow the name ``d`` throughout"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:311
msgid ""
"If we don't follow the protocol correctly - create the door, open it, "
"close it, then delete it - then the program won't type check. For "
"example, we can try not to delete the door before finishing"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:324
msgid "This gives the following error::"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:329
msgid ""
"There's a lot more to be said about the details here! But, this shows at "
"a high level how we can use linearity to capture resource usage protocols"
" at the type level. If we have an external resource which is guaranteed "
"to be used linearly, like ``Door``, we don't need to run operations on "
"that resource in an ``IO`` monad, since we're already enforcing an "
"ordering on operations and don't have access to any out of date resource "
"states. This is similar to the way interactive programs work in `the "
"Clean programming language <https://clean.cs.ru.nl/Clean>`_, and in fact "
"is how ``IO`` is implemented internally in Idris 2, with a special "
"``%World`` type for representing the state of the outside world that is "
"always used linearly"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:351
msgid ""
"Having multiplicities in the type system raises several interesting "
"questions, such as:"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:354
msgid ""
"Can we use linearity information to inform memory management and, for "
"example, have type level guarantees about functions which will not need "
"to perform garbage collection?"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:357
msgid ""
"How should multiplicities be incorporated into interfaces such as "
"``Functor``, ``Applicative`` and ``Monad``?"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:359
msgid ""
"If we have ``0``, and ``1`` as multiplicities, why stop there? Why not "
"have ``2``, ``3`` and more (like `Granule <https://granule-"
"project.github.io/granule.html>`_)"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:362
msgid ""
"What about multiplicity polymorphism, as in the `Linear Haskell proposal "
"<https://arxiv.org/abs/1710.09756>`_?"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:363
msgid "Even without all of that, what can we do *now*?"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:368
msgid "Erasure"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:370
msgid ""
"The ``1`` multiplicity give us many possibilities in the kinds of "
"properties we can express. But, the ``0`` multiplicity is perhaps more "
"important in that it allows us to be precise about which values are "
"relevant at run time, and which are compile time only (that is, which are"
" erased). Using the ``0`` multiplicity means a function's type now tells "
"us exactly what it needs at run time."
msgstr ""

#: ../../source/tutorial/multiplicities.rst:377
msgid "For example, in Idris 1 you could get the length of a vector as follows"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:384
msgid ""
"This is fine, since it runs in constant time, but the trade off is that "
"``n`` has to be available at run time, so at run time we always need the "
"length of the vector to be available if we ever call ``vlen``. Idris 1 "
"can infer whether the length is needed, but there's no easy way for a "
"programmer to be sure."
msgstr ""

#: ../../source/tutorial/multiplicities.rst:389
msgid "In Idris 2, we need to state explicitly that ``n`` is needed at run time"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:396
msgid ""
"(Incidentally, also note that in Idris 2, names bound in types are also "
"available in the definition without explicitly rebinding them.)"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:399
msgid ""
"This also means that when you call ``vlen``, you need the length "
"available. For example, this will give an error"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:407
msgid "Idris 2 reports::"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:412
msgid ""
"This means that it needs to use ``m`` as an argument to pass to ``vlen "
"xs``, where it needs to be available at run time, but ``m`` is not "
"available in ``sumLengths`` because it has multiplicity ``0``."
msgstr ""

#: ../../source/tutorial/multiplicities.rst:416
msgid ""
"We can see this more clearly by replacing the right hand side of "
"``sumLengths`` with a hole..."
msgstr ""

#: ../../source/tutorial/multiplicities.rst:424
msgid "...then checking the hole's type at the REPL::"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:435
msgid ""
"Instead, we need to give bindings for ``m`` and ``n`` with unrestricted "
"multiplicity"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:443
msgid ""
"Remember that giving no multiplicity on a binder, as with ``m`` and ``n``"
" here, means that the variable has unrestricted usage."
msgstr ""

#: ../../source/tutorial/multiplicities.rst:446
msgid ""
"If you're converting Idris 1 programs to work with Idris 2, this is "
"probably the biggest thing you need to think about. It is important to "
"note, though, that if you have bound implicits, such as..."
msgstr ""

#: ../../source/tutorial/multiplicities.rst:454
msgid ""
"...then it's a good idea to make sure ``t`` really is needed, or "
"performance might suffer due to the run time building the instance of "
"``t`` unnecessarily!"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:457
msgid ""
"One final note on erasure: it is an error to try to pattern match on an "
"argument with multiplicity ``0``, unless its value is inferrable from "
"elsewhere. So, the following definition is rejected"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:467
msgid "This is rejected with the error::"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:472
msgid ""
"The following, however, is fine, because in ``sNot``, even though we "
"appear to match on the erased argument ``x``, its value is uniquely "
"inferrable from the type of the second argument"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:486
msgid ""
"Experience with Idris 2 so far suggests that, most of the time, as long "
"as you're using unbound implicits in your Idris 1 programs, they will "
"work without much modification in Idris 2. The Idris 2 type checker will "
"point out where you require an unbound implicit argument at run time - "
"sometimes this is both surprising and enlightening!"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:495
msgid "Pattern Matching on Types"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:497
msgid ""
"One way to think about dependent types is to think of them as \"first "
"class\" objects in the language, in that they can be assigned to "
"variables, passed around and returned from functions, just like any other"
" construct. But, if they're truly first class, we should be able to "
"pattern match on them too! Idris 2 allows us to do this. For example"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:510
msgid "We can try this as follows::"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:519
msgid ""
"Pattern matching on function types is interesting, because the return "
"type may depend on the input value. For example, let's add a case to "
"``showType``"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:527
msgid "Inspecting the type of ``help`` tells us::"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:534
msgid ""
"So, the return type ``a`` depends on the input value of type ``Nat``, and"
" we'll need to come up with a value to use ``a``, for example"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:541
msgid ""
"Note that multiplicities on the binders, and the ability to pattern match"
" on *non-erased* types mean that the following two types are distinct"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:549
msgid ""
"In the case of ``notId``, we can match on ``a`` and get a function which "
"is certainly not the identity function"
msgstr ""

#: ../../source/tutorial/multiplicities.rst:564
msgid ""
"There is an important consequence of being able to distinguish between "
"relevant and irrelevant type arguments, which is that a function is "
"*only* parametric in ``a`` if ``a`` has multiplicity ``0``. So, in the "
"case of ``notId``, ``a`` is *not* a parameter, and so we can't draw any "
"conclusions about the way the function will behave because it is "
"polymorphic, because the type tells us it might pattern match on ``a``."
msgstr ""

#: ../../source/tutorial/multiplicities.rst:571
msgid ""
"On the other hand, it is merely a coincidence that, in non-dependently "
"typed languages, types are *irrelevant* and get erased, and values are "
"*relevant* and remain at run time. Idris 2, being based on QTT, allows us"
" to make the distinction between relevant and irrelevant arguments "
"precise. Types can be relevant, values (such as the ``n`` index to "
"vectors) can be irrelevant."
msgstr ""

#: ../../source/tutorial/multiplicities.rst:577
msgid ""
"For more details on multiplicities, see `Idris 2: Quantitative Type "
"Theory in Action <https://www.type-driven.org.uk/edwinb/idris-2"
"-quantitative-type-theory-in-action.html>`_."
msgstr ""

#: ../../source/tutorial/packages.rst:5
msgid "Packages"
msgstr ""

#: ../../source/tutorial/packages.rst:7
msgid ""
"Idris includes a simple build system for building packages and "
"executables from a named package description file. These files can be "
"used with the Idris compiler to manage the development process."
msgstr ""

#: ../../source/tutorial/packages.rst:12
msgid "Package Descriptions"
msgstr ""

#: ../../source/tutorial/packages.rst:14
msgid "A package description includes the following:"
msgstr ""

#: ../../source/tutorial/packages.rst:16
msgid ""
"A header, consisting of the keyword ``package`` followed by a package "
"name. Package names can be any valid Idris identifier. The iPKG format "
"also takes a quoted version that accepts any valid filename."
msgstr ""

#: ../../source/tutorial/packages.rst:20
msgid "Fields describing package contents, ``<field> = <value>``."
msgstr ""

#: ../../source/tutorial/packages.rst:22
msgid ""
"At least one field must be the modules field, where the value is a comma "
"separated list of modules. For example, given an idris package ``maths`` "
"that has modules ``Maths.idr``, ``Maths.NumOps.idr``, "
"``Maths.BinOps.idr``, and ``Maths.HexOps.idr``, the corresponding package"
" file would be:"
msgstr ""

#: ../../source/tutorial/packages.rst:37
msgid ""
"Running ``idris2 --init`` will interactively create a new package file in"
" the current directory. The generated pacakge file lists all configurable"
" fields with a brief description."
msgstr ""

#: ../../source/tutorial/packages.rst:39
msgid ""
"Other examples of package files can be found in the ``libs`` directory of"
" the main Idris repository, and in `third-party libraries "
"<https://github.com/idris-lang/Idris-dev/wiki/Libraries>`_."
msgstr ""

#: ../../source/tutorial/packages.rst:45
msgid "Using Package files"
msgstr ""

#: ../../source/tutorial/packages.rst:47
msgid ""
"Idris itself is aware about packages, and special commands are available "
"to help with, for example, building packages, installing packages, and "
"cleaning packages.  For instance, given the ``maths`` package from "
"earlier we can use Idris as follows:"
msgstr ""

#: ../../source/tutorial/packages.rst:52
msgid "``idris2 --build maths.ipkg`` will build all modules in the package"
msgstr ""

#: ../../source/tutorial/packages.rst:54
msgid ""
"``idris2 --install maths.ipkg`` will install the package, making it "
"accessible by other Idris libraries and programs."
msgstr ""

#: ../../source/tutorial/packages.rst:57
msgid ""
"``idris2 --clean maths.ipkg`` will delete all intermediate code and "
"executable files generated when building."
msgstr ""

#: ../../source/tutorial/packages.rst:60
msgid ""
"Once the maths package has been installed, the command line option "
"``--package maths`` makes it accessible (abbreviated to ``-p maths``). "
"For example:"
msgstr ""

#: ../../source/tutorial/packages.rst:69
msgid "Package Dependencies Using Atom"
msgstr ""

#: ../../source/tutorial/packages.rst:71
msgid ""
"If you are using the Atom editor and have a dependency on another "
"package, corresponding to for instance ``import Lightyear`` or ``import "
"Pruviloj``, you need to let Atom know that it should be loaded. The "
"easiest way to accomplish that is with a .ipkg file. The general contents"
" of an ipkg file will be described in the next section of the tutorial, "
"but for now here is a simple recipe for this trivial case:"
msgstr ""

#: ../../source/tutorial/packages.rst:78
msgid "Create a folder myProject."
msgstr ""

#: ../../source/tutorial/packages.rst:80
msgid "Add a file myProject.ipkg containing just a couple of lines:"
msgstr ""

#: ../../source/tutorial/packages.rst:88
msgid "In Atom, use the File menu to Open Folder myProject."
msgstr ""

#: ../../source/tutorial/starting.rst:5
msgid "Getting Started"
msgstr ""

#: ../../source/tutorial/starting.rst:8
msgid "Installing from Source"
msgstr ""

#: ../../source/tutorial/starting.rst:16
msgid "Prerequisites"
msgstr ""

#: ../../source/tutorial/starting.rst:18
msgid ""
"Idris 2 is implemented in Idris 2 itself, so to bootstrap it you can "
"build from generated Scheme sources. To do this, you need either Chez "
"Scheme (default, and currently preferred since it is the fastest) or "
"Racket. You can get one of these from:"
msgstr ""

#: ../../source/tutorial/starting.rst:23
msgid "`Chez Scheme <https://cisco.github.io/ChezScheme/>`_"
msgstr ""

#: ../../source/tutorial/starting.rst:24
msgid "`Racket <https://download.racket-lang.org/>`_"
msgstr ""

#: ../../source/tutorial/starting.rst:26
msgid ""
"Both are also available from MacPorts/Homebrew and all major Linux "
"distributions. Windows requires some further prerequisites, see :ref"
":`windows-install`."
msgstr ""

#: ../../source/tutorial/starting.rst:29
msgid ""
"**Note**: If you install Chez Scheme from source files, building it "
"locally, make sure you run ``./configure --threads`` to build "
"multithreading support in."
msgstr ""

#: ../../source/tutorial/starting.rst:33
msgid "Downloading and Installing"
msgstr ""

#: ../../source/tutorial/starting.rst:35
msgid ""
"You can download the Idris 2 source from the `Idris web site <https://www"
".idris-lang.org/pages/download.html>`_ or get the latest development "
"version from `idris-lang/Idris2 <https://github.com/idris-lang/Idris2>`_ "
"on Github.  This includes the Idris 2 source code and the Scheme code "
"generated from that.  Once you have unpacked the source, you can install "
"it as follows::"
msgstr ""

#: ../../source/tutorial/starting.rst:44
msgid ""
"Where `chez` is the executable name of the Chez Scheme compiler. This "
"will vary from system to system, but is often one of ``scheme``, "
"``chezscheme``, or ``chezscheme9.5``. If you are building via Racket, you"
" can install it as follows::"
msgstr ""

#: ../../source/tutorial/starting.rst:51
msgid ""
"Once you've successfully bootstrapped with any of the above commands, you"
" can install with the command ``make install``.  This will, by default, "
"install into ``${HOME}/.idris2``. You can change this by editing the "
"options in ``config.mk``. For example, to install into ``/usr/local``, "
"you can edit the ``IDRIS2_PREFIX`` as follows::"
msgstr ""

#: ../../source/tutorial/starting.rst:60
msgid "Installing from a Package Manager"
msgstr ""

#: ../../source/tutorial/starting.rst:63
msgid "Installing Using Homebrew"
msgstr ""

#: ../../source/tutorial/starting.rst:65
msgid ""
"If you are Homebrew user you can install Idris 2 together with all the "
"requirements by running following command::"
msgstr ""

#: ../../source/tutorial/starting.rst:71
msgid "Checking Installation"
msgstr ""

#: ../../source/tutorial/starting.rst:73
msgid ""
"To check that installation has succeeded, and to write your first Idris "
"program, create a file called ``hello.idr`` containing the following "
"text:"
msgstr ""

#: ../../source/tutorial/starting.rst:84
msgid ""
"If you are familiar with Haskell, it should be fairly clear what the "
"program is doing and how it works, but if not, we will explain the "
"details later. You can compile the program to an executable by entering "
"``idris2 hello.idr -o hello`` at the shell prompt. This will, by default,"
" create an executable called ``hello``, which invokes a generated and "
"compiled Chez Scheme program, in the destination directory ``build/exec``"
" which you can run:"
msgstr ""

#: ../../source/tutorial/starting.rst:98
msgid ""
"Please note that the dollar sign ``$`` indicates the shell prompt! Some "
"useful options to the Idris command are:"
msgstr ""

#: ../../source/tutorial/starting.rst:101
msgid "``-o prog`` to compile to an executable called ``prog``."
msgstr ""

#: ../../source/tutorial/starting.rst:103
msgid ""
"``--check`` type check the file and its dependencies without starting the"
" interactive environment."
msgstr ""

#: ../../source/tutorial/starting.rst:105
msgid ""
"``--package pkg`` add package as dependency, e.g. ``--package contrib`` "
"to make use of the contrib package."
msgstr ""

#: ../../source/tutorial/starting.rst:107
msgid "``--help`` display usage summary and command line options."
msgstr ""

#: ../../source/tutorial/starting.rst:109
msgid ""
"You can find out more about compiling to executables in Section :ref"
":`sect-execs`."
msgstr ""

#: ../../source/tutorial/starting.rst:113
msgid "The Interactive Environment"
msgstr ""

#: ../../source/tutorial/starting.rst:115
msgid ""
"Entering ``idris2`` at the shell prompt starts up the interactive "
"environment. You should see something like the following:"
msgstr ""

#: ../../source/tutorial/starting.rst:120
msgid ""
"This gives a ``ghci`` style interface which allows evaluation of, as well"
" as type checking of, expressions; theorem proving, compilation; editing;"
" and various other operations. The command ``:?`` gives a list of "
"supported commands. Below, we see an example run in which ``hello.idr`` "
"is loaded, the type of ``main`` is checked and then the program is "
"compiled to the executable file ``hello``, available in the destination "
"directory ``build/exec/``. Type checking a file, if successful, creates a"
" bytecode version of the file (in this case ``build/ttc/hello.ttc``) to "
"speed up loading in future. The bytecode is regenerated if the source "
"file changes."
msgstr ""

#: ../../source/tutorial/theorems.rst:5
msgid "Theorem Proving"
msgstr ""

#: ../../source/tutorial/theorems.rst:8
msgid "Equality"
msgstr ""

#: ../../source/tutorial/theorems.rst:10
msgid ""
"Idris allows propositional equalities to be declared, allowing theorems "
"about programs to be stated and proved. An equality type is defined as "
"follows in the Prelude:"
msgstr ""

#: ../../source/tutorial/theorems.rst:19
msgid ""
"As a notational convenience, ``Equal x y`` can be written as ``x = y``. "
"Equalities can be proposed between any values of any types, but the only "
"way to construct a proof of equality is if values actually are equal. For"
" example:"
msgstr ""

#: ../../source/tutorial/theorems.rst:32
msgid "If we try..."
msgstr ""

#: ../../source/tutorial/theorems.rst:39
msgid "...then we'll get an error:"
msgstr ""

#: ../../source/tutorial/theorems.rst:53
msgid "The Empty Type"
msgstr ""

#: ../../source/tutorial/theorems.rst:55
msgid ""
"There is an empty type, ``Void``, which has no constructors. It is "
"therefore impossible to construct a canonical element of the empty type. "
"We can therefore use the empty type to prove that something is "
"impossible, for example zero is never equal to a successor:"
msgstr ""

#: ../../source/tutorial/theorems.rst:69
msgid ""
"Don't worry if you don't get all the details of how this works just yet -"
" essentially, it applies the library function ``replace``, which uses an "
"equality proof to transform a predicate. Here we use it to transform a "
"value of a type which can exist, the empty tuple, to a value of a type "
"which can’t, by using a proof of something which can’t exist."
msgstr ""

#: ../../source/tutorial/theorems.rst:75
msgid ""
"Once we have an element of the empty type, we can prove anything. "
"``void`` is defined in the library, to assist with proofs by "
"contradiction."
msgstr ""

#: ../../source/tutorial/theorems.rst:84
msgid "Proving Theorems"
msgstr ""

#: ../../source/tutorial/theorems.rst:86
msgid ""
"When type checking dependent types, the type itself gets *normalised*. So"
" imagine we want to prove the following theorem about the reduction "
"behaviour of ``plus``:"
msgstr ""

#: ../../source/tutorial/theorems.rst:94
msgid ""
"We’ve written down the statement of the theorem as a type, in just the "
"same way as we would write the type of a program. In fact there is no "
"real distinction between proofs and programs. A proof, as far as we are "
"concerned here, is merely a program with a precise enough type to "
"guarantee a particular property of interest."
msgstr ""

#: ../../source/tutorial/theorems.rst:100
msgid ""
"We won’t go into details here, but the Curry-Howard correspondence "
"[#Timothy]_ explains this relationship. The proof itself is immediate, "
"because ``plus Z n`` normalises to ``n`` by the definition of ``plus``:"
msgstr ""

#: ../../source/tutorial/theorems.rst:108
msgid ""
"It is slightly harder if we try the arguments the other way, because plus"
" is defined by recursion on its first argument. The proof also works by "
"recursion on the first argument to ``plus``, namely ``n``."
msgstr ""

#: ../../source/tutorial/theorems.rst:118
msgid ""
"``cong`` is a function defined in the library which states that equality "
"respects function application:"
msgstr ""

#: ../../source/tutorial/theorems.rst:125
msgid ""
"To see more detail on what's going on, we can replace the recursive call "
"to ``plusReducesZ`` with a hole:"
msgstr ""

#: ../../source/tutorial/theorems.rst:132
msgid "Then inspecting the type of the hole at the REPL shows us:"
msgstr ""

#: ../../source/tutorial/theorems.rst:141
msgid "We can do the same for the reduction behaviour of plus on successors:"
msgstr ""

#: ../../source/tutorial/theorems.rst:149
msgid ""
"Even for small theorems like these, the proofs are a little tricky to "
"construct in one go. When things get even slightly more complicated, it "
"becomes too much to think about to construct proofs in this “batch mode”."
msgstr ""

#: ../../source/tutorial/theorems.rst:154
msgid ""
"Idris provides interactive editing capabilities, which can help with "
"building proofs. For more details on building proofs interactively in an "
"editor, see :ref:`proofs-index`."
msgstr ""

#: ../../source/tutorial/theorems.rst:161
msgid "Theorems in Practice"
msgstr ""

#: ../../source/tutorial/theorems.rst:163
msgid ""
"The need to prove theorems can arise naturally in practice. For example, "
"previously (:ref:`sec-views`) we implemented ``natToBin`` using a "
"function ``parity``:"
msgstr ""

#: ../../source/tutorial/theorems.rst:171
msgid ""
"We provided a definition for ``parity``, but without explanation.  We "
"might have hoped that it would look something like the following:"
msgstr ""

#: ../../source/tutorial/theorems.rst:183
msgid "Unfortunately, this fails with a type error:"
msgstr ""

#: ../../source/tutorial/theorems.rst:193
msgid ""
"The problem is that normalising ``S j + S j``, in the type of ``Even`` "
"doesn't result in what we need for the type of the right hand side of "
"``Parity``. We know that ``S (S (plus j j))`` is going to be equal to ``S"
" j + S j``, but we need to explain it to Idris with a proof. We can begin"
" by adding some *holes* (see :ref:`sect-holes`) to the definition:"
msgstr ""

#: ../../source/tutorial/theorems.rst:210
msgid ""
"Checking the type of ``helpEven`` shows us what we need to prove for the "
"``Even`` case:"
msgstr ""

#: ../../source/tutorial/theorems.rst:220
msgid ""
"We can therefore write a helper function to *rewrite* the type to the "
"form we need:"
msgstr ""

#: ../../source/tutorial/theorems.rst:228
msgid ""
"The ``rewrite ... in`` syntax allows you to change the required type of "
"an expression by rewriting it according to an equality proof. Here, we "
"have used ``plusSuccRightSucc``, which has the following type:"
msgstr ""

#: ../../source/tutorial/theorems.rst:236
msgid ""
"We can see the effect of ``rewrite`` by replacing the right hand side of "
"``helpEven`` with a hole, and working step by step. Beginning with the "
"following:"
msgstr ""

#: ../../source/tutorial/theorems.rst:244
msgid "We can look at the type of ``helpEven_rhs``:"
msgstr ""

#: ../../source/tutorial/theorems.rst:253
msgid ""
"Then we can ``rewrite`` by applying ``plusSuccRightSucc j j``, which "
"gives an equation ``S (j + j) = j + S j``, thus replacing ``S (j + j)`` "
"(or, in this case, ``S (plus j j)`` since ``S (j + j)`` reduces to that) "
"in the type with ``j + S j``:"
msgstr ""

#: ../../source/tutorial/theorems.rst:263
msgid ""
"Checking the type of ``helpEven_rhs`` now shows what has happened, "
"including the type of the equation we just used (as the type of "
"``_rewrite_rule``):"
msgstr ""

#: ../../source/tutorial/theorems.rst:274
msgid ""
"Using ``rewrite`` and another helper for the ``Odd`` case, we can "
"complete ``parity`` as follows:"
msgstr ""

#: ../../source/tutorial/theorems.rst:292
msgid ""
"Full details of ``rewrite`` are beyond the scope of this introductory "
"tutorial, but it is covered in the theorem proving tutorial (see :ref"
":`proofs-index`)."
msgstr ""

#: ../../source/tutorial/theorems.rst:298
msgid "Totality Checking"
msgstr ""

#: ../../source/tutorial/theorems.rst:300
msgid ""
"If we really want to trust our proofs, it is important that they are "
"defined by *total* functions — that is, a function which is defined for "
"all possible inputs and is guaranteed to terminate. Otherwise we could "
"construct an element of the empty type, from which we could prove "
"anything:"
msgstr ""

#: ../../source/tutorial/theorems.rst:318
msgid ""
"Internally, Idris checks every definition for totality, and we can check "
"at the prompt with the ``:total`` command. We see that neither of the "
"above definitions is total:"
msgstr ""

#: ../../source/tutorial/theorems.rst:329
msgid ""
"Note the use of the word “possibly” — a totality check can never be "
"certain due to the undecidability of the halting problem. The check is, "
"therefore, conservative. It is also possible (and indeed advisable, in "
"the case of proofs) to mark functions as total so that it will be a "
"compile time error for the totality check to fail:"
msgstr ""

#: ../../source/tutorial/theorems.rst:340
msgid ""
"Reassuringly, our proof in Section :ref:`sect-empty` that the zero and "
"successor constructors are disjoint is total:"
msgstr ""

#: ../../source/tutorial/theorems.rst:348
msgid ""
"The totality check is, necessarily, conservative. To be recorded as "
"total, a function ``f`` must:"
msgstr ""

#: ../../source/tutorial/theorems.rst:351
msgid "Cover all possible inputs"
msgstr ""

#: ../../source/tutorial/theorems.rst:353
msgid ""
"Be *well-founded* — i.e. by the time a sequence of (possibly mutually) "
"recursive calls reaches ``f`` again, it must be possible to show that one"
" of its arguments has decreased."
msgstr ""

#: ../../source/tutorial/theorems.rst:357
msgid "Not use any data types which are not *strictly positive*"
msgstr ""

#: ../../source/tutorial/theorems.rst:359
msgid "Not call any non-total functions"
msgstr ""

#: ../../source/tutorial/theorems.rst:362
msgid "Directives and Compiler Flags for Totality"
msgstr ""

#: ../../source/tutorial/theorems.rst:366
msgid "Not all of this is implemented yet for Idris 2"
msgstr ""

#: ../../source/tutorial/theorems.rst:368
msgid ""
"By default, Idris allows all well-typed definitions, whether total or "
"not. However, it is desirable for functions to be total as far as "
"possible, as this provides a guarantee that they provide a result for all"
" possible inputs, in finite time. It is possible to make total functions "
"a requirement, either:"
msgstr ""

#: ../../source/tutorial/theorems.rst:373
msgid "By using the ``--total`` compiler flag."
msgstr ""

#: ../../source/tutorial/theorems.rst:375
#, python-format
msgid ""
"By adding a ``%default total`` directive to a source file. All "
"definitions after this will be required to be total, unless explicitly "
"flagged as ``partial``."
msgstr ""

#: ../../source/tutorial/theorems.rst:379
#, python-format
msgid ""
"All functions *after* a ``%default total`` declaration are required to be"
" total. Correspondingly, after a ``%default partial`` declaration, the "
"requirement is relaxed."
msgstr ""

#: ../../source/tutorial/theorems.rst:383
msgid ""
"Finally, the compiler flag ``--warnpartial`` causes to print a warning "
"for any undeclared partial function."
msgstr ""

#: ../../source/tutorial/theorems.rst:387
msgid "Totality checking issues"
msgstr ""

#: ../../source/tutorial/theorems.rst:389
msgid ""
"Please note that the totality checker is not perfect! Firstly, it is "
"necessarily conservative due to the undecidability of the halting "
"problem, so many programs which *are* total will not be detected as such."
" Secondly, the current implementation has had limited effort put into it "
"so far, so there may still be cases where it believes a function is total"
" which is not. Do not rely on it for your proofs yet!"
msgstr ""

#: ../../source/tutorial/theorems.rst:397
msgid "Hints for totality"
msgstr ""

#: ../../source/tutorial/theorems.rst:399
msgid ""
"In cases where you believe a program is total, but Idris does not agree, "
"it is possible to give hints to the checker to give more detail for a "
"termination argument. The checker works by ensuring that all chains of "
"recursive calls eventually lead to one of the arguments decreasing "
"towards a base case, but sometimes this is hard to spot. For example, the"
" following definition cannot be checked as ``total`` because the checker "
"cannot decide that ``filter (< x) xs`` will always be smaller than ``(x "
":: xs)``:"
msgstr ""

#: ../../source/tutorial/theorems.rst:415
msgid ""
"The function ``assert_smaller``, defined in the prelude, is intended to "
"address this problem:"
msgstr ""

#: ../../source/tutorial/theorems.rst:423
msgid ""
"It simply evaluates to its second argument, but also asserts to the "
"totality checker that ``y`` is structurally smaller than ``x``. This can "
"be used to explain the reasoning for totality if the checker cannot work "
"it out itself. The above example can now be written as:"
msgstr ""

#: ../../source/tutorial/theorems.rst:437
msgid ""
"The expression ``assert_smaller (x :: xs) (filter (<= x) xs)`` asserts "
"that the result of the filter will always be smaller than the pattern "
"``(x :: xs)``."
msgstr ""

#: ../../source/tutorial/theorems.rst:441
msgid ""
"In more extreme cases, the function ``assert_total`` marks a "
"subexpression as always being total:"
msgstr ""

#: ../../source/tutorial/theorems.rst:449
msgid ""
"In general, this function should be avoided, but it can be very useful "
"when reasoning about primitives or externally defined functions (for "
"example from a C library) where totality can be shown by an external "
"argument."
msgstr ""

#: ../../source/tutorial/theorems.rst:455
msgid ""
"Timothy G. Griffin. 1989. A formulae-as-type notion of control. In "
"Proceedings of the 17th ACM SIGPLAN-SIGACT symposium on Principles of "
"programming languages (POPL '90). ACM, New York, NY, USA, 47-58. "
"DOI=10.1145/96709.96714 https://doi.acm.org/10.1145/96709.96714"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:5
msgid "Types and Functions"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:8
msgid "Primitive Types"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:10
msgid ""
"Idris defines several primitive types: ``Int``, ``Integer`` and "
"``Double`` for numeric operations, ``Char`` and ``String`` for text "
"manipulation, and ``Ptr`` which represents foreign pointers. There are "
"also several data types declared in the library, including ``Bool``, with"
" values ``True`` and ``False``. We can declare some constants with these "
"types. Enter the following into a file ``Prims.idr`` and load it into the"
" Idris interactive environment by typing ``idris2 Prims.idr``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:34
msgid ""
"An Idris file consists of an optional module declaration (here ``module "
"Prims``) followed by an optional list of imports and a collection of "
"declarations and definitions. In this example no imports have been "
"specified. However Idris programs can consist of several modules and the "
"definitions in each module each have their own namespace. This is "
"discussed further in Section :ref:`sect-namespaces`. When writing Idris "
"programs both the order in which definitions are given and indentation "
"are significant. Functions and data types must be defined before use, "
"incidentally each definition must have a type declaration, for example "
"see ``x : Int``, ``foo : String``, from the above listing. New "
"declarations must begin at the same level of indentation as the preceding"
" declaration. Alternatively, a semicolon ``;`` can be used to terminate "
"declarations."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:48
msgid ""
"A library module ``prelude`` is automatically imported by every Idris "
"program, including facilities for IO, arithmetic, data structures and "
"various common functions. The prelude defines several arithmetic and "
"comparison operators, which we can use at the prompt. Evaluating things "
"at the prompt gives an answer, for example:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:61
msgid ""
"All of the usual arithmetic and comparison operators are defined for the "
"primitive types. They are overloaded using interfaces, as we will discuss"
" in Section :ref:`sect-interfaces` and can be extended to work on user "
"defined types. Boolean expressions can be tested with the "
"``if...then...else`` construct, for example:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:73
msgid "Data Types"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:75
msgid ""
"Data types are declared in a similar way and with similar syntax to "
"Haskell. Natural numbers and lists, for example, can be declared as "
"follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:85
msgid ""
"Data type names cannot begin with a lower case letter (we will see later "
"why not!).  The above declarations are taken from the standard library. "
"Unary natural numbers can be either zero (``Z``), or the successor of "
"another natural number (``S k``). Lists can either be empty (``Nil``) or "
"a value added to the front of another list (``x :: xs``). In the "
"declaration for ``List``, we used an infix operator ``::``. New operators"
" such as this can be added using a fixity declaration, as follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:97
msgid ""
"Functions, data constructors and type constructors may all be given infix"
" operators as names. They may be used in prefix form if enclosed in "
"brackets, e.g. ``(::)``. Infix operators can use any of the symbols:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:106
msgid "Some operators built from these symbols can't be user defined. These are"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:108
msgid ""
"``%``, ``\\``, ``:``, ``=``, ``|``, ``|||``, ``<-``, ``->``, ``=>``, "
"``?``, ``!``, ``&``, ``**``, ``..``"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:112
msgid "Functions"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:114
msgid ""
"Functions are implemented by pattern matching, again using a similar "
"syntax to Haskell. The main difference is that Idris requires type "
"declarations for all functions, using a single colon ``:`` (rather than "
"Haskell’s double colon ``::``). Some natural number arithmetic functions "
"can be defined as follows, again taken from the standard library:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:133
msgid ""
"The standard arithmetic operators ``+`` and ``*`` are also overloaded for"
" use by ``Nat``, and are implemented using the above functions. Unlike "
"Haskell, there is no restriction on whether function names must begin "
"with a capital letter or not. Function names (``plus`` and ``mult`` "
"above), data constructors (``Z``, ``S``, ``Nil`` and ``::``) and type "
"constructors (``Nat`` and ``List``) are all part of the same namespace. "
"By convention, however, data types and constructor names typically begin "
"with a capital letter. We can test these functions at the Idris prompt:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:150
msgid ""
"Like arithmetic operations, integer literals are also overloaded using "
"interfaces, meaning that we can also test the functions as follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:160
msgid ""
"You may wonder, by the way, why we have unary natural numbers when our "
"computers have perfectly good integer arithmetic built in. The reason is "
"primarily that unary numbers have a very convenient structure which is "
"easy to reason about, and easy to relate to other data structures as we "
"will see later. Nevertheless, we do not want this convenience to be at "
"the expense of efficiency. Fortunately, Idris knows about the "
"relationship between ``Nat`` (and similarly structured types) and "
"numbers. This means it can optimise the representation, and functions "
"such as ``plus`` and ``mult``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:171
msgid "``where`` clauses"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:173
msgid ""
"Functions can also be defined *locally* using ``where`` clauses. For "
"example, to define a function which reverses a list, we can use an "
"auxiliary function which accumulates the new, reversed list, and which "
"does not need to be visible globally:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:186
msgid ""
"Indentation is significant — functions in the ``where`` block must be "
"indented further than the outer function."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:189
msgid "Scope"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:191
msgid ""
"Any names which are visible in the outer scope are also visible in the "
"``where`` clause (unless they have been redefined, such as ``xs`` here). "
"A name which appears in the type will be in scope in the ``where`` "
"clause."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:196
msgid ""
"As well as functions, ``where`` blocks can include local data "
"declarations, such as the following where ``MyLT`` is not accessible "
"outside the definition of ``foo``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:212
msgid ""
"Functions defined in a ``where`` clause need a type declaration just like"
" any top level function. Here is another example of how this works in "
"practice:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:238
msgid "Totality and Covering"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:240
msgid ""
"By default, functions in Idris must be ``covering``. That is, there must "
"be patterns which cover all possible values of the inputs types. For "
"example, the following definition will give an error:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:249
msgid ""
"This gives an error because ``fromMaybe Nothing`` is not defined. Idris "
"reports:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:257
msgid "You can override this with a ``partial`` annotation:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:264
msgid ""
"However, this is not advisable, and in general you should only do this "
"during the initial development of a function, or during debugging.  If "
"you try to evaluate ``fromMaybe Nothing`` at run time you will get a run "
"time error."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:269
msgid "Holes"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:271
msgid ""
"Idris programs can contain *holes* which stand for incomplete parts of "
"programs. For example, we could leave a hole for the greeting in our "
"\"Hello world\" program:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:280
msgid ""
"The syntax ``?greeting`` introduces a hole, which stands for a part of a "
"program which is not yet written. This is a valid Idris program, and you "
"can check the type of ``greeting``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:290
msgid ""
"Checking the type of a hole also shows the types of any variables in "
"scope. For example, given an incomplete definition of ``even``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:299
msgid ""
"We can check the type of ``even_rhs`` and see the expected return type, "
"and the type of the variable ``k``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:309
msgid ""
"Holes are useful because they help us write functions *incrementally*. "
"Rather than writing an entire function in one go, we can leave some parts"
" unwritten and use Idris to tell us what is necessary to complete the "
"definition."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:315
msgid "Dependent Types"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:320
msgid "First Class Types"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:322
msgid ""
"In Idris, types are first class, meaning that they can be computed and "
"manipulated (and passed to functions) just like any other language "
"construct. For example, we could write a function which computes a type:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:332
msgid ""
"This function calculates the appropriate type from a ``Bool`` which flags"
" whether the type should be a singleton or not. We can use this function "
"to calculate a type anywhere that a type can be used. For example, it can"
" be used to calculate a return type:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:343
msgid ""
"Or it can be used to have varying input types. The following function "
"calculates either the sum of a list of ``Nat``, or returns the given "
"``Nat``, depending on whether the singleton flag is true:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:355
msgid "Vectors"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:357
msgid ""
"A standard example of a dependent data type is the type of “lists with "
"length”, conventionally called vectors in the dependent type literature. "
"They are available as part of the Idris library, by importing "
"``Data.Vect``, or we can declare them as follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:368
msgid ""
"Note that we have used the same constructor names as for ``List``. Ad-hoc"
" name overloading such as this is accepted by Idris, provided that the "
"names are declared in different namespaces (in practice, normally in "
"different modules). Ambiguous constructor names can normally be resolved "
"from context."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:374
msgid ""
"This declares a family of types, and so the form of the declaration is "
"rather different from the simple type declarations above. We explicitly "
"state the type of the type constructor ``Vect`` — it takes a ``Nat`` and "
"a type as an argument, where ``Type`` stands for the type of types. We "
"say that ``Vect`` is *indexed* over ``Nat`` and *parameterised* by "
"``Type``. Each constructor targets a different part of the family of "
"types. ``Nil`` can only be used to construct vectors with zero length, "
"and ``::`` to construct vectors with non-zero length. In the type of "
"``::``, we state explicitly that an element of type ``a`` and a tail of "
"type ``Vect k a`` (i.e., a vector of length ``k``) combine to make a "
"vector of length ``S k``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:386
msgid ""
"We can define functions on dependent types such as ``Vect`` in the same "
"way as on simple types such as ``List`` and ``Nat`` above, by pattern "
"matching. The type of a function over ``Vect`` will describe what happens"
" to the lengths of the vectors involved. For example, ``++``, defined as "
"follows, appends two ``Vect``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:398
msgid ""
"The type of ``(++)`` states that the resulting vector’s length will be "
"the sum of the input lengths. If we get the definition wrong in such a "
"way that this does not hold, Idris will not accept the definition. For "
"example:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:409
msgid "When run through the Idris type checker, this results in the following:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:423
msgid ""
"This error message suggests that there is a length mismatch between two "
"vectors — we needed a vector of length ``k + m``, but provided a vector "
"of length ``k + k``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:428
msgid "The Finite Sets"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:430
msgid ""
"Finite sets, as the name suggests, are sets with a finite number of "
"elements. They are available as part of the Idris library, by importing "
"``Data.Fin``, or can be declared as follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:440
msgid ""
"From the signature,  we can see that this is a type constructor that "
"takes a ``Nat``, and produces a type. So this is not a set in the sense "
"of a collection that is a container of objects, rather it is the "
"canonical set of unnamed elements, as in \"the set of 5 elements,\" for "
"example. Effectively, it is a type that captures integers that fall into "
"the range of zero to ``(n - 1)`` where ``n`` is the argument used to "
"instantiate the ``Fin`` type. For example, ``Fin 5`` can be thought of as"
" the type of integers between 0 and 4."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:447
msgid "Let us look at the constructors in greater detail."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:449
msgid ""
"``FZ`` is the zeroth element of a finite set with ``S k`` elements; ``FS "
"n`` is the ``n+1``\\ th element of a finite set with ``S k`` elements. "
"``Fin`` is indexed by a ``Nat``, which represents the number of elements "
"in the set. Since we can’t construct an element of an empty set, neither "
"constructor targets ``Fin Z``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:455
msgid ""
"As mentioned above, a useful application of the ``Fin`` family is to "
"represent bounded natural numbers. Since the first ``n`` natural numbers "
"form a finite set of ``n`` elements, we can treat ``Fin n`` as the set of"
" integers greater than or equal to zero and less than ``n``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:460
msgid ""
"For example, the following function which looks up an element in a "
"``Vect``, by a bounded index given as a ``Fin n``, is defined in the "
"prelude:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:470
msgid ""
"This function looks up a value at a given location in a vector. The "
"location is bounded by the length of the vector (``n`` in each case), so "
"there is no need for a run-time bounds check. The type checker guarantees"
" that the location is no larger than the length of the vector, and of "
"course no less than zero."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:476
msgid ""
"Note also that there is no case for ``Nil`` here. This is because it is "
"impossible. Since there is no element of ``Fin Z``, and the location is a"
" ``Fin n``, then ``n`` can not be ``Z``. As a result, attempting to look "
"up an element in an empty vector would give a compile time type error, "
"since it would force ``n`` to be ``Z``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:483
msgid "Implicit Arguments"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:485
msgid "Let us take a closer look at the type of ``index``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:491
msgid ""
"It takes two arguments, an element of the finite set of ``n`` elements, "
"and a vector with ``n`` elements of type ``a``. But there are also two "
"names, ``n`` and ``a``, which are not declared explicitly. These are "
"*implicit* arguments to ``index``. We could also write the type of "
"``index`` as:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:501
msgid ""
"Implicit arguments, given with the ``forall`` declaration, are not given "
"in applications of ``index``; their values can be inferred from the types"
" of the ``Fin n`` and ``Vect n a`` arguments. Any name beginning with a "
"lower case letter which appears as a parameter or index in a type "
"declaration, which is not applied to any arguments, will *always* be "
"automatically bound as an implicit argument; this is why data type names "
"cannot begin with a lower case letter. Implicit arguments can still be "
"given explicitly in applications, using ``{a=value}`` and ``{n=value}``, "
"for example:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:517
msgid ""
"In fact, any argument, implicit or explicit, may be given a name. We "
"could have declared the type of ``index`` as:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:524
msgid ""
"It is a matter of taste whether you want to do this — sometimes it can "
"help document a function by making the purpose of an argument more clear."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:528
msgid ""
"The names of implicit arguments are in scope in the body of the function,"
" although they cannot be used at run time. There is much more to say "
"about implicit arguments - we will discuss the question of what is "
"available at run time, among other things, in Section :ref:`sect-"
"multiplicities`"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:534
msgid "Note: Declaration Order and ``mutual`` blocks"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:536
msgid ""
"In general, functions and data types must be defined before use, since "
"dependent types allow functions to appear as part of types, and type "
"checking can rely on how particular functions are defined (though this is"
" only true of total functions; see Section :ref:`sect-totality`). "
"However, this restriction can be relaxed by using a ``mutual`` block, "
"which allows data types and functions to be defined simultaneously:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:554
msgid ""
"In a ``mutual`` block, first all of the type declarations are added, then"
" the function bodies. As a result, none of the function types can depend "
"on the reduction behaviour of any of the functions in the block."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:559
msgid ""
"Forward declarations can allow you to have more fine-grained control over"
" the order in which mutually defined concepts are declared. This can be "
"useful if you need to mention a datatype's constructor in the type of a "
"mutually defined function, or need to rely on the behaviour of a mutually"
" defined function for something to typecheck."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:602
msgid ""
"Placing signature declarations forward can suggest Idris to detect their "
"corresponding mutual definitions."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:606
msgid "I/O"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:608
msgid ""
"Computer programs are of little use if they do not interact with the user"
" or the system in some way. The difficulty in a pure language such as "
"Idris — that is, a language where expressions do not have side-effects — "
"is that I/O is inherently side-effecting. So, Idris provides a "
"parameterised type ``IO`` which *describes* the interactions that the "
"run-time system will perform when executing a function:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:619
msgid ""
"We’ll leave the definition of ``IO`` abstract, but effectively it "
"describes what the I/O operations to be executed are, rather than how to "
"execute them. The resulting operations are executed externally, by the "
"run-time system. We’ve already seen one I/O program:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:629
msgid ""
"The type of ``putStrLn`` explains that it takes a string, and returns an "
"I/O action which produces an element of the unit type ``()``. There is a "
"variant ``putStr`` which decribes the output of a string without a "
"newline:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:638
msgid "We can also read strings from user input:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:644
msgid ""
"A number of other I/O operations are available. For example, by adding "
"``import System.File`` to your program, you get access to functions for "
"reading and writing files, including:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:660
msgid "Note that several of these return ``Either``, since they may fail."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:665
msgid "“``do``” notation"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:667
msgid ""
"I/O programs will typically need to sequence actions, feeding the output "
"of one computation into the input of the next. ``IO`` is an abstract "
"type, however, so we can’t access the result of a computation directly. "
"Instead, we sequence operations with ``do`` notation:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:679
msgid ""
"The syntax ``x <- iovalue`` executes the I/O operation ``iovalue``, of "
"type ``IO a``, and puts the result, of type ``a`` into the variable "
"``x``. In this case, ``getLine`` returns an ``IO String``, so ``name`` "
"has type ``String``. Indentation is significant — each statement in the "
"do block must begin in the same column. The ``pure`` operation allows us "
"to inject a value directly into an IO operation:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:690
msgid ""
"As we will see later, ``do`` notation is more general than this, and can "
"be overloaded."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:693
msgid ""
"You can try executing ``greet`` at the Idris 2 REPL by running the "
"command ``:exec greet``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:704
msgid "Laziness"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:706
msgid ""
"Normally, arguments to functions are evaluated before the function itself"
" (that is, Idris uses *eager* evaluation). However, this is not always "
"the best approach. Consider the following function:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:716
msgid ""
"This function uses one of the ``t`` or ``e`` arguments, but not both. We "
"would prefer if *only* the argument which was used was evaluated. To "
"achieve this, Idris provides a ``Lazy`` primitive, which allows "
"evaluation to be suspended. It is a primitive, but conceptually we can "
"think of it as follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:728
msgid ""
"A value of type ``Lazy a`` is unevaluated until it is forced by "
"``Force``. The Idris type checker knows about the ``Lazy`` type, and "
"inserts conversions where necessary between ``Lazy a`` and ``a``, and "
"vice versa. We can therefore write ``ifThenElse`` as follows, without any"
" explicit use of ``Force`` or ``Delay``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:741
msgid "Infinite data Types"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:743
msgid ""
"Infinite data types (codata) allow us to define infinite data structures "
"by marking recursive arguments as potentially infinite. One example of an"
" infinite type is Stream, which is defined as follows."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:752
msgid ""
"The following is an example of how the codata type ``Stream`` can be used"
" to form an infinite data structure. In this case we are creating an "
"infinite stream of ones."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:762
msgid "Useful Data Types"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:764
msgid ""
"Idris includes a number of useful data types and library functions (see "
"the ``libs/`` directory in the distribution, and the `documentation "
"<https://www.idris-lang.org/pages/documentation.html>`_). This section "
"describes a few of these, and how to import them."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:770
msgid "``List`` and ``Vect``"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:772
msgid "We have already seen the ``List`` and ``Vect`` data types:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:782
msgid ""
"You can get access to ``Vect`` with ``import Data.Vect``. Note that the "
"constructor names are the same for each — constructor names (in fact, "
"names in general) can be overloaded, provided that they are declared in "
"different namespaces (see Section :ref:`sect-namespaces`), and will "
"typically be resolved according to their type. As syntactic sugar, any "
"implementation of the names ``Nil`` and ``::`` can be written in list "
"form. For example:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:790
msgid "``[]`` means ``Nil``"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:792
msgid "``[1,2,3]`` means ``1 :: 2 :: 3 :: Nil``"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:794
msgid ""
"Similarly, any implementation of the names ``Lin`` and ``:<`` can be "
"written in **snoc**-list form:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:797
msgid "``[<]`` mean ``Lin``"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:798
msgid "``[< 1, 2, 3]`` means ``Lin :< 1 :< 2 :< 3``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:800
msgid "and the prelude includes a pre-defined datatype for snoc-lists:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:807
msgid ""
"The library also defines a number of functions for manipulating these "
"types. ``map`` is overloaded both for ``List`` and ``Vect`` (we'll see "
"more details of precisely how later when we cover interfaces in Section "
":ref:`sect-interfaces`) and applies a function to every element of the "
"list or vector."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:823
msgid ""
"For example, given the following vector of integers, and a function to "
"double an integer:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:834
msgid ""
"the function ``map`` can be used as follows to double every element in "
"the vector:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:842
msgid ""
"For more details of the functions available on ``List`` and ``Vect``, "
"look in the library files:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:845
msgid "``libs/base/Data/List.idr``"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:847
msgid "``libs/base/Data/Vect.idr``"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:849
msgid "Functions include filtering, appending, reversing, and so on."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:852
msgid "Aside: Anonymous functions and operator sections"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:854
msgid ""
"There are neater ways to write the above expression. One way would be to "
"use an anonymous function:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:862
msgid ""
"The notation ``\\x => val`` constructs an anonymous function which takes "
"one argument, ``x`` and returns the expression ``val``. Anonymous "
"functions may take several arguments, separated by commas, e.g. ``\\x, y,"
" z => val``. Arguments may also be given explicit types, e.g. ``\\x : Int"
" => x * 2``, and can pattern match, e.g. ``\\(x, y) => x + y``. We could "
"also use an operator section:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:874
msgid ""
"``(*2)`` is shorthand for a function which multiplies a number by 2. It "
"expands to ``\\x => x * 2``. Similarly, ``(2*)`` would expand to ``\\x =>"
" 2 * x``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:879
msgid "Maybe"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:881
msgid ""
"``Maybe``, defined in the Prelude, describes an optional value. Either "
"there is a value of the given type, or there isn’t:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:888
msgid ""
"``Maybe`` is one way of giving a type to an operation that may fail. For "
"example, looking something up in a ``List`` (rather than a vector) may "
"result in an out of bounds error:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:899
msgid ""
"The ``maybe`` function is used to process values of type ``Maybe``, "
"either by applying a function to the value, if there is one, or by "
"providing a default value:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:907
msgid ""
"Note that the types of the first two arguments are wrapped in ``Lazy``. "
"Since only one of the two arguments will actually be used, we mark them "
"as ``Lazy`` in case they are large expressions where it would be wasteful"
" to compute and then discard them."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:913
msgid "Tuples"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:915
msgid "Values can be paired with the following built-in data type:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:921
msgid ""
"As syntactic sugar, we can write ``(a, b)`` which, according to context, "
"means either ``Pair a b`` or ``MkPair a b``. Tuples can contain an "
"arbitrary number of values, represented as nested pairs:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:943
msgid "Dependent Pairs"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:945
msgid ""
"Dependent pairs allow the type of the second element of a pair to depend "
"on the value of the first element:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:953
msgid ""
"Again, there is syntactic sugar for this. ``(x : a ** p)`` is the type of"
" a pair of A and P, where the name ``x`` can occur inside ``p``. ``( x **"
" p )`` constructs a value of this type. For example, we can pair a number"
" with a ``Vect`` of a particular length:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:963
msgid "If you like, you can write it out the long way; the two are equivalent:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:970
msgid ""
"The type checker could infer the value of the first element from the "
"length of the vector. We can write an underscore ``_`` in place of values"
" which we expect the type checker to fill in, so the above definition "
"could also be written as:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:980
msgid ""
"We might also prefer to omit the type of the first element of the pair, "
"since, again, it can be inferred:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:988
msgid ""
"One use for dependent pairs is to return values of dependent types where "
"the index is not necessarily known in advance. For example, if we filter "
"elements out of a ``Vect`` according to some predicate, we will not know "
"in advance what the length of the resulting vector will be:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:998
msgid "If the ``Vect`` is empty, the result is:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1004
msgid ""
"In the ``::`` case, we need to inspect the result of a recursive call to "
"``filter`` to extract the length and the vector from the result. To do "
"this, we use a ``case`` expression, which allows pattern matching on "
"intermediate values:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1018
msgid "Dependent pairs are sometimes referred to as “Sigma types”."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1021
msgid "Records"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1023
msgid ""
"*Records* are data types which collect several values (the record's "
"*fields*) together. Idris provides syntax for defining records and "
"automatically generating field access and update functions. Unlike the "
"syntax used for data structures, records in Idris follow a different "
"syntax to that seen with Haskell. For example, we can represent a "
"person’s name and age in a record:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1039
msgid ""
"The constructor name is provided using the ``constructor`` keyword, and "
"the *fields* are then given which are in an indented block following the "
"`where` keyword (here, ``firstName``, ``middleName``, ``lastName``, and "
"``age``). You can declare multiple fields on a single line, provided that"
" they have the same type. The field names can be used to access the field"
" values:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1054
msgid "We can use prefix field projections, like in Haskell:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1065
msgid ""
"Prefix field projections can be disabled per record definition using "
"pragma ``%prefix_record_projections off``, which makes all subsequently "
"defined records generate only dotted projections. This pragma has effect "
"until the end of the module or until the closest occurrence of "
"``%prefix_record_projections on``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1071
msgid ""
"We can also use the field names to update a record (or, more precisely, "
"produce a copy of the record with the given fields updated):"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1082
msgid ""
"The syntax ``{ field := val, ... }`` generates a function which updates "
"the given fields in a record. ``:=`` assigns a new value to a field, and "
"``$=`` applies a function to update its value."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1086
msgid ""
"Each record is defined in its own namespace, which means that field names"
" can be reused in multiple records."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1089
msgid ""
"Records, and fields within records, can have dependent types. Updates are"
" allowed to change the type of a field, provided that the result is well-"
"typed."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1100
msgid ""
"It is safe to update the ``students`` field to a vector of a different "
"length because it will not affect the type of the record:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1113
msgid "We could also use ``$=`` to define ``addStudent`` more concisely:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1121
msgid "Nested record projection"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1123
msgid "Nested record fields can be accessed using the dot notation:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1130
msgid ""
"For the dot notation, there must be no spaces after the dots but there "
"may be spaces before the dots. The composite projection must be "
"parenthesised, otherwise ``map .a.b.c xs`` would be understood as "
"``map.a.b.c xs``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1134
msgid "Nested record fields can be accessed using the prefix notation, too:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1141
msgid "Dots with spaces around them stand for function composition operators."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1144
msgid "Nested record update"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1146
msgid ""
"Idris also provides a convenient syntax for accessing and updating nested"
" records. For example, if a field is accessible with the expression "
"``x.a.b.c``, it can be updated using the following syntax:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1155
msgid ""
"This returns a new record, with the field accessed by the path ``a.b.c`` "
"set to ``val``. The syntax is first class, i.e. ``{ a.b.c := val }`` "
"itself has a function type."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1159
msgid "The ``$=`` notation is also valid for nested record updates."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1162
msgid "Dependent Records"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1164
msgid ""
"Records can also be dependent on values. Records have *parameters*, which"
" cannot be updated like the other fields. The parameters appear as "
"arguments to the resulting type, and are written following the record "
"type name. For example, a pair type could be defined as follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1176
msgid ""
"Using the ``Class`` record from earlier, the size of the class can be "
"restricted using a ``Vect`` and the size included in the type by "
"parameterising the record with the size.  For example:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1187
msgid ""
"In the case of ``addStudent`` earlier, we can still add a student to a "
"``SizedClass`` since the size is implicit, and will be updated when a "
"student is added:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1196
msgid ""
"In fact, the dependent pair type we have just seen is, in practice, "
"defined as a record, with fields ``fst`` and ``snd`` which allow "
"projecting values out of the pair:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1207
msgid ""
"It is possible to use record update syntax to update dependent fields, "
"provided that all related fields are updated at once. For example:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1217
msgid "Or even:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1230
msgid "More Expressions"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1235
msgid "``let`` bindings"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1237
msgid "Intermediate values can be calculated using ``let`` bindings:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1245
msgid ""
"We can do pattern matching in ``let`` bindings too. For example, we can "
"extract fields from a record as follows, as well as by pattern matching "
"at the top level:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1257
msgid "These let bindings can be annotated with a type:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1265
msgid ""
"We can also use the symbol ``:=`` instead of ``=`` to, among other "
"things, avoid ambiguities with propositional equality:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1273
msgid ""
"Local definitions can also be introduced using ``let``. Just like top "
"level ones and ones defined in a ``where`` clause you need to:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1276
msgid "declare the function and its type"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1277
msgid "define the function by pattern matching"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1286
msgid ""
"The symbol ``:=`` cannot be used in a local function definition. Which "
"means that it can be used to interleave let bindings and local "
"definitions without introducing ambiguities."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1301
msgid "List comprehensions"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1303
msgid ""
"Idris provides *comprehension* notation as a convenient shorthand for "
"building lists. The general form is:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1310
msgid ""
"This generates the list of values produced by evaluating the "
"``expression``, according to the conditions given by the comma separated "
"``qualifiers``. For example, we can build a list of Pythagorean triples "
"as follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1321
msgid ""
"The ``[a..b]`` notation is another shorthand which builds a list of "
"numbers between ``a`` and ``b``. Alternatively ``[a,b..c]`` builds a list"
" of numbers between ``a`` and ``c`` with the increment specified by the "
"difference between ``a`` and ``b``. This works for type ``Nat``, ``Int`` "
"and ``Integer``, using the ``enumFromTo`` and ``enumFromThenTo`` function"
" from the prelude."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1329
msgid "``case`` expressions"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1331
msgid ""
"Another way of inspecting intermediate values is to use a ``case`` "
"expression. The following function, for example, splits a string into two"
" at a given character:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1341
msgid ""
"``break`` is a library function which breaks a string into a pair of "
"strings at the point where the given function returns true. We then "
"deconstruct the pair it returns, and remove the first character of the "
"second string."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1346
msgid ""
"A ``case`` expression can match several cases, for example, to inspect an"
" intermediate value of type ``Maybe a``. Recall ``list_lookup`` which "
"looks up an index in a list, returning ``Nothing`` if the index is out of"
" bounds. We can use this to write ``lookup_default``, which looks up an "
"index and returns a default value if the index is out of bounds:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1360
msgid ""
"If the index is in bounds, we get the value at that index, otherwise we "
"get a default value:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1371
msgid "Totality"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1373
msgid ""
"Idris distinguishes between *total* and *partial* functions. A total "
"function is a function that either:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1376
msgid "Terminates for all possible inputs, or"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1377
msgid "Produces a non-empty, finite, prefix of a possibly infinite result"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1379
msgid ""
"If a function is total, we can consider its type a precise description of"
" what that function will do. For example, if we have a function with a "
"return type of ``String`` we know something different, depending on "
"whether or not it's total:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1384
msgid "If it's total, it will return a value of type ``String`` in finite time;"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1385
msgid ""
"If it's partial, then as long as it doesn't crash or enter an infinite "
"loop, it will return a ``String``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1388
msgid ""
"Idris makes this distinction so that it knows which functions are safe to"
" evaluate while type checking (as we've seen with :ref:`sect-fctypes`). "
"After all, if it tries to evaluate a function during type checking which "
"doesn't terminate, then type checking won't terminate! Therefore, only "
"total functions will be evaluated during type checking. Partial functions"
" can still be used in types, but will not be evaluated further."
msgstr ""

#: ../../source/tutorial/views.rst:5
msgid "Views and the “``with``” rule"
msgstr ""

#: ../../source/tutorial/views.rst:9
msgid "NOT UPDATED FOR IDRIS 2 YET"
msgstr ""

#: ../../source/tutorial/views.rst:12
msgid "Dependent pattern matching"
msgstr ""

#: ../../source/tutorial/views.rst:14
msgid ""
"Since types can depend on values, the form of some arguments can be "
"determined by the value of others. For example, if we were to write down "
"the implicit length arguments to ``(++)``, we’d see that the form of the "
"length argument was determined by whether the vector was empty or not:"
msgstr ""

#: ../../source/tutorial/views.rst:26
msgid ""
"If ``n`` was a successor in the ``[]`` case, or zero in the ``::`` case, "
"the definition would not be well typed."
msgstr ""

#: ../../source/tutorial/views.rst:32
msgid "The ``with`` rule — matching intermediate values"
msgstr ""

#: ../../source/tutorial/views.rst:34
msgid ""
"Very often, we need to match on the result of an intermediate "
"computation. Idris provides a construct for this, the ``with`` rule, "
"inspired by views in ``Epigram`` [#McBridgeMcKinna]_, which takes account"
" of the fact that matching on a value in a dependently typed language can"
" affect what we know about the forms of other values. In its simplest "
"form, the ``with`` rule adds another argument to the function being "
"defined."
msgstr ""

#: ../../source/tutorial/views.rst:42
msgid ""
"We have already seen a vector filter function. This time, we define it "
"using ``with`` as follows:"
msgstr ""

#: ../../source/tutorial/views.rst:52
msgid ""
"Here, the ``with`` clause allows us to deconstruct the result of ``filter"
" p xs``. The view refined argument pattern ``filter p (x :: xs)`` goes "
"beneath the ``with`` clause, followed by a vertical bar ``|``, followed "
"by the deconstructed intermediate result ``( _ ** xs' )``. If the view "
"refined argument pattern is unchanged from the original function argument"
" pattern, then the left side of ``|`` is extraneous and may be omitted "
"with an underscore ``_``:"
msgstr ""

#: ../../source/tutorial/views.rst:65
msgid "``with`` clauses can also be nested:"
msgstr ""

#: ../../source/tutorial/views.rst:76
msgid ""
"and left hand sides that are the same as their parent's can be skipped by"
" using ``_`` to focus on the patterns for the most local ``with``. "
"Meaning that the above ``foo`` can be rewritten as follows:"
msgstr ""

#: ../../source/tutorial/views.rst:89
msgid ""
"If the intermediate computation itself has a dependent type, then the "
"result can affect the forms of other arguments — we can learn the form of"
" one value by testing another. In these cases, view refined argument "
"patterns must be explicit. For example, a ``Nat`` is either even or odd. "
"If it is even it will be the sum of two equal ``Nat``. Otherwise, it is "
"the sum of two equal ``Nat`` plus one:"
msgstr ""

#: ../../source/tutorial/views.rst:102
msgid ""
"We say ``Parity`` is a *view* of ``Nat``. It has a *covering function* "
"which tests whether it is even or odd and constructs the predicate "
"accordingly. Note that we're going to need access to ``n`` at run time, "
"so although it's an implicit argument, it has unrestricted multiplicity."
msgstr ""

#: ../../source/tutorial/views.rst:111
msgid ""
"We’ll come back to the definition of ``parity`` shortly. We can use it to"
" write a function which converts a natural number to a list of binary "
"digits (least significant first) as follows, using the ``with`` rule:"
msgstr ""

#: ../../source/tutorial/views.rst:124
msgid ""
"The value of ``parity k`` affects the form of ``k``, because the result "
"of ``parity k`` depends on ``k``. So, as well as the patterns for the "
"result of the intermediate computation (``Even`` and ``Odd``) right of "
"the ``|``, we also write how the results affect the other patterns left "
"of the ``|``. That is:"
msgstr ""

#: ../../source/tutorial/views.rst:130
msgid ""
"When ``parity k`` evaluates to ``Even``, we can refine the original "
"argument ``k`` to a refined pattern ``(j + j)`` according to ``Parity (n "
"+ n)`` from the ``Even`` constructor definition. So ``(j + j)`` replaces "
"``k`` on the left side of ``|``, and the ``Even`` constructor appears on "
"the right side. The natural number ``j`` in the refined pattern can be "
"used on the right side of the ``=`` sign."
msgstr ""

#: ../../source/tutorial/views.rst:138
msgid ""
"Otherwise, when ``parity k`` evaluates to ``Odd``, the original argument "
"``k`` is refined to ``S (j + j)`` according to ``Parity (S (n + n))`` "
"from the ``Odd`` constructor definition, and ``Odd`` now appears on the "
"right side of ``|``, again with the natural number ``j`` used on the "
"right side of the ``=`` sign."
msgstr ""

#: ../../source/tutorial/views.rst:144
msgid ""
"Note that there is a function in the patterns (``+``) and repeated "
"occurrences of ``j`` - this is allowed because another argument has "
"determined the form of these patterns."
msgstr ""

#: ../../source/tutorial/views.rst:149
msgid "Defining ``parity``"
msgstr ""

#: ../../source/tutorial/views.rst:151
msgid ""
"The definition of ``parity`` is a little tricky, and requires some "
"knowledge of theorem proving (see Section :ref:`sect-theorems`), but for "
"completeness, here it is:"
msgstr ""

#: ../../source/tutorial/views.rst:166
msgid ""
"For full details on ``rewrite`` in particular, please refer to the "
"theorem proving tutorial, in Section :ref:`proofs-index`."
msgstr ""

#: ../../source/tutorial/views.rst:169
msgid ""
"Conor McBride and James McKinna. 2004. The view from the left. J. Funct. "
"Program. 14, 1 (January 2004), 69-111. "
"https://doi.org/10.1017/S0956796803004829"
msgstr ""

#: ../../source/tutorial/windows.rst:4
msgid "Prerequisites for Windows"
msgstr ""

#: ../../source/tutorial/windows.rst:7
msgid "MSYS2"
msgstr ""

#: ../../source/tutorial/windows.rst:9
msgid ""
"To build Idris 2 on Windows, an Unix-like environment is needed for all "
"the utilities used during the build. `MSYS2 <https://www.msys2.org>`_ "
"provides that for us."
msgstr ""

#: ../../source/tutorial/windows.rst:12
msgid "Download the latest version of MSYS2"
msgstr ""

#: ../../source/tutorial/windows.rst:13
msgid ""
"Run the installer. Don't install it under Program files as it needs to "
"write files (the \"unix\" home directory lies under there, for example)"
msgstr ""

#: ../../source/tutorial/windows.rst:16
msgid ""
"In the directory where you installed MSYS2, find the file ``mingw64.ini``"
" and add the line ``MSYS2_PATH_TYPE=inherit``. This adds the normal "
"windows PATH to the shell in MSYS2."
msgstr ""

#: ../../source/tutorial/windows.rst:19
msgid ""
"Start MSYS2 (click on mingw64.exe, as the icon in the start menu won't "
"pick up the MSYS2_PATH_TYPE from the ini, it can be added to the system "
"settings)"
msgstr ""

#: ../../source/tutorial/windows.rst:22
msgid "Update the installation with the latest releases with ``pacman -Syu``"
msgstr ""

#: ../../source/tutorial/windows.rst:24
msgid "Install the programs that the build needs with::"
msgstr ""

#: ../../source/tutorial/windows.rst:30
msgid "Chez Scheme"
msgstr ""

#: ../../source/tutorial/windows.rst:32
msgid ""
"Chez Scheme has a ready-made installer at `GitHub "
"<https://github.com/cisco/ChezScheme/releases>`_"
msgstr ""

#: ../../source/tutorial/windows.rst:34
msgid ""
"Download the installer and run it, do not install it in a path with "
"spaces, currently Idris2 has trouble with them."
msgstr ""

#: ../../source/tutorial/windows.rst:36
msgid ""
"Add the threaded 64-bit scheme to the PATH. It is the ``\\bin\\ta6nt`` "
"subdirectory to where Chez Scheme was installed. So if you used "
"\"C:\\Chez\" it will be in ``C:\\Chez\\bin\\ta6nt``"
msgstr ""

#: ../../source/tutorial/windows.rst:41
msgid "Building"
msgstr ""

#: ../../source/tutorial/windows.rst:43
msgid ""
"Start a fresh MSYS2 shell so that it knows about your modified PATH (it's"
" important to use Mingw64 to get access to the right compilers)."
msgstr ""

#: ../../source/tutorial/windows.rst:46
msgid "Navigate to the Idris2 directory."
msgstr ""

#: ../../source/tutorial/windows.rst:47
msgid ""
"Set the SCHEME environment variable that Idris2 needs ``export "
"SCHEME=scheme``. This can be set permanently in the bash profile file or "
"the Windows settings."
msgstr ""

#: ../../source/tutorial/windows.rst:50
msgid ""
"Now ``make bootstrap && make install`` should build Idris2 and install it"
" in ``home/<username>/.idris2/bin`` under your MSYS2 installation. If you"
" add that to the PATH in Windows settings it will be usable from any "
"command line (including Powershell or DOS), that you open."
msgstr ""

