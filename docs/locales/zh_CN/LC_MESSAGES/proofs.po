# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 09:08+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/proofs/definitional.rst:1
msgid ""
"Before we discuss the details of theorem proving in Idris, we will "
"describe some fundamental concepts:"
msgstr ""

#: ../../source/proofs/definitional.rst:4
msgid "Propositions and judgments"
msgstr ""

#: ../../source/proofs/definitional.rst:5
msgid "Boolean and constructive logic"
msgstr ""

#: ../../source/proofs/definitional.rst:6
#: ../../source/proofs/definitional.rst:57
msgid "Curry-Howard correspondence"
msgstr ""

#: ../../source/proofs/definitional.rst:7
msgid "Definitional and propositional equalities"
msgstr ""

#: ../../source/proofs/definitional.rst:8
msgid "Axiomatic and constructive approaches"
msgstr ""

#: ../../source/proofs/definitional.rst:11
msgid "Propositions and Judgments"
msgstr ""

#: ../../source/proofs/definitional.rst:13
msgid ""
"Propositions are the subject of our proofs. Before the proof, we can't "
"formally say if they are true or not. If the proof is successful then the"
" result is a 'judgment'.  For instance, if the ``proposition`` is,"
msgstr ""

#: ../../source/proofs/definitional.rst:18
msgid "1+1=2"
msgstr ""

#: ../../source/proofs/definitional.rst:21
msgid "When we prove it, the ``judgment`` is,"
msgstr ""

#: ../../source/proofs/definitional.rst:24
msgid "1+1=2 true"
msgstr ""

#: ../../source/proofs/definitional.rst:27
msgid "Or if the ``proposition`` is,"
msgstr ""

#: ../../source/proofs/definitional.rst:30
msgid "1+1=3"
msgstr ""

#: ../../source/proofs/definitional.rst:33
msgid ""
"we can't prove it is true, but it is still a valid proposition and "
"perhaps we can prove it is false so the ``judgment`` is,"
msgstr ""

#: ../../source/proofs/definitional.rst:37
msgid "1+1=3 false"
msgstr ""

#: ../../source/proofs/definitional.rst:40
msgid ""
"This may seem a bit pedantic but it is important to be careful: in "
"mathematics not every proposition is true or false. For instance, a "
"proposition may be unproven or even unprovable."
msgstr ""

#: ../../source/proofs/definitional.rst:44
msgid ""
"So the logic here is different from the logic that comes from boolean "
"algebra. In that case what is not true is false and what is not false is "
"true. The logic we are using here does not have this law, the \"Law of "
"Excluded Middle\", so we cannot use it."
msgstr ""

#: ../../source/proofs/definitional.rst:49
msgid ""
"A false proposition is taken to be a contradiction and if we have a "
"contradiction then we can prove anything, so we need to avoid this. Some "
"languages, used in proof assistants, prevent contradictions."
msgstr ""

#: ../../source/proofs/definitional.rst:53
msgid ""
"The logic we are using is called constructive (or sometimes intuitional) "
"because we are constructing a 'database' of judgments."
msgstr ""

#: ../../source/proofs/definitional.rst:59
msgid ""
"So how do we relate these proofs to Idris programs? It turns out that "
"there is a correspondence between constructive logic and type theory. "
"They have the same structure and we can switch back and forth between the"
" two notations."
msgstr ""

#: ../../source/proofs/definitional.rst:63
msgid "The way that this works is that a proposition is a type so..."
msgstr ""

#: ../../source/proofs/definitional.rst:73
msgid ""
"...is a proposition and it is also a type. The following will also "
"produce an equality type:"
msgstr ""

#: ../../source/proofs/definitional.rst:82
msgid ""
"Both of these are valid propositions so both are valid equality types. "
"But how do we represent a true judgment? That is, how do we denote 1+1=2 "
"is true but not 1+1=3?  A type that is true is inhabited, that is, it can"
" be constructed. An equality type has only one constructor 'Refl' so a "
"proof of 1+1=2 is"
msgstr ""

#: ../../source/proofs/definitional.rst:92
msgid ""
"Now that we can represent propositions as types other aspects of "
"propositional logic can also be translated to types as follows:"
msgstr ""

#: ../../source/proofs/definitional.rst:96
msgid "propositions"
msgstr ""

#: ../../source/proofs/definitional.rst:96
msgid "example of possible type"
msgstr ""

#: ../../source/proofs/definitional.rst:98
msgid "A"
msgstr ""

#: ../../source/proofs/definitional.rst:98
msgid "x=y"
msgstr ""

#: ../../source/proofs/definitional.rst:100
msgid "B"
msgstr ""

#: ../../source/proofs/definitional.rst:100
#: ../../source/proofs/definitional.rst:108
#: ../../source/proofs/definitional.rst:110
msgid "y=z"
msgstr ""

#: ../../source/proofs/definitional.rst:102
msgid "and"
msgstr ""

#: ../../source/proofs/definitional.rst:102
msgid "A /\\\\ B"
msgstr ""

#: ../../source/proofs/definitional.rst:102
msgid "Pair(x=y,y=z)"
msgstr ""

#: ../../source/proofs/definitional.rst:104
msgid "or"
msgstr ""

#: ../../source/proofs/definitional.rst:104
msgid "A \\\\/ B"
msgstr ""

#: ../../source/proofs/definitional.rst:104
msgid "Either(x=y,y=z)"
msgstr ""

#: ../../source/proofs/definitional.rst:106
msgid "implies"
msgstr ""

#: ../../source/proofs/definitional.rst:106
msgid "A -> B"
msgstr ""

#: ../../source/proofs/definitional.rst:106
msgid "(x=y) -> (y=z)"
msgstr ""

#: ../../source/proofs/definitional.rst:108
msgid "for all"
msgstr ""

#: ../../source/proofs/definitional.rst:110
msgid "exists"
msgstr ""

#: ../../source/proofs/definitional.rst:115
msgid "And (conjunction)"
msgstr ""

#: ../../source/proofs/definitional.rst:117
msgid "We can have a type which corresponds to conjunction:"
msgstr ""

#: ../../source/proofs/definitional.rst:123
msgid "There is a built in type called 'Pair'."
msgstr ""

#: ../../source/proofs/definitional.rst:126
msgid "Or (disjunction)"
msgstr ""

#: ../../source/proofs/definitional.rst:128
msgid "We can have a type which corresponds to disjunction:"
msgstr ""

#: ../../source/proofs/definitional.rst:136
msgid "There is a built in type called 'Either'."
msgstr ""

#: ../../source/proofs/definitional.rst:139
msgid "Definitional and Propositional Equalities"
msgstr ""

#: ../../source/proofs/definitional.rst:141
msgid ""
"We have seen that  we can 'prove' a type by finding a way to construct a "
"term. In the case of equality types there is only one constructor which "
"is ``Refl``. We have also seen that each side of the equation does not "
"have to be identical like '2=2'. It is enough that both sides are "
"*definitionally equal* like this:"
msgstr ""

#: ../../source/proofs/definitional.rst:151
msgid ""
"Both sides of this equation normalise to 2 and so Refl matches and the "
"proposition is proved."
msgstr ""

#: ../../source/proofs/definitional.rst:154
msgid ""
"We don't have to stick to terms; we can also use symbolic parameters so "
"the following type checks:"
msgstr ""

#: ../../source/proofs/definitional.rst:162
msgid ""
"If a proposition/equality type is not definitionally equal but is still "
"true then it is *propositionally equal*. In this case we may still be "
"able to prove it but some steps in the proof may require us to add "
"something into the terms or at least to take some sideways steps to get "
"to a proof."
msgstr ""

#: ../../source/proofs/definitional.rst:167
msgid ""
"Especially when working with equalities containing variable terms (inside"
" functions) it can be hard to know which equality types are "
"definitionally equal, in this example ``plusReducesL`` is *definitionally"
" equal* but ``plusReducesR`` is not (although it is *propositionally "
"equal*). The only difference between them is the order of the operands."
msgstr ""

#: ../../source/proofs/definitional.rst:181
msgid "Checking ``plusReducesR`` gives the following error:"
msgstr ""

#: ../../source/proofs/definitional.rst:192
msgid "So why is ``Refl`` able to prove some equality types but not others?"
msgstr ""

#: ../../source/proofs/definitional.rst:194
msgid ""
"The first answer is that ``plus`` is defined by recursion on its first "
"argument. So, when the first argument is ``Z``, it reduces, but not when "
"the second argument is ``Z``."
msgstr ""

#: ../../source/proofs/definitional.rst:198
msgid ""
"If an equality type can be proved/constructed by using ``Refl`` alone it "
"is known as a *definitional equality*. In order to be definitionally "
"equal both sides of the equation must normalise to the same value."
msgstr ""

#: ../../source/proofs/definitional.rst:202
msgid ""
"So when we type ``1+1`` in Idris it is immediately reduced to 2 because "
"definitional equality is built in"
msgstr ""

#: ../../source/proofs/definitional.rst:210
msgid "In the following pages we discuss how to resolve propositional equalities."
msgstr ""

#: ../../source/proofs/index.rst:5
msgid "Theorem Proving"
msgstr ""

#: ../../source/proofs/index.rst:7
msgid "A tutorial on theorem proving in Idris 2."
msgstr ""

#: ../../source/proofs/index.rst:11
msgid ""
"The documentation for Idris has been published under the Creative Commons"
" CC0 License. As such to the extent possible under law, *The Idris "
"Community* has waived all copyright and related or neighboring rights to "
"Documentation for Idris."
msgstr ""

#: ../../source/proofs/index.rst:16
msgid ""
"More information concerning the CC0 can be found online at: "
"http://creativecommons.org/publicdomain/zero/1.0/"
msgstr ""

#: ../../source/proofs/inductive.rst:5
msgid "Inductive Proofs"
msgstr ""

#: ../../source/proofs/inductive.rst:7
msgid ""
"Before embarking on proving ``plus_commutes`` in Idris itself, let us "
"consider the overall structure of a proof of some property of natural "
"numbers. Recall that they are defined recursively, as follows:"
msgstr ""

#: ../../source/proofs/inductive.rst:17
msgid ""
"A *total* function over natural numbers must both terminate, and cover "
"all possible inputs. Idris checks functions for totality by checking that"
" all inputs are covered, and that all recursive calls are on "
"*structurally smaller* values (so recursion will always reach a base "
"case). Recalling ``plus``:"
msgstr ""

#: ../../source/proofs/inductive.rst:29
msgid ""
"This is total because it covers all possible inputs (the first argument "
"can only be ``Z`` or ``S k`` for some ``k``, and the second argument "
"``m`` covers all possible ``Nat``) and in the recursive call, ``k`` is "
"structurally smaller than ``S k`` so the first argument will always reach"
" the base case ``Z`` in any sequence of recursive calls."
msgstr ""

#: ../../source/proofs/inductive.rst:35
msgid ""
"In some sense, this resembles a mathematical proof by induction (and this"
" is no coincidence!). For some property ``P`` of a natural number ``x``, "
"we can show that ``P`` holds for all ``x`` if:"
msgstr ""

#: ../../source/proofs/inductive.rst:39
msgid "``P`` holds for zero (the base case)."
msgstr ""

#: ../../source/proofs/inductive.rst:41
msgid ""
"Assuming that ``P`` holds for ``k``, we can show ``P`` also holds for ``S"
" k`` (the inductive step)."
msgstr ""

#: ../../source/proofs/inductive.rst:44
msgid ""
"In ``plus``, the property we are trying to show is somewhat trivial (for "
"all natural numbers ``x``, there is a ``Nat`` which need not have any "
"relation to ``x``). However, it still takes the form of a base case and "
"an inductive step. In the base case, we show that there is a ``Nat`` "
"arising from ``plus n m`` when ``n = Z``, and in the inductive step we "
"show that there is a ``Nat`` arising when ``n = S k`` and we know we can "
"get a ``Nat`` inductively from ``plus k m``. We could even write a "
"function capturing all such inductive definitions:"
msgstr ""

#: ../../source/proofs/inductive.rst:64
msgid ""
"Using ``nat_induction``, we can implement an equivalent inductive version"
" of ``plus``:"
msgstr ""

#: ../../source/proofs/inductive.rst:77
msgid ""
"To prove that ``plus n m = plus m n`` for all natural numbers ``n`` and "
"``m``, we can also use induction. Either we can fix ``m`` and perform "
"induction on ``n``, or vice versa. We can sketch an outline of a proof; "
"performing induction on ``n``, we have:"
msgstr ""

#: ../../source/proofs/inductive.rst:82
msgid "Property ``prop`` is ``\\x => plus x m = plus m x``."
msgstr ""

#: ../../source/proofs/inductive.rst:84
msgid "Show that ``prop`` holds in the base case and inductive step:"
msgstr ""

#: ../../source/proofs/inductive.rst
msgid "Base case: ``prop Z``, i.e."
msgstr ""

#: ../../source/proofs/inductive.rst
msgid "``plus Z m = plus m Z``, which reduces to"
msgstr ""

#: ../../source/proofs/inductive.rst
msgid "``m = plus m Z`` due to the definition of ``plus``."
msgstr ""

#: ../../source/proofs/inductive.rst
msgid ""
"Inductive step: Inductively, we know that ``prop k`` holds for a "
"specific, fixed ``k``, i.e."
msgstr ""

#: ../../source/proofs/inductive.rst
msgid ""
"``plus k m = plus m k`` (the induction hypothesis). Given this, show "
"``prop (S k)``, i.e."
msgstr ""

#: ../../source/proofs/inductive.rst
msgid "``plus (S k) m = plus m (S k)``, which reduces to"
msgstr ""

#: ../../source/proofs/inductive.rst
msgid ""
"``S (plus k m) = plus m (S k)``. From the induction hypothesis, we can "
"rewrite this to"
msgstr ""

#: ../../source/proofs/inductive.rst
msgid "``S (plus m k) = plus m (S k)``."
msgstr ""

#: ../../source/proofs/inductive.rst:96
msgid ""
"To complete the proof we therefore need to show that ``m = plus m Z`` for"
" all natural numbers ``m``, and that ``S (plus m k) = plus m (S k)`` for "
"all natural numbers ``m`` and ``k``. Each of these can also be proved by "
"induction, this time on ``m``."
msgstr ""

#: ../../source/proofs/inductive.rst:101
msgid ""
"We are now ready to embark on a proof of commutativity of ``plus`` "
"formally in Idris."
msgstr ""

#: ../../source/proofs/patterns.rst:3
msgid "Pattern Matching Proofs"
msgstr ""

#: ../../source/proofs/patterns.rst:5
msgid ""
"In this section, we will provide a proof of ``plus_commutes`` directly, "
"by writing a pattern matching definition. We will use interactive editing"
" features extensively, since it is significantly easier to produce a "
"proof when the machine can give the types of intermediate values and "
"construct components of the proof itself. The commands we will use are "
"summarised below. Where we refer to commands directly, we will use the "
"Vim version, but these commands have a direct mapping to Emacs commands."
msgstr ""

#: ../../source/proofs/patterns.rst:15
msgid "Command"
msgstr ""

#: ../../source/proofs/patterns.rst:15
msgid "Vim binding"
msgstr ""

#: ../../source/proofs/patterns.rst:15
msgid "Emacs binding"
msgstr ""

#: ../../source/proofs/patterns.rst:15
msgid "Explanation"
msgstr ""

#: ../../source/proofs/patterns.rst:17
msgid "Check type"
msgstr ""

#: ../../source/proofs/patterns.rst:17
msgid "``\\t``"
msgstr ""

#: ../../source/proofs/patterns.rst:17
msgid "``C-c C-t``"
msgstr ""

#: ../../source/proofs/patterns.rst:17
msgid "Show type of identifier or hole under the cursor."
msgstr ""

#: ../../source/proofs/patterns.rst:19
msgid "Proof search"
msgstr ""

#: ../../source/proofs/patterns.rst:19
msgid "``\\s``"
msgstr ""

#: ../../source/proofs/patterns.rst:19
msgid "``C-c C-a``"
msgstr ""

#: ../../source/proofs/patterns.rst:19
msgid "Attempt to solve hole under the cursor by applying simple proof search."
msgstr ""

#: ../../source/proofs/patterns.rst:21
msgid "Make new definition"
msgstr ""

#: ../../source/proofs/patterns.rst:21
msgid "``\\a``"
msgstr ""

#: ../../source/proofs/patterns.rst:21
msgid "``C-c C-s``"
msgstr ""

#: ../../source/proofs/patterns.rst:21
msgid "Add a template definition for the type defined under the cursor."
msgstr ""

#: ../../source/proofs/patterns.rst:23
msgid "Make lemma"
msgstr ""

#: ../../source/proofs/patterns.rst:23
msgid "``\\l``"
msgstr ""

#: ../../source/proofs/patterns.rst:23
msgid "``C-c C-e``"
msgstr ""

#: ../../source/proofs/patterns.rst:23
msgid ""
"Add a top level function with a type which solves the hole under the "
"cursor."
msgstr ""

#: ../../source/proofs/patterns.rst:25
msgid "Split cases"
msgstr ""

#: ../../source/proofs/patterns.rst:25
msgid "``\\c``"
msgstr ""

#: ../../source/proofs/patterns.rst:25
msgid "``C-c C-c``"
msgstr ""

#: ../../source/proofs/patterns.rst:25
msgid ""
"Create new constructor patterns for each possible case of the variable "
"under the cursor."
msgstr ""

#: ../../source/proofs/patterns.rst:30
msgid "Creating a Definition"
msgstr ""

#: ../../source/proofs/patterns.rst:32
msgid ""
"To begin, create a file ``pluscomm.idr`` containing the following type "
"declaration:"
msgstr ""

#: ../../source/proofs/patterns.rst:39
msgid ""
"To create a template definition for the proof, press ``\\a`` (or the "
"equivalent in your editor of choice) on the line with the type "
"declaration. You should see:"
msgstr ""

#: ../../source/proofs/patterns.rst:48
msgid ""
"To prove this by induction on ``n``, as we sketched in Section :ref"
":`sect-inductive`, we begin with a case split on ``n`` (press ``\\c`` "
"with the cursor over the ``n`` in the definition.) You should see:"
msgstr ""

#: ../../source/proofs/patterns.rst:59
msgid ""
"If we inspect the types of the newly created holes, "
"``plus_commutes_rhs_1`` and ``plus_commutes_rhs_2``, we see that the type"
" of each reflects that ``n`` has been refined to ``Z`` and ``S k`` in "
"each respective case. Pressing ``\\t`` over ``plus_commutes_rhs_1`` "
"shows:"
msgstr ""

#: ../../source/proofs/patterns.rst:71
msgid "Similarly, for ``plus_commutes_rhs_2``:"
msgstr ""

#: ../../source/proofs/patterns.rst:80
msgid "It is a good idea to give these slightly more meaningful names:"
msgstr ""

#: ../../source/proofs/patterns.rst:89
msgid "Base Case"
msgstr ""

#: ../../source/proofs/patterns.rst:91
msgid ""
"We can create a separate lemma for the base case interactively, by "
"pressing ``\\l`` with the cursor over ``plus_commutes_Z``. This yields:"
msgstr ""

#: ../../source/proofs/patterns.rst:103
msgid ""
"That is, the hole has been filled with a call to a top level function "
"``plus_commutes_Z``, applied to the variable in scope ``m``."
msgstr ""

#: ../../source/proofs/patterns.rst:106
msgid ""
"Unfortunately, we cannot prove this lemma directly, since ``plus`` is "
"defined by matching on its *first* argument, and here ``plus m Z`` has a "
"concrete value for its *second argument* (in fact, the left hand side of "
"the equality has been reduced from ``plus Z m``.) Again, we can prove "
"this by induction, this time on ``m``."
msgstr ""

#: ../../source/proofs/patterns.rst:112
msgid "First, create a template definition with ``\\d``:"
msgstr ""

#: ../../source/proofs/patterns.rst:119
msgid "Now, case split on ``m`` with ``\\c``:"
msgstr ""

#: ../../source/proofs/patterns.rst:127
msgid ""
"Checking the type of ``plus_commutes_Z_rhs_1`` shows the following, which"
" is provable by ``Refl``:"
msgstr ""

#: ../../source/proofs/patterns.rst:135
msgid ""
"For such immediate proofs, we can let write the proof automatically by "
"pressing ``\\s`` with the cursor over ``plus_commutes_Z_rhs_1``. This "
"yields:"
msgstr ""

#: ../../source/proofs/patterns.rst:145
msgid "For ``plus_commutes_Z_rhs_2``, we are not so lucky:"
msgstr ""

#: ../../source/proofs/patterns.rst:153
msgid ""
"Inductively, we should know that ``k = plus k Z``, and we can get access "
"to this inductive hypothesis by making a recursive call on k, as follows:"
msgstr ""

#: ../../source/proofs/patterns.rst:165
msgid "For ``plus_commutes_Z_rhs_2``, we now see:"
msgstr ""

#: ../../source/proofs/patterns.rst:174
msgid ""
"So we know that ``k = plus k Z``, but how do we use this to update the "
"goal to ``S k = S k``?"
msgstr ""

#: ../../source/proofs/patterns.rst:177
msgid ""
"To achieve this, Idris provides a ``replace`` function as part of the "
"prelude:"
msgstr ""

#: ../../source/proofs/patterns.rst:185
msgid ""
"Given a proof that ``x = y``, and a property ``p`` which holds for ``x``,"
" we can get a proof of the same property for ``y``, because we know ``x``"
" and ``y`` must be the same. Note the multiplicity on ``rule`` means that"
" it's guaranteed to be erased at run time. In practice, this function can"
" be a little tricky to use because in general the implicit argument ``p``"
" can be hard to infer by unification, so Idris provides a high level "
"syntax which calculates the property and applies ``replace``:"
msgstr ""

#: ../../source/proofs/patterns.rst:198
msgid ""
"If we have ``prf : x = y``, and the required type for ``expr`` is some "
"property of ``x``, the ``rewrite ... in`` syntax will search for all "
"occurrences of ``x`` in the required type of ``expr`` and replace them "
"with ``y``. We want to replace ``plus k Z`` with ``k``, so we need to "
"apply our rule ``rec`` in reverse, which we can do using ``sym`` from the"
" Prelude"
msgstr ""

#: ../../source/proofs/patterns.rst:210
msgid "Concretely, in our example, we can say:"
msgstr ""

#: ../../source/proofs/patterns.rst:218
msgid "Checking the type of ``plus_commutes_Z_rhs_2`` now gives:"
msgstr ""

#: ../../source/proofs/patterns.rst:227
msgid ""
"Using the rewrite rule ``rec``, the goal type has been updated with "
"``plus k Z`` replaced by ``k``."
msgstr ""

#: ../../source/proofs/patterns.rst:230
msgid "We can use proof search (``\\s``) to complete the proof, giving:"
msgstr ""

#: ../../source/proofs/patterns.rst:240
msgid "The base case of ``plus_commutes`` is now complete."
msgstr ""

#: ../../source/proofs/patterns.rst:243
msgid "Inductive Step"
msgstr ""

#: ../../source/proofs/patterns.rst:245
msgid ""
"Our main theorem, ``plus_commutes`` should currently be in the following "
"state:"
msgstr ""

#: ../../source/proofs/patterns.rst:254
msgid "Looking again at the type of ``plus_commutes_S``, we have:"
msgstr ""

#: ../../source/proofs/patterns.rst:263
msgid ""
"Conveniently, by induction we can immediately tell that ``plus k m = plus"
" m k``, so let us rewrite directly by making a recursive call to "
"``plus_commutes``. We add this directly, by hand, as follows:"
msgstr ""

#: ../../source/proofs/patterns.rst:274
msgid "Checking the type of ``plus_commutes_S`` now gives:"
msgstr ""

#: ../../source/proofs/patterns.rst:283
msgid ""
"The good news is that ``m`` and ``k`` now appear in the correct order. "
"However, we still have to show that the successor symbol ``S`` can be "
"moved to the front in the right hand side of this equality. This "
"remaining lemma takes a similar form to the ``plus_commutes_Z``; we begin"
" by making a new top level lemma with ``\\l``. This gives:"
msgstr ""

#: ../../source/proofs/patterns.rst:293
msgid "Again, we make a template definition with ``\\a``:"
msgstr ""

#: ../../source/proofs/patterns.rst:300
msgid ""
"Like ``plus_commutes_Z``, we can define this by induction over ``m``, "
"since ``plus`` is defined by matching on its first argument. The complete"
" definition is:"
msgstr ""

#: ../../source/proofs/patterns.rst:311
msgid "All holes have now been solved."
msgstr ""

#: ../../source/proofs/patterns.rst:313
msgid ""
"The ``total`` annotation means that we require the final function to pass"
" the totality checker; i.e. it will terminate on all possible well-typed "
"inputs. This is important for proofs, since it provides a guarantee that "
"the proof is valid in *all* cases, not just those for which it happens to"
" be well-defined."
msgstr ""

#: ../../source/proofs/patterns.rst:319
msgid ""
"Now that ``plus_commutes`` has a ``total`` annotation, we have completed "
"the proof of commutativity of addition on natural numbers."
msgstr ""

#: ../../source/proofs/pluscomm.rst:3
msgid "Running example: Addition of Natural Numbers"
msgstr ""

#: ../../source/proofs/pluscomm.rst:5
msgid ""
"Throughout this tutorial, we will be working with the following function,"
" defined in the Idris prelude, which defines addition on natural numbers:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:15
msgid ""
"It is defined by the above equations, meaning that we have for free the "
"properties that adding ``m`` to zero always results in ``m``, and that "
"adding ``m`` to any non-zero number ``S k`` always results in ``S (plus k"
" m)``. We can see this by evaluation at the Idris REPL (i.e. the prompt, "
"the read-eval-print loop):"
msgstr ""

#: ../../source/proofs/pluscomm.rst:29
msgid ""
"Note that unlike many other language REPLs, the Idris REPL performs "
"evaluation on *open* terms, meaning that it can reduce terms which appear"
" inside lambda bindings, like those above. Therefore, we can introduce "
"unknowns ``k`` and ``m`` as lambda bindings and see how ``plus`` reduces."
msgstr ""

#: ../../source/proofs/pluscomm.rst:35
msgid ""
"The ``plus`` function has a number of other useful properties, for "
"example:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:38
msgid ""
"It is *commutative*, that is for all ``Nat`` inputs ``n`` and ``m``, we "
"know that ``plus n m = plus m n``."
msgstr ""

#: ../../source/proofs/pluscomm.rst:41
msgid ""
"It is *associative*, that is for all ``Nat`` inputs ``n``, ``m`` and "
"``p``, we know that ``plus n (plus m p) = plus (plus m n) p``."
msgstr ""

#: ../../source/proofs/pluscomm.rst:44
msgid ""
"We can use these properties in an Idris program, but in order to do so we"
" must *prove* them."
msgstr ""

#: ../../source/proofs/pluscomm.rst:48
msgid "Equality Proofs"
msgstr ""

#: ../../source/proofs/pluscomm.rst:50
msgid "Idris defines a propositional equality type as follows:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:57
msgid "As syntactic sugar, ``Equal x y`` can be written as ``x = y``."
msgstr ""

#: ../../source/proofs/pluscomm.rst:59
msgid ""
"It is *propositional* equality, where the type states that any two values"
" in different types ``a`` and ``b`` may be proposed to be equal. There is"
" only one way to *prove* equality, however, which is by reflexivity "
"(``Refl``)."
msgstr ""

#: ../../source/proofs/pluscomm.rst:64
msgid ""
"We have a *type* for propositional equality here, and correspondingly a "
"*program* inhabiting an instance of this type can be seen as a proof of "
"the corresponding proposition [1]_. So, trivially, we can prove that "
"``4`` equals ``4``:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:74
msgid "However, trying to prove that ``4 = 5`` results in failure:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:81
msgid ""
"The type ``4 = 5`` is a perfectly valid type, but is uninhabited, so when"
" trying to type check this definition, Idris gives the following error:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:94
msgid "Type checking equality proofs"
msgstr ""

#: ../../source/proofs/pluscomm.rst:96
msgid ""
"An important step in type checking Idris programs is *unification*, which"
" attempts to resolve implicit arguments such as the implicit argument "
"``x`` in ``Refl``. As far as our understanding of type checking proofs is"
" concerned, it suffices to know that unifying two terms involves reducing"
" both to normal form then trying to find an assignment to implicit "
"arguments which will make those normal forms equal."
msgstr ""

#: ../../source/proofs/pluscomm.rst:103
msgid ""
"When type checking ``Refl``, Idris requires that the type is of the form "
"``x = x``, as we see from the type of ``Refl``. In the case of "
"``four_eq_five``, Idris will try to unify the expected type ``4 = 5`` "
"with the type of ``Refl``, ``x = x``, notice that a solution requires "
"that ``x`` be both ``4`` and ``5``, and therefore fail."
msgstr ""

#: ../../source/proofs/pluscomm.rst:109
msgid ""
"Since type checking involves reduction to normal form, we can write the "
"following equalities directly:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:124
#: ../../source/proofs/propositional.rst:124
msgid "Heterogeneous Equality"
msgstr ""

#: ../../source/proofs/pluscomm.rst:126
msgid ""
"Equality in Idris is *heterogeneous*, meaning that we can even propose "
"equalities between values in different types:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:133
msgid ""
"The type ``Z = \"Z\"`` is uninhabited, and one might wonder why it is "
"useful to be able to propose equalities between values in different "
"types. However, with dependent types, such equalities can arise "
"naturally. For example, if two vectors are equal, their lengths must be "
"equal:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:143
msgid ""
"In the above declaration, ``xs`` and ``ys`` have different types because "
"their lengths are different, but we would still like to draw a conclusion"
" about the lengths if they happen to be equal. We can define "
"``vect_eq_length`` as follows:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:152
msgid ""
"By matching on ``Refl`` for the third argument, we know that the only "
"valid value for ``ys`` is ``xs``, because they must be equal, and "
"therefore their types must be equal, so the lengths must be equal."
msgstr ""

#: ../../source/proofs/pluscomm.rst:156
msgid ""
"Alternatively, we can put an underscore for the second ``xs``, since "
"there is only one value which will type check:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:164
msgid "Properties of ``plus``"
msgstr ""

#: ../../source/proofs/pluscomm.rst:166
msgid ""
"Using the ``(=)`` type, we can now state the properties of ``plus`` given"
" above as Idris type declarations:"
msgstr ""

#: ../../source/proofs/pluscomm.rst:174
msgid ""
"Both of these properties (and many others) are proved for natural number "
"addition in the Idris standard library, using ``(+)`` from the ``Num`` "
"interface rather than using ``plus`` directly. They have the names "
"``plusCommutative`` and ``plusAssociative`` respectively."
msgstr ""

#: ../../source/proofs/pluscomm.rst:179
msgid ""
"In the remainder of this tutorial, we will explore several different ways"
" of proving ``plus_commutes`` (or, to put it another way, writing the "
"function.) We will also discuss how to use such equality proofs, and see "
"where the need for them arises in practice."
msgstr ""

#: ../../source/proofs/pluscomm.rst:185
msgid "This is known as the Curry-Howard correspondence."
msgstr ""

#: ../../source/proofs/propositional.rst:1
msgid ""
"This page attempts to explain some of the techniques used in Idris to "
"prove propositional equalities."
msgstr ""

#: ../../source/proofs/propositional.rst:5
msgid "Proving Propositional Equality"
msgstr ""

#: ../../source/proofs/propositional.rst:7
msgid ""
"We have seen that definitional equalities can be proved using ``Refl`` "
"since they always normalise to values that can be compared directly."
msgstr ""

#: ../../source/proofs/propositional.rst:10
msgid ""
"However with propositional equalities we are using symbolic variables, "
"which do not always normalise."
msgstr ""

#: ../../source/proofs/propositional.rst:13
msgid "So to take the previous example:"
msgstr ""

#: ../../source/proofs/propositional.rst:19
msgid ""
"In this case ``plus n Z`` does not normalise to n. Even though both sides"
" of the equality are provably equal we cannot claim ``Refl`` as a proof."
msgstr ""

#: ../../source/proofs/propositional.rst:22
msgid ""
"If the pattern match cannot match for all ``n`` then we need to match all"
" possible values of ``n``. In this case"
msgstr ""

#: ../../source/proofs/propositional.rst:33
msgid ""
"we can't use ``Refl`` to prove ``plus n 0 = n`` for all ``n``. Instead, "
"we call it for each case separately.  So, in the second line for example,"
" the type checker substitutes ``Z`` for ``n`` in the type being matched, "
"and reduces the type accordingly."
msgstr ""

#: ../../source/proofs/propositional.rst:39
msgid "Replace"
msgstr ""

#: ../../source/proofs/propositional.rst:41
msgid ""
"This implements the 'indiscernability of identicals' principle, if two "
"terms are equal then they have the same properties. In other words, if "
"``x=y``, then we can substitute y for x in any expression. In our proofs "
"we can express this as:"
msgstr ""

#: ../../source/proofs/propositional.rst:45
msgid "if x=y then prop x = prop y"
msgstr ""

#: ../../source/proofs/propositional.rst:48
msgid ""
"where prop is a pure function representing the property. In the examples "
"below prop is an expression in some variable with a type like this: "
"``prop: n -> Type``"
msgstr ""

#: ../../source/proofs/propositional.rst:51
msgid ""
"So if ``n`` is a natural number variable then ``prop`` could be something"
" like ``\\n => 2*n + 3``."
msgstr ""

#: ../../source/proofs/propositional.rst:54
msgid "To use this in our proofs there is the following function in the prelude:"
msgstr ""

#: ../../source/proofs/propositional.rst:62
msgid ""
"If we supply an equality (x=y) and a proof of a property of x (``prop "
"x``) then we get a proof of a property of y (``prop y``). So, in the "
"following example, if we supply ``p1 x`` which is a proof that ``x=2`` "
"and the equality ``x=y`` then we get a proof that ``y=2``."
msgstr ""

#: ../../source/proofs/propositional.rst:76
msgid "Rewrite"
msgstr ""

#: ../../source/proofs/propositional.rst:78
msgid ""
"In practice, ``replace`` can be a little tricky to use because in general"
" the implicit argument ``prop`` can be hard to infer for the machine, so "
"Idris provides a high level syntax which calculates the property and "
"applies ``replace``."
msgstr ""

#: ../../source/proofs/propositional.rst:83
msgid ""
"Example: again we supply ``p1 x`` which is a proof that ``x=2`` and the "
"equality ``y=x`` then we get a proof that ``y=2``."
msgstr ""

#: ../../source/proofs/propositional.rst:94
msgid "We can think of ``rewrite`` as working in this way:"
msgstr ""

#: ../../source/proofs/propositional.rst:96
msgid "Start with a equation ``x=y`` and a property ``prop : x -> Type``"
msgstr ""

#: ../../source/proofs/propositional.rst:97
msgid "Search for ``x`` in ``prop``"
msgstr ""

#: ../../source/proofs/propositional.rst:98
msgid "Replaces all occurrences of ``x`` with ``y`` in ``prop``."
msgstr ""

#: ../../source/proofs/propositional.rst:100
msgid "That is, we are doing a substitution."
msgstr ""

#: ../../source/proofs/propositional.rst:102
msgid ""
"Notice that here we need to supply reverse equality, i.e. ``y=x`` instead"
" of ``x=y``. This is because ``rewrite`` performs the substitution of "
"left part of equality to the right part and this substitution is done in "
"the *return type*. Thus, here in the return type ``y=2`` we need to apply"
" ``y=x`` in order to match the type of the argument ``x=2``."
msgstr ""

#: ../../source/proofs/propositional.rst:108
msgid "Symmetry and Transitivity"
msgstr ""

#: ../../source/proofs/propositional.rst:110
msgid ""
"In addition to 'reflexivity' equality also obeys 'symmetry' and "
"'transitivity' and these are also included in the prelude:"
msgstr ""

#: ../../source/proofs/propositional.rst:126
msgid "Also included in the prelude:"
msgstr ""

