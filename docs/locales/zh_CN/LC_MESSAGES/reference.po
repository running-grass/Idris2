# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: 467195537@qq.com\n"
"POT-Creation-Date: 2022-07-12 09:08+0800\n"
"PO-Revision-Date: 2022-07-12 03:10+0000\n"
"Last-Translator: Leo Liu <leo19920823@gmail.com>\n"
"Language-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/"
"idris2/reference/zh_Hans/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.14-dev\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/reference/builtins.rst:5
msgid "Builtins"
msgstr ""

#: ../../source/reference/builtins.rst:11
msgid "Natural numbers"
msgstr ""

#: ../../source/reference/builtins.rst:13
msgid ""
"Idris2 supports an optimized runtime representation of natural numbers "
"(non-negative integers). This optimization is automatic, however it only "
"works when natural numbers are represented in a specific way"
msgstr ""

#: ../../source/reference/builtins.rst:17
msgid "Here is an example of a natural number that would be optimized:"
msgstr ""

#: ../../source/reference/builtins.rst:25
msgid ""
"Natural numbers are generally represented as either zero or the successor"
" (1 more than) of another natural number. These are called Peano numbers."
msgstr ""

#: ../../source/reference/builtins.rst:28
msgid ""
"At runtime, Idris2 will automatically represent this the same as the "
"``Integer`` type. This will massively reduce the memory usage."
msgstr ""

#: ../../source/reference/builtins.rst:31
msgid "There are a few rules governing when this optimization occures:"
msgstr ""

#: ../../source/reference/builtins.rst:33
msgid "The data type must have 2 constructors"
msgstr ""

#: ../../source/reference/builtins.rst:35
msgid ""
"After erasure of runtime irrelevant arguments + One must have no "
"arguments + One must have exactly 1 argument (called ``Succ``)"
msgstr ""

#: ../../source/reference/builtins.rst:39
msgid ""
"The type of the argument to ``Succ`` must have the same type constructor "
"as the parent type. This means indexed data types, like ``Fin``, can be "
"optimised."
msgstr ""

#: ../../source/reference/builtins.rst:41
msgid "The argument to ``Succ`` must be strict, ie not ``Lazy Natural``"
msgstr ""

#: ../../source/reference/builtins.rst:43
msgid ""
"To ensure that a type is optimized to an ``Integer``, use ``%builtin "
"Natural`` ie"
msgstr ""

#: ../../source/reference/builtins.rst:54
msgid "Casting between natural numbers and integer"
msgstr ""

#: ../../source/reference/builtins.rst:56
msgid ""
"Idris optimizes functions which convert between natural numbers and "
"integers, so that it takes constant time rather than linear time."
msgstr ""

#: ../../source/reference/builtins.rst:59
msgid ""
"Such functions must be written in a specific way, so that idris can "
"detect that it can be optimised."
msgstr ""

#: ../../source/reference/builtins.rst:62
msgid "Here is an example of a natural to ``Integer`` function."
msgstr ""

#: ../../source/reference/builtins.rst:70
msgid ""
"This optimization is applied late in the compilation process, so it may "
"be sensitive to seemingly insignificant changes."
msgstr ""

#: ../../source/reference/builtins.rst:73
msgid "However here are roughly the rules governing this optimisation:"
msgstr ""

#: ../../source/reference/builtins.rst:75
msgid ""
"Exactly one argument must be pattern matched on (any other forced or "
"dotted patterns are allowed)"
msgstr ""

#: ../../source/reference/builtins.rst:77
msgid "The right hand side of the 'Zero' case must be ``0``"
msgstr ""

#: ../../source/reference/builtins.rst:78
msgid ""
"The right hand side of the 'Succ' case must be ``1 + cast k`` where ``k``"
" is the predecessor of the pattern matched argument"
msgstr ""

#: ../../source/reference/builtins.rst:81
msgid "Casting from an ``Integer`` to a natural is a little more complex."
msgstr ""

#: ../../source/reference/builtins.rst:93
msgid "For now you must manually check the given integer is non-negative."
msgstr ""

#: ../../source/reference/builtins.rst:95
msgid ""
"If you are using an indexed data type it may be very hard to write your "
"``Integer`` to natural cast in such a way, so you can use ``%builtin "
"IntegerToNatural`` to assert to the compiler that a function is correct. "
"It is your responsibility to make sure this is correct."
msgstr ""

#: ../../source/reference/builtins.rst:122
msgid "Other operations"
msgstr ""

#: ../../source/reference/builtins.rst:124
msgid ""
"This can be used with ``%transform`` to allow many other operations to be"
" O(1) too."
msgstr ""

#: ../../source/reference/builtins.rst:142
msgid "Compilation"
msgstr ""

#: ../../source/reference/builtins.rst:144
msgid ""
"Here are the details of how natural numbers are compiled to ``Integer`` "
"s. Note: a numeric literal here is an ``Integer``."
msgstr ""

#: ../../source/reference/builtins.rst:147
msgid "``Zero`` => ``0``"
msgstr ""

#: ../../source/reference/builtins.rst:149
msgid "``Succ k`` => ``1 + k``"
msgstr ""

#: ../../source/reference/builtins.rst:157
msgid "=>"
msgstr ""

#: ../../source/reference/debugging.rst:3
msgid "Debugging The Compiler"
msgstr ""

#: ../../source/reference/debugging.rst:6
msgid "Performance"
msgstr ""

#: ../../source/reference/debugging.rst:8
msgid ""
"The compiler has the ``--timing`` flag to dump timing information "
"collected during operation."
msgstr ""

#: ../../source/reference/debugging.rst:10
msgid ""
"The output documents, in reverse chronological order, the cumulative time"
" taken for the operation (and sub operations) to complete. Sub levels are"
" indicated by successive repetitions of ``+``."
msgstr ""

#: ../../source/reference/debugging.rst:15
msgid "Logging"
msgstr ""

#: ../../source/reference/debugging.rst:17
msgid ""
"The compiler logs various categories of information during operation at "
"various levels."
msgstr ""

#: ../../source/reference/debugging.rst:19
msgid "Log levels are characterised by two things:"
msgstr ""

#: ../../source/reference/debugging.rst:21
msgid "a dot-separated path of ever finer topics of interest e.g. scope.let"
msgstr ""

#: ../../source/reference/debugging.rst:22
msgid "a natural number corresponding to the verbosity level e.g. 5"
msgstr ""

#: ../../source/reference/debugging.rst:24
msgid "If the user asks for some logs by writing::"
msgstr ""

#: ../../source/reference/debugging.rst:28
msgid ""
"they will get all of the logs whose path starts with `scope` and whose "
"verbosity level is less or equal to `5`. By combining different logging "
"directives, users can request information about everything (with a low "
"level of details) and at the same time focus on a particular subsystem "
"they want to get a lot of information about. For instance:::"
msgstr ""

#: ../../source/reference/debugging.rst:37
msgid ""
"will deliver basic information about the various phases the compiler goes"
" through and deliver a lot of information about scope-checking let "
"binders."
msgstr ""

#: ../../source/reference/debugging.rst:41
msgid "You can set the logging level at the command line using::"
msgstr ""

#: ../../source/reference/debugging.rst:45
msgid "and through the REPL using::"
msgstr ""

#: ../../source/reference/debugging.rst:51
msgid ""
"The supported logging categories can be found using the command line "
"flag::"
msgstr ""

#: ../../source/reference/debugging.rst:56
msgid "REPL Commands"
msgstr ""

#: ../../source/reference/debugging.rst:58
msgid ""
"To see more debug information from the REPL there are several options one"
" can set."
msgstr ""

#: ../../source/reference/debugging.rst:60
#: ../../source/reference/debugging.rst:72
msgid "Logging Categories"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "command"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "description"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "``:di <name>``"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "show debugging information for a name"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "``:set showimplicits``"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "show values of implicit arguments"
msgstr ""

#: ../../source/reference/debugging.rst:68
msgid "Compiler Flags"
msgstr ""

#: ../../source/reference/debugging.rst:70
msgid ""
"There are several 'hidden' compiler flags that can help expose Idris' "
"inner workings."
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "``--dumpcases <file>``"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "dump case trees to the given file"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "``--dumplifted <file>``"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "dump lambda lifted trees to the given file"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "``--dumpanf <file>``"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "dump ANF to the given file"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "``--dumpvmcode <file>``"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "dump VM Code to the given file"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "``--debug-elab-check``"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "do more elaborator checks (currently conversion in LinearCheck)"
msgstr ""

#: ../../source/reference/debugging.rst:84
msgid "Output Formats"
msgstr ""

#: ../../source/reference/debugging.rst:87
msgid "Debug Output"
msgstr ""

#: ../../source/reference/debugging.rst:89
msgid ""
"Calling ``:di <name>`` dumps debugging information about the selected "
"term. Specifically dumped are:"
msgstr ""

#: ../../source/reference/debugging.rst:92
msgid "Debugging Information"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "topic"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "Full Name(s)"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "The fully qualified name of the term."
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "Multiplicity"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "The terms multiplicity."
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "Erasable Arguments"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "Things that are erased."
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "Detaggable argument types"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "Specialised arguments"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "Inferrable arguments"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "Compiled version"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "Compile time linked terms"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "Runtime linked terms"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "Flags"
msgstr ""

#: ../../source/reference/debugging.rst:1
msgid "Size change graph"
msgstr ""

#: ../../source/reference/documenting.rst:5
msgid "Documenting Idris Code"
msgstr ""

#: ../../source/reference/documenting.rst:7
msgid ""
"Idris documentation comes in two major forms: comments, which exist for a"
" reader’s edification and are ignored by the compiler, and inline API "
"documentation, which the compiler parses and stores for future reference."
" To consult the documentation for a declaration ``f``, write ``:doc f`` "
"at the REPL or use the appropriate command in your editor (``C-c C-d`` in"
" Emacs, ``<LocalLeader>h`` in Vim)."
msgstr ""

#: ../../source/reference/documenting.rst:15
#: ../../source/reference/packages.rst:117
msgid "Comments"
msgstr ""

#: ../../source/reference/documenting.rst:17
msgid ""
"Use comments to explain why code is written the way that it is. Idris’s "
"comment syntax is the same as that of Haskell: lines beginning with "
"``--`` are comments, and regions bracketed by ``{-`` and ``-}`` are "
"comments even if they extend across multiple lines. These can be used to "
"comment out lines of code or provide simple documentation for the readers"
" of Idris code."
msgstr ""

#: ../../source/reference/documenting.rst:25
msgid "Inline Documentation"
msgstr ""

#: ../../source/reference/documenting.rst:27
msgid ""
"Idris also supports a comprehensive and rich inline syntax for Idris code"
" to be generated. This syntax also allows for named parameters and "
"variables within type signatures to be individually annotated using a "
"syntax similar to Javadoc parameter annotations."
msgstr ""

#: ../../source/reference/documenting.rst:32
msgid ""
"Documentation always comes before the declaration being documented. "
"Inline documentation applies to either top-level declarations or to "
"constructors. Documentation for specific arguments to constructors, type "
"constructors, or functions can be associated with these arguments using "
"their names."
msgstr ""

#: ../../source/reference/documenting.rst:38
msgid ""
"The inline documentation for a declaration is an unbroken string of "
"lines, each of which begins with ``|||`` (three pipe symbols). The first "
"paragraph of the documentation is taken to be an overview, and in some "
"contexts, only this overview will be shown. After the documentation for "
"the declaration as a whole, it is possible to associate documentation "
"with specific named parameters, which can either be explicitly name or "
"the results of converting free variables to implicit parameters.  "
"Annotations are the same as with Javadoc annotations, that is for the "
"named parameter ``(n : T)``, the corresponding annotation is ``||| @ n "
"Some description`` that is placed before the declaration."
msgstr ""

#: ../../source/reference/documenting.rst:50
msgid ""
"Documentation is written in Markdown, though not all contexts will "
"display all possible formatting (for example, images are not displayed "
"when viewing documentation in the REPL, and only some terminals render "
"italics correctly). A comprehensive set of examples is given below."
msgstr ""

#: ../../source/reference/envvars.rst:5
msgid "Environment Variables"
msgstr ""

#: ../../source/reference/envvars.rst:7
msgid ""
"Idris 2 recognises a number of environment variables, to decide where to "
"look for packages, external libraries, code generators, etc. It currently"
" recognises, in approximately the order you're likely to need them:"
msgstr ""

#: ../../source/reference/envvars.rst:11
msgid "``EDITOR`` - Sets the editor used in REPL :e command"
msgstr ""

#: ../../source/reference/envvars.rst:12
msgid "``IDRIS2_CG`` - Sets which code generator to use when compiling programs"
msgstr ""

#: ../../source/reference/envvars.rst:13
msgid ""
"``IDRIS2_PACKAGE_PATH`` - Lists the directories where Idris2 looks for "
"packages, in addition to the defaults (which are under the "
"``IDRIS2_PREFIX`` and in the ``depends`` subdirectory of the current "
"working directory). Directories are separated by a ``:``, or a ``;`` on "
"Windows"
msgstr ""

#: ../../source/reference/envvars.rst:17
msgid ""
"``IDRIS2_PATH`` - Places Idris2 looks for import files, in addition to "
"the imports in packages"
msgstr ""

#: ../../source/reference/envvars.rst:19
msgid ""
"``IDRIS2_DATA`` - Places Idris2 looks for its data files. These are "
"typically support code for code generators."
msgstr ""

#: ../../source/reference/envvars.rst:21
msgid ""
"``IDRIS2_LIBS`` - Places Idris2 looks for libraries used by code "
"generators."
msgstr ""

#: ../../source/reference/envvars.rst:22
msgid "``IDRIS2_PREFIX`` - Gives the Idris2 installation prefix"
msgstr ""

#: ../../source/reference/envvars.rst:23
msgid ""
"``CHEZ`` - Sets the location of the ``chez`` executable used in Chez "
"codegen"
msgstr ""

#: ../../source/reference/envvars.rst:24
msgid ""
"``RACKET`` - Sets the location of the ``racket`` executable used in "
"Racket codegen"
msgstr ""

#: ../../source/reference/envvars.rst:25
msgid ""
"``RACKET_RACO`` - Sets the location of the ``raco`` executable used in "
"Racket codegen"
msgstr ""

#: ../../source/reference/envvars.rst:26
msgid ""
"``GAMBIT_GSI`` - Sets the location of the ``gsi`` executable used in "
"Gambit codegen"
msgstr ""

#: ../../source/reference/envvars.rst:27
msgid ""
"``GAMBIT_GSC`` - Sets the location of the ``gsc`` executable used in "
"Gambit codegen"
msgstr ""

#: ../../source/reference/envvars.rst:28
msgid "``GAMBIT_GSC_BACKEND`` - Sets the ``gsc`` executable backend argument"
msgstr ""

#: ../../source/reference/envvars.rst:29
msgid ""
"``IDRIS2_CC`` - Sets the location of the C compiler executable used in "
"RefC codegen"
msgstr ""

#: ../../source/reference/envvars.rst:30
msgid ""
"``CC`` - Sets the location of the C compiler executable used in RefC "
"codegen"
msgstr ""

#: ../../source/reference/envvars.rst:31
msgid ""
"``NODE`` - Sets the location of the ``node`` executable used in Node "
"codegen"
msgstr ""

#: ../../source/reference/envvars.rst:32
msgid "``PATH`` - used to search for executables in certain codegens"
msgstr ""

#: ../../source/reference/index.rst:3
msgid "Idris2 Reference Guide"
msgstr ""

#: ../../source/reference/index.rst:7
msgid ""
"The documentation for Idris 2 has been published under the Creative "
"Commons CC0 License. As such to the extent possible under law, *The Idris"
" Community* has waived all copyright and related or neighboring rights to"
" Documentation for Idris."
msgstr ""
"Idris 2 的文档已在知识共享 CC0 许可下发布。因此，在法律允许的范围内，*Idris "
"社区* 已经放弃了 Idris 文档的所有版权和相关或邻近的权利。"

#: ../../source/reference/index.rst:12
msgid ""
"More information concerning the CC0 can be found online at: "
"https://creativecommons.org/publicdomain/zero/1.0/"
msgstr "有关 CC0 的更多信息，请访问：https://creativecommons.org/publicdomain/zero/1."
"0/"

#: ../../source/reference/index.rst:14
msgid "This is a placeholder, to get set up with readthedocs."
msgstr ""

#: ../../source/reference/literate.rst:5
msgid "Literate Programming"
msgstr ""

#: ../../source/reference/literate.rst:7
msgid "Idris2 supports several types of literate mode styles."
msgstr ""

#: ../../source/reference/literate.rst:9
msgid ""
"The unlit'n has been designed based such that we assume that we are "
"parsing markdown-like languages The unlit'n is performed by a Lexer that "
"uses a provided literate style to recognise code blocks and code lines. "
"Anything else is ignored. Idris2 also provides support for recognising "
"both 'visible' and 'invisible' code blocks using 'native features' of "
"each literate style."
msgstr ""

#: ../../source/reference/literate.rst:14
msgid "A literate style consists of:"
msgstr ""

#: ../../source/reference/literate.rst:16
msgid "a list of String encoded code block deliminators;"
msgstr ""

#: ../../source/reference/literate.rst:17
msgid "a list of line indicators; and"
msgstr ""

#: ../../source/reference/literate.rst:18
msgid "a list of valid file extensions."
msgstr ""

#: ../../source/reference/literate.rst:20
msgid ""
"Lexing is simple and greedy in that when consuming anything that is a "
"code blocks we treat everything as code until we reach the closing "
"deliminator. This means that use of verbatim modes in a literate file "
"will also be treated as active code."
msgstr ""

#: ../../source/reference/literate.rst:23
msgid ""
"In future we should add support for literate ``LaTeX`` files, and "
"potentially other common document formats. But more importantly, a more "
"intelligent processing of literate documents using a pandoc like library "
"in Idris such as: `Edda <https://github.com/jfdm/edda>` would also be "
"welcome."
msgstr ""

#: ../../source/reference/literate.rst:27
msgid "Bird Style Literate Files"
msgstr ""

#: ../../source/reference/literate.rst:29
msgid ""
"We treat files with an extension of ``.lidr`` as bird style literate "
"files."
msgstr ""

#: ../../source/reference/literate.rst:31
msgid ""
"Bird notation is a classic literate mode found in Haskell, (and Orwell) "
"in which visible code lines begin with ``>`` and hidden lines with ``<``."
" Other lines are treated as documentation."
msgstr ""

#: ../../source/reference/literate.rst:37
msgid ""
"We have diverged from ``lhs2tex`` in which ``<`` is traditionally used to"
" display inactive code. Bird-style is presented as is, and we recommended"
" use of the other styles for much more comprehensive literate mode."
msgstr ""

#: ../../source/reference/literate.rst:41
msgid "Embedding in Markdown-like documents"
msgstr ""

#: ../../source/reference/literate.rst:43
msgid ""
"While Bird Style literate mode is useful, it does not lend itself well to"
" more modern markdown-like notations such as Org-Mode and CommonMark. "
"Idris2 also provides support for recognising both 'visible' and "
"'invisible' code blocks and lines in both CommonMark and OrgMode "
"documents using native code blocks and lines.."
msgstr ""

#: ../../source/reference/literate.rst:48
msgid "The idea being is that:"
msgstr ""

#: ../../source/reference/literate.rst:50
msgid "**Visible** content will be kept in the pretty printer's output;"
msgstr ""

#: ../../source/reference/literate.rst:51
msgid "**Invisible** content will be removed; and"
msgstr ""

#: ../../source/reference/literate.rst:52
msgid ""
"**Specifications** will be displayed *as is* and not touched by the "
"compiler."
msgstr ""

#: ../../source/reference/literate.rst:55
msgid "OrgMode"
msgstr ""

#: ../../source/reference/literate.rst:57
msgid ""
"We treat files with an extension of ``.org`` as org-style literate files."
" Each of the following markup is recognised regardless of case:"
msgstr ""

#: ../../source/reference/literate.rst:60
msgid ""
"Org mode source blocks for idris sans options are recognised as visible "
"code blocks::"
msgstr ""

#: ../../source/reference/literate.rst:66
msgid ""
"Comment blocks that begin with ``#+BEGIN_COMMENT idris`` are treated as "
"invisible code blocks::"
msgstr ""

#: ../../source/reference/literate.rst:72
msgid ""
"Visible code lines, and specifications, are not supported. Invisible code"
" lines are denoted with ``#+IDRIS:``::"
msgstr ""

#: ../../source/reference/literate.rst:76
msgid ""
"Specifications can be given using OrgModes plain source or example "
"blocks::"
msgstr ""

#: ../../source/reference/literate.rst:86
msgid "CommonMark"
msgstr ""

#: ../../source/reference/literate.rst:88
msgid ""
"We treat files with an extension of ``.md`` and ``.markdown`` as "
"CommonMark style literate files."
msgstr ""

#: ../../source/reference/literate.rst:90
msgid ""
"CommonMark source blocks for idris sans options are recognised as visible"
" code blocks::"
msgstr ""

#: ../../source/reference/literate.rst:100
msgid ""
"Comment blocks of the form ``<!-- idris\\n ... \\n -->`` are treated as "
"invisible code blocks::"
msgstr ""

#: ../../source/reference/literate.rst:106
#: ../../source/reference/literate.rst:144
msgid "Code lines are not supported."
msgstr ""

#: ../../source/reference/literate.rst:108
msgid ""
"Specifications can be given using CommonMark's pre-formatted blocks "
"(indented by four spaces) or unlabelled code blocks.::"
msgstr ""

#: ../../source/reference/literate.rst:127
msgid "LaTeX"
msgstr ""

#: ../../source/reference/literate.rst:129
msgid ""
"We treat files with an extension of ``.tex`` and ``.ltx`` as LaTeX style "
"literate files."
msgstr ""

#: ../../source/reference/literate.rst:131
msgid "We treat environments named ``code`` as visible code blocks::"
msgstr ""

#: ../../source/reference/literate.rst:138
msgid "We treat environments named ``hidden`` as invisible code blocks::"
msgstr ""

#: ../../source/reference/literate.rst:146
msgid "Specifications can be given using user defined environments."
msgstr ""

#: ../../source/reference/literate.rst:148
msgid ""
"We do not provide definitions for these code blocks and ask the user to "
"define them. With one such example using ``fancyverbatim`` and "
"``comment`` packages as::"
msgstr ""

#: ../../source/reference/overloadedlit.rst:2
msgid "Overloaded literals"
msgstr ""

#: ../../source/reference/overloadedlit.rst:7
#, python-format
msgid ""
"The compiler provides directives for literals overloading, respectively "
"``%stringLit <fun>`` and ``%integerLit <fun>`` for string and integer "
"literals. During elaboration, the given function is applied to the "
"corresponding literal. In the Prelude these functions are set to "
"``fromString`` and ``fromInteger``."
msgstr ""

#: ../../source/reference/overloadedlit.rst:12
msgid ""
"The interface ``FromString ty`` provides the ``fromString : String -> "
"ty`` function, while the ``Num ty`` interface provides the ``fromInteger "
": Integer -> ty`` function for all numerical types."
msgstr ""

#: ../../source/reference/overloadedlit.rst:17
msgid "Restricted overloads"
msgstr ""

#: ../../source/reference/overloadedlit.rst:18
msgid ""
"Although the overloading of literals can be achieved by implementing the "
"interfaces described above, in principle only a function with the correct"
" signature and name is enough to achieve the desired behaviour. This can "
"be exploited to obtain more restrictive overloading such as converting "
"literals to ``Fin n`` values, where integer literals greater or equal to "
"n are not constructible values for the type. Additional implicit "
"arguments can be added to the function signature, in particular auto "
"implicit arguments for searching proofs. As an example, this is the "
"implementation of ``fromInteger`` for ``Fin n``."
msgstr ""

#: ../../source/reference/overloadedlit.rst:36
msgid ""
"The ``prf`` auto implicit is an automatically constructed proof (if "
"possible) that the literal is suitable for the ``Fin n`` type. The "
"restricted behaviour can be observed in the REPL, where the failure to "
"construct a valid proof is caught during the type-checking phase and not "
"at runtime:"
msgstr ""

#: ../../source/reference/packages.rst:5
msgid "Packages"
msgstr ""

#: ../../source/reference/packages.rst:7
msgid ""
"Idris includes a system for building packages from a package description "
"file.  These files can be used with the Idris compiler to manage the "
"development process of your Idris programs and packages."
msgstr ""

#: ../../source/reference/packages.rst:12
msgid "Package Descriptions"
msgstr ""

#: ../../source/reference/packages.rst:14
msgid "A package description includes the following:"
msgstr ""

#: ../../source/reference/packages.rst:16
msgid ""
"A header, consisting of the keyword ``package`` followed by the package "
"name. Package names can be any valid Idris identifier. The iPKG format "
"also takes a quoted version that accepts any valid filename."
msgstr ""

#: ../../source/reference/packages.rst:19
msgid "Fields describing package contents, ``<field> = <value>``"
msgstr ""

#: ../../source/reference/packages.rst:21
msgid ""
"Packages can describe libraries, executables, or both, and should include"
" a version number. For library packages, one field must be the modules "
"field, where the value is a comma separated list of modules to be "
"installed. For example, a library ``test`` which has two modules "
"``Foo.idr`` and ``Bar.idr`` as source files would be written as follows::"
msgstr ""

#: ../../source/reference/packages.rst:32
msgid ""
"When installed, this will be in a directory ``test-0.1``. If the version "
"number is missing, it will default to ``0``."
msgstr ""

#: ../../source/reference/packages.rst:35
msgid ""
"Other examples of package files can be found in the ``libs`` directory of"
" the main Idris repository, and in `third-party libraries "
"<https://github.com/idris-lang/Idris-dev/wiki/Libraries>`_."
msgstr ""

#: ../../source/reference/packages.rst:39
msgid "Metadata"
msgstr ""

#: ../../source/reference/packages.rst:41
msgid ""
"The `iPKG` format supports additional metadata associated with the "
"package. The added fields are:"
msgstr ""

#: ../../source/reference/packages.rst:44
msgid ""
"``brief = \"<text>\"``, a string literal containing a brief description "
"of the package."
msgstr ""

#: ../../source/reference/packages.rst:47
msgid ""
"``version = <version number>``, a semantic version number, which must be "
"in the form of integers separated by dots (e.g. ``1.0.0``, ``0.3.0``, "
"``3.1.4`` etc)"
msgstr ""

#: ../../source/reference/packages.rst:50
msgid ""
"``langversion <version constraints>``, see ``depends`` below for a list "
"of allowable constraints. For example, ``langversion >= 0.5.1 && < "
"1.0.0``"
msgstr ""

#: ../../source/reference/packages.rst:53
msgid "``readme = \"<file>\"``, location of the README file."
msgstr ""

#: ../../source/reference/packages.rst:55
msgid ""
"``license = \"<text>\"``, a string description of the licensing "
"information."
msgstr ""

#: ../../source/reference/packages.rst:58
msgid "``authors = \"<text>\"``, the author information."
msgstr ""

#: ../../source/reference/packages.rst:60
msgid "``maintainers = \"<text>\"``, Maintainer information."
msgstr ""

#: ../../source/reference/packages.rst:62
msgid "``homepage = \"<url>\"``, the website associated with the package."
msgstr ""

#: ../../source/reference/packages.rst:64
msgid ""
"``sourceloc = \"<url>\"``, the location of the DVCS where the source can "
"be found."
msgstr ""

#: ../../source/reference/packages.rst:67
msgid "``bugtracker = \"<url>\"``, the location of the project's bug tracker."
msgstr ""

#: ../../source/reference/packages.rst:70
msgid "Directories"
msgstr ""

#: ../../source/reference/packages.rst:72
msgid "``sourcedir = \"<dir>\"``, the directory to look for Idris source files."
msgstr ""

#: ../../source/reference/packages.rst:74
msgid ""
"``builddir = \"<dir>\"``, the directory to put the checked modules and "
"the artefacts from the code generator."
msgstr ""

#: ../../source/reference/packages.rst:77
msgid ""
"``outputdir = \"<dir>\"``, the directory where the code generator should "
"output the executable."
msgstr ""

#: ../../source/reference/packages.rst:81
msgid "Common Fields"
msgstr ""

#: ../../source/reference/packages.rst:83
msgid "Other common fields which may be present in an ``ipkg`` file are:"
msgstr ""

#: ../../source/reference/packages.rst:85
msgid ""
"``executable = <output>``, which takes the name of the executable file to"
" generate. Executable names can be any valid Idris identifier. the iPKG "
"format also takes a quoted version that accepts any valid filename."
msgstr ""

#: ../../source/reference/packages.rst:90
msgid ""
"Executables are placed in ``build/exec`` by default. The location can be "
"changed by specifying the ``outputdir`` field."
msgstr ""

#: ../../source/reference/packages.rst:93
msgid ""
"``main = <module>``, which takes the name of the main module, and must be"
" present if the ``executable`` field is present."
msgstr ""

#: ../../source/reference/packages.rst:96
msgid ""
"``opts = \"<idris options>\"``, which allows options to be passed to "
"Idris."
msgstr ""

#: ../../source/reference/packages.rst:99
msgid ""
"``depends = <pkg description> (',' <pkg description>)+``, a comma "
"separated list of package names that the Idris package requires. The "
"``pkg_description`` is the package name, followed by an optional list of "
"version constraints. Version constraints are separated by ``&&`` and can "
"use operators ``<``, ``<=``, ``>``, ``>=``, ``==``. For example, the "
"following are valid package descriptions:"
msgstr ""

#: ../../source/reference/packages.rst:106
msgid "``contrib`` (no constraints)"
msgstr ""

#: ../../source/reference/packages.rst:108
msgid "``contrib == 0.3.0`` (an exact version constraint)"
msgstr ""

#: ../../source/reference/packages.rst:110
msgid "``contrib >= 0.3.0`` (an inclusive lower bound)"
msgstr ""

#: ../../source/reference/packages.rst:112
msgid ""
"``contrib >= 0.3.0 && < 0.4`` (an inclusive lower bound, and exclusive "
"upper bound)"
msgstr ""

#: ../../source/reference/packages.rst:119
msgid ""
"Package files support comments using the standard Idris singleline ``--``"
" and multiline ``{- -}`` format."
msgstr ""

#: ../../source/reference/packages.rst:122
msgid "Using Package files"
msgstr ""

#: ../../source/reference/packages.rst:124
msgid ""
"Given an Idris package file ``test.ipkg`` it can be used with the Idris "
"compiler as follows:"
msgstr ""

#: ../../source/reference/packages.rst:126
msgid "``idris2 --build test.ipkg`` will build all modules in the package"
msgstr ""

#: ../../source/reference/packages.rst:128
msgid ""
"``idris2 --install test.ipkg`` will install the package to the global "
"Idris library directory (that is ``$IDRIS2_PREFIX/idris-<version>/``), "
"making the modules in its ``modules`` field accessible by other Idris "
"libraries and programs. Note that this doesn't install any executables, "
"just library modules."
msgstr ""

#: ../../source/reference/packages.rst:134
msgid "``idris2 --clean test.ipkg`` will clean the intermediate build files."
msgstr ""

#: ../../source/reference/packages.rst:136
msgid ""
"``idris2 --mkdoc test.ipkg`` will generate HTML documentation for the "
"package, output to ``build/docs``"
msgstr ""

#: ../../source/reference/packages.rst:139
msgid ""
"Once the test package has been installed, the command line option "
"``--package test`` makes it accessible (abbreviated to ``-p test``). For "
"example::"
msgstr ""

#: ../../source/reference/packages.rst:146
msgid "Where does Idris look for packages?"
msgstr ""

#: ../../source/reference/packages.rst:148
msgid ""
"Compiled packages are directories with compiled TTC files (see :ref"
":`build-artefacts` section). Directory structure of the source `*.idr` "
"files is preserved for TTC files."
msgstr ""

#: ../../source/reference/packages.rst:151
msgid ""
"Compiled packages can be installed globally (under "
"``$IDRIS2_PREFIX/idris-<version>/`` as described above) or locally (under"
" a ``depends`` subdirectory in the top level working directory of a "
"project). Packages specified using ``-p pkgname`` or with the ``depends``"
" field of a package will then be located as follows:"
msgstr ""

#: ../../source/reference/packages.rst:157
msgid ""
"First, Idris looks in ``depends/pkgname-<version>``, for a package which "
"satisfies the version constraint."
msgstr ""

#: ../../source/reference/packages.rst:159
msgid ""
"If no package is found locally, Idris looks in "
"``$IDRIS2_PREFIX/idris-<version>/pkgname-<version>``."
msgstr ""

#: ../../source/reference/packages.rst:162
msgid ""
"In each case, if more than one version satisfies the constraint, it will "
"choose the one with the highest version number. If package versions are "
"omitted in directory names, they are treated as the version ``0``."
msgstr ""

#: ../../source/reference/pragmas.rst:3
msgid "Pragmas"
msgstr ""

#: ../../source/reference/pragmas.rst:8
msgid ""
"Idris2 supports a number of pragmas (identifiable by the `%` prefix). "
"Some pragmas change compiler behavior until the behavior is changed back "
"using the same pragma while others apply to the following declaration. A "
"small niche of pragmas apply directly to one or more arguments instead of"
" the code following the pragma (like the `%name` pragma described below)."
msgstr ""

#: ../../source/reference/pragmas.rst:14
msgid ""
"This page is a work in progress. If you know about a pragma that is not "
"described yet, please consider submitting a pull request!"
msgstr ""

#: ../../source/reference/pragmas.rst:19
msgid "``%builtin``"
msgstr ""

#: ../../source/reference/pragmas.rst:21
msgid ""
"The ``%builtin Natural`` pragma converts recursive/unary representations "
"of natural numbers into primitive ``Integer`` representations."
msgstr ""

#: ../../source/reference/pragmas.rst:24
msgid ""
"This pragma is explained in detail on its own page. For more, see "
":ref:`builtins`."
msgstr ""

#: ../../source/reference/pragmas.rst:27
#, python-format
msgid "``%deprecate``"
msgstr ""

#: ../../source/reference/pragmas.rst:29
msgid ""
"Mark the following definition as deprecated. Whenever the function is "
"used, Idris will show a deprecation warning."
msgstr ""

#: ../../source/reference/pragmas.rst:45
msgid ""
"You can use code documentation (triple vertical bar `||| docs`) to "
"suggest a strategy for removing the deprecated function call and that "
"documentation will be displayed alongside the warning."
msgstr ""

#: ../../source/reference/pragmas.rst:64
#, python-format
msgid "``%inline``"
msgstr ""

#: ../../source/reference/pragmas.rst:66
msgid ""
"Instruct the compiler to inline the following definition when it is "
"applied. It is generally best to let the compiler and the backend you are"
" using optimize code based on its predetermined rules, but if you want to"
" force a function to be inlined when it is called, this pragma will force"
" it."
msgstr ""

#: ../../source/reference/pragmas.rst:77
msgid "``%noinline``"
msgstr ""

#: ../../source/reference/pragmas.rst:79
msgid ""
"Instruct the compiler _not_ to inline the following definition when it is"
" applied. It is generally best to let the compiler and the backend you "
"are using optimize code based on its predetermined rules, but if you want"
" to force a function to never be inlined when it is called, this pragma "
"will force it."
msgstr ""

#: ../../source/reference/pragmas.rst:90
msgid "``%name``"
msgstr ""

#: ../../source/reference/pragmas.rst:92
msgid ""
"Give the compiler some suggested names to use for a particular type when "
"it is asked to generate names for values. You can specify any number of "
"suggested names; they will be used in-order when more than one is needed "
"for a single definition."
msgstr ""

#: ../../source/reference/records.rst:2
msgid "Dot syntax for records"
msgstr ""

#: ../../source/reference/records.rst:7
msgid ""
"Long story short, ``.field`` is a postfix projection operator that binds "
"tighter than function application."
msgstr ""

#: ../../source/reference/records.rst:11
msgid "Lexical structure"
msgstr ""

#: ../../source/reference/records.rst:13
msgid ""
"``.foo`` is a valid name, which stands for record fields (new ``Name`` "
"constructor ``RF \"foo\"``)"
msgstr ""

#: ../../source/reference/records.rst:16
msgid ""
"``Foo.bar.baz`` starting with uppercase ``F`` is one lexeme, a namespaced"
" identifier: ``DotSepIdent [\"baz\", \"bar\", \"Foo\"]``"
msgstr ""

#: ../../source/reference/records.rst:19
msgid ""
"``foo.bar.baz`` starting with lowercase ``f`` is three lexemes: ``foo``, "
"``.bar``, ``.baz``"
msgstr ""

#: ../../source/reference/records.rst:22
msgid "``.foo.bar.baz`` is three lexemes: ``.foo``, ``.bar``, ``.baz``"
msgstr ""

#: ../../source/reference/records.rst:24
msgid ""
"If you want ``Constructor.field``, you have to write "
"``(Constructor).field``."
msgstr ""

#: ../../source/reference/records.rst:26
msgid "All module names must start with an uppercase letter."
msgstr ""

#: ../../source/reference/records.rst:29
msgid "New syntax of ``simpleExpr``"
msgstr ""

#: ../../source/reference/records.rst:31
msgid ""
"Expressions binding tighter than application (``simpleExpr``), such as "
"variables or parenthesised expressions, have been renamed to "
"``simplerExpr``, and an extra layer of syntax has been inserted."
msgstr ""

#: ../../source/reference/records.rst:39
msgid ""
"``(.foo)`` is a name, so you can use it to e.g. define a function called "
"``.foo`` (see ``.squared`` below)"
msgstr ""

#: ../../source/reference/records.rst:42
msgid "``(.foo.bar)`` is a parenthesised expression"
msgstr ""

#: ../../source/reference/records.rst:45
msgid "Desugaring rules"
msgstr ""

#: ../../source/reference/records.rst:47
msgid ""
"``(.field1 .field2 .field3)`` desugars to ``(\\x => .field3 (.field2 "
"(.field1 x)))``"
msgstr ""

#: ../../source/reference/records.rst:50
msgid ""
"``(simpleExpr .field1 .field2 .field3)`` desugars to ``((.field .field2 "
".field3) simpleExpr)``"
msgstr ""

#: ../../source/reference/records.rst:54
msgid "Record elaboration"
msgstr ""

#: ../../source/reference/records.rst:56
msgid ""
"there is a new pragma ``%prefix_record_projections``, which is ``on`` by "
"default"
msgstr ""

#: ../../source/reference/records.rst:59
msgid "for every field ``f`` of a record ``R``, we get:"
msgstr ""

#: ../../source/reference/records.rst:61
msgid ""
"projection ``f`` in namespace ``R`` (exactly like now), unless "
"``%prefix_record_projections`` is ``off``"
msgstr ""

#: ../../source/reference/records.rst:64
msgid "projection ``.f`` in namespace ``R`` with the same definition"
msgstr ""

#: ../../source/reference/records.rst:67
msgid "Example code"
msgstr ""

#: ../../source/reference/records.rst:76
msgid ""
"This record creates two projections: * ``.x : Point -> Double`` * ``.y : "
"Point -> Double``"
msgstr ""

#: ../../source/reference/records.rst:80
msgid ""
"Because ``%prefix_record_projections`` are ``on`` by default, we also "
"get: * ``x : Point -> Double`` * ``y : Point -> Double``"
msgstr ""

#: ../../source/reference/records.rst:84
msgid ""
"To prevent cluttering the ordinary global name space with short "
"identifiers, we can do this:"
msgstr ""

#: ../../source/reference/records.rst:95
msgid "For ``Rect``, we don't get the prefix projections:"
msgstr ""

#: ../../source/reference/records.rst:104
msgid "Let's define some constants:"
msgstr ""

#: ../../source/reference/records.rst:117
msgid "User-defined projections work, too. (Should they?)"
msgstr ""

#: ../../source/reference/records.rst:124
msgid "Finally, the examples:"
msgstr ""

#: ../../source/reference/records.rst:188
msgid "Parses but does not typecheck:"
msgstr ""

#: ../../source/reference/strings.rst:2
msgid "String literals in Idris"
msgstr ""

#: ../../source/reference/strings.rst:4
msgid ""
"To facilitate the use of string literals, idris provides three features "
"in addition to plain string literals: multiline strings, raw strings and "
"interpolated strings."
msgstr ""

#: ../../source/reference/strings.rst:9
msgid "Plain string literals"
msgstr ""

#: ../../source/reference/strings.rst:11
msgid ""
"String literals behave the way you expect from other programming "
"language. Use quotation marks ``\"`` around the piece of text that you "
"want to use as a string:"
msgstr ""

#: ../../source/reference/strings.rst:14
msgid "``\"hello world\"``"
msgstr ""

#: ../../source/reference/strings.rst:16
msgid ""
"As explained in :doc:`overloadedlit`, string literals can be overloaded "
"to return a type different than string."
msgstr ""

#: ../../source/reference/strings.rst:19
msgid "Multiline string literals"
msgstr ""

#: ../../source/reference/strings.rst:21
msgid ""
"In some cases you will have to display a large string literal that spans "
"multiple lines. For this you can use *multiline string literals*, they "
"allow you to span a string across multiple vertical lines, preserving the"
" line returns and the indentation. Additionally they allow you to indent "
"your multiline string with the surrounding code, without breaking the "
"intended format of the string."
msgstr ""

#: ../../source/reference/strings.rst:26
msgid ""
"To use multiline strings, start with a triple quote ``\"\"\"`` followed "
"by a line return, then enter your text and close it with another triple "
"quote ``\"\"\"`` with whitespace on its left. The indentation of the "
"closing triple quote will determine how much whitespace should be cropped"
" from each line of the text."
msgstr ""

#: ../../source/reference/strings.rst:33
msgid ""
"Multiline strings use triple quotes to enable the automatic cropping of "
"leading whitespace when the multiline block is indented."
msgstr ""

#: ../../source/reference/strings.rst:48
msgid "printing the variable `welcome` will result in the following text:"
msgstr ""

#: ../../source/reference/strings.rst:58
msgid ""
"As you can see, each line has been stripped of its leading 4 space, that "
"is because the closing delimiter was indented with 4 spaces."
msgstr ""

#: ../../source/reference/strings.rst:61
msgid "In order to use multiline string literals, remember the following:"
msgstr ""

#: ../../source/reference/strings.rst:63
msgid "The starting delimited must be followed by a line return"
msgstr ""

#: ../../source/reference/strings.rst:64
msgid ""
"The ending delimiter's intendation level must not exceed the indentation "
"of any line"
msgstr ""

#: ../../source/reference/strings.rst:67
msgid "Raw string literals"
msgstr ""

#: ../../source/reference/strings.rst:69
msgid ""
"It is not uncommon to write string literals that require some amount of "
"escaping. For plain string literals the characters ``\\\\`` and ``\"`` "
"must be escaped, for multiline strings the characters ``\"\"\"`` must be "
"escaped. Raw string literals allow you to dynamically change the required"
" escaped sequence in order to avoid having to escape those very common "
"sets of characters. For this, use ``#\"`` as starting delimiter and "
"``\"#`` as closing delimiter. The number of ``#`` symbols can be "
"increased in order to accomodate for edge cases where ``\"#`` would be a "
"valid symbol. In the following example we are able to match on ``\\{`` by"
" using half as many ``\\\\`` characters as if we didn't use raw string "
"literals:"
msgstr ""

#: ../../source/reference/strings.rst:84
msgid ""
"If you need to escape characters you still can by using a ``\\\\`` "
"followed by the same number of ``#`` that you used for your string "
"delimiters. In the following example we are using two ``#`` characters as"
" our escape sequence and want to print a line return:"
msgstr ""

#: ../../source/reference/strings.rst:93
msgid ""
"This last example could be implemented by combining raw string literals "
"with multiline strings:"
msgstr ""

#: ../../source/reference/strings.rst:105
msgid "Interpolated strings"
msgstr ""

#: ../../source/reference/strings.rst:107
msgid ""
"Concatenating string literals with runtime values happens all the time, "
"but sprinkling our code with lots of ``\"`` and ``++`` symbols sometimes "
"hurts legibility which in turn can introduce bugs that are hard to detect"
" for human eyes. Interpolated strings allow to inline the execution of "
"programs that evaluate to strings with a string literals in order to "
"avoid manually writing out the concatenation of those expressions. To use"
" interpolated strings, use ``\\{`` to start an interpolation slice in "
"which you can write an idris expression. Close it with ``}``"
msgstr ""

#: ../../source/reference/strings.rst:130
msgid ""
"As you can see in the second line, raw string literals and interpolated "
"strings can be combined. The starting and closing delimiters indicate how"
" many ``#`` must be used as escape sequence in the string, since "
"interpolated strings require the first ``{`` to be escaped, an "
"interpolated slice in a raw string uses ``\\#{`` as starting delimiter."
msgstr ""

#: ../../source/reference/strings.rst:135
msgid ""
"Additionally multiline strings can also be combined with string "
"interpolation in the way you expect, as shown with the ``Decl`` pattern. "
"Finally all three features can be combined together in the last branch of"
" the example, where a multiline string has a custom escape sequence and "
"includes an interpolated slice."
msgstr ""

#: ../../source/reference/strings.rst:141
msgid "Interpolation Interface"
msgstr ""

#: ../../source/reference/strings.rst:143
msgid ""
"The Prelude exposes an ``Interpolation`` interface with one function "
"``interpolate``. This function is used within every interpolation slice "
"to convert an arbitrary expression into a string that can be concatenated"
" with the rest of the interpolated string."
msgstr ""

#: ../../source/reference/strings.rst:147
msgid ""
"To go into more details, when you write ``\"hello \\{username}\"`` the "
"compiler translates the expression into ``concat [interpolate \"hello \","
" interpolate username]`` so that the concatenation is fast and so that if"
" ``username`` implement the ``Interpolation`` interface, you don't have "
"to convert it to a string manually."
msgstr ""

#: ../../source/reference/strings.rst:151
msgid ""
"Here is an example where we reuse the ``Expr`` type but instead of "
"implementing a ``print`` function we implement ``Interpolation``:"
msgstr ""

#: ../../source/reference/strings.rst:170
msgid ""
"As you can see we avoid repeated calls to ``print`` since the slices are "
"automatically applied to ``interpolate``."
msgstr ""

#: ../../source/reference/strings.rst:173
msgid ""
"We use ``Interpolation`` instead of ``Show`` for interpolation slices "
"because the semantics of ``show`` are not necessarily the same as "
"``interpolate``. Typically the implementation of ``show`` for ``String`` "
"adds double quotes around the text, but for ``interpolate`` what we want "
"is to return the string as is. In the previous example, ``\"hello "
"\\{username}\"``, if we were to use ``show`` we would end up with the "
"string ``\"hello \"Susan`` which displays an extra pair of double quotes."
" That is why the implementation of ``interpolate`` for ``String`` is the "
"identity function: ``interpolate x = x``. This way the desugared code "
"looks like: ``concat [id \"hello \", interpolate username]``."
msgstr ""
