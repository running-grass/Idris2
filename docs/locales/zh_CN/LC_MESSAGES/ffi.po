# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-08-28 21:56+0800\n"
"PO-Revision-Date: 2022-09-11 07:49+0000\n"
"Last-Translator: grass <467195537@qq.com>\n"
"Language-Team: Chinese (Simplified) <https://weblate.grass.work:30443/"
"projects/idris-lang/idris2-docs-ffi/zh_Hans/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.13.1\n"
"Generated-By: Babel 2.10.3\n"

#: ../source/ffi/ffi.rst:3 1fb3a540634d490bad9b84056f20f9c9
msgid "FFI Overview"
msgstr "FFI 概述"

#: ../source/ffi/ffi.rst:5 f98cc1912672427280991a099ce0c90c
#, python-format
msgid ""
"Foreign functions are declared with the ``%foreign`` directive, which "
"takes the following general form:"
msgstr "外部函数使用 ``%foreign`` 指令声明，它采用以下一般形式："

#: ../source/ffi/ffi.rst:13 6cd1769516ab433589e4f407b4f2dbe4
msgid ""
"The specifier is an Idris ``String`` which says in which language the "
"foreign function is written, what it's called, and where to find it. "
"There may be more than one specifier, and a code generator is free to "
"choose any specifier it understands - or even ignore the specifiers "
"completely and use their own approach. In general, a specifier has the "
"form \"Language:name,library\". For example, in C:"
msgstr ""
"说明符是一个 Idris ``String`` ，它表示外部函数是用哪种语言编写的，它被称为什"
"么，以及在哪里可以找到它。可能有多个说明符，"
"并且代码生成器可以自由选择它理解的任何说明符 - 甚至完全忽略说明符并使用自己的"
"方法。通常，说明符的形式为“Language:name,library”。例如，在 C 中："

#: ../source/ffi/ffi.rst:25 5b69d17e95174922b6a722662e772066
msgid ""
"It is up to specific code generators to decide how to locate the function"
" and the library. In this document, we will assume the default Chez "
"Scheme code generator (the examples also work with the Racket or Gambit "
"code generator) and that the foreign language is C."
msgstr ""
"由特定的代码生成器决定如何定位函数和库。在本文档中，我们将假设默认的 Chez "
"Scheme 代码生成器（示例也适用于 Racket 或 Gambit 代码生成器）并且外部语音是 "
"C。"

#: ../source/ffi/ffi.rst:31 94b1bf2282a64578b1364709f3f69b61
msgid "Scheme Sidenote"
msgstr "Scheme 旁注"

#: ../source/ffi/ffi.rst:33 993eb4a371ed49359330518640705d2d
msgid "Scheme foreign specifiers can be written to target particular flavors."
msgstr "可以编写 Scheme 外部说明符以针对特定目标的口味。"

#: ../source/ffi/ffi.rst:35 da48f694dac34072a664914dc5f62d18
msgid ""
"The following example shows a foreign declaration that allocates memory "
"in a way specific to the choice of code generator. In this example there "
"is no general scheme specifier present that matches every flavor, e.g. "
"``scheme:foo``, so it  will only match the specific flavors listed:"
msgstr ""
"以下示例显示了一个外部声明，它以特定于代码生成器选择的方式分配内存。在此示例"
"中，不存在匹配每种风味的通用方案说明符，例如 ``scheme:foo`` "
"，所以它只会匹配列出的特定口味："

#: ../source/ffi/ffi.rst:48 d8fc0cc844784682948b1c095eadd209
msgid ""
"If your backend (code generator) is not specified but defines a C FFI it "
"will be able to make use of the ``C:malloc,libc`` specifier."
msgstr "如果您的后端（代码生成器）未指定但定义了 C FFI，它将能够使用 "
"``C:malloc,libc`` 说明符。"

#: ../source/ffi/ffi.rst:52 da01834dec844c93913ab3e358a0bac9
msgid "C Sidenote"
msgstr "C 旁注"

#: ../source/ffi/ffi.rst:54 f40fe99f325b4a459e1500cf6bdc461b
msgid ""
"The ``C`` language specifier is used for common functions that may be "
"used by any backend which can, in turn, FFI out to C. For example, "
"Scheme."
msgstr "``C`` 语言说明符用于任何后端都可以使用的通用函数，而后端又可以将 FFI 输出到 "
"C。例如，Scheme。"

#: ../source/ffi/ffi.rst:57 45bf289abfa7496fa1bb1e9bc7314d20
msgid ""
"The common C functions do no automatic memory management, deferring that "
"to the individual backends."
msgstr "常见的 C 函数不进行自动内存管理，将其推迟到各个后端。"

#: ../source/ffi/ffi.rst:60 1b77aab10c964931900730b38726b00e
msgid ""
"The standard C backend is known as \"RefC\", and uses the ``RefC`` "
"language specifier."
msgstr "标准 C 后端称为“RefC”，并使用 ``RefC`` 语言说明符。"

#: ../source/ffi/ffi.rst:64 6e6d8f79d6dc4b4ebb129f3da10ffb6d
msgid "FFI Example"
msgstr "FFI 示例"

#: ../source/ffi/ffi.rst:66 5a6a627d152646babbadddae2abd8eae
msgid ""
"As a running example, we are going to work with a small C file. Save the "
"following content to a file ``smallc.c``"
msgstr "作为一个运行示例，我们将使用一个小的 C 文件。将以下内容保存到文件 ``smallc."
"c``"

#: ../source/ffi/ffi.rst:82 cd8b334476ec4a3199e3b62c9c795672
msgid "Then, compile it to a shared library with::"
msgstr "然后，将其编译为共享库："

#: ../source/ffi/ffi.rst:86 1381006c4f8a44df8209c059e560155f
msgid ""
"We can now write an Idris program which calls each of these. First, we'll"
" write a small program which uses ``add`` to add two integers:"
msgstr "我们现在可以编写一个 Idris "
"程序来调用其中的每一个函数。首先，我们将编写一个小程序，它使用 ``add`` "
"将两个整数相加："

#: ../source/ffi/ffi.rst:97 b2f7d5b2aeff4ccca0c515cd29bf531c
#, python-format
msgid ""
"The ``%foreign`` declaration states that ``add`` is written in C, with "
"the name ``add`` in the library ``libsmall``. As long as the run time is "
"able to locate ``libsmall.so`` (in practice it looks in the current "
"directory and the system library paths) we can run this at the REPL:"
msgstr ""
"``%foreign`` 说明符声明 ``add`` 是用 C 语言编写的，在 ``libsmall`` 库中名为 "
"``add`` 。只要运行时能够找到 ``libsmall.so`` "
"（实际上它会在当前目录和系统库路径中查找），我们就可以在 REPL 中运行它："

#: ../source/ffi/ffi.rst:107 db9079da813042189ea1268fb890a883
msgid ""
"Note that it is the programmer's responsibility to make sure that the "
"Idris function and C function have corresponding types. There is no way "
"for the machine to check this! If you get it wrong, you will get "
"unpredictable behaviour."
msgstr "请注意，确保 Idris 函数和 C 函数具有相应的类型是程序员的责任。机器没有办法检"
"查这个！如果你弄错了，你会得到不可预测的行为。"

#: ../source/ffi/ffi.rst:112 ca8af434ad1c42e6bd10ff525152d09d
msgid ""
"Since ``add`` has no side effects, we've given it a return type of "
"``Int``. But what if the function has some effect on the outside world, "
"like ``addWithMessage``? In this case, we use ``PrimIO Int`` to say that "
"it returns a primitive IO action:"
msgstr ""
"由于 ``add`` 没有副作用，我们给它一个 ``Int`` "
"返回类型。但是如果这个函数对外界有一些影响，比如 ``addWithMessage`` "
"呢？在这种情况下，我们使用 ``PrimIO Int`` 来表示它返回一个原语 IO 操作："

#: ../source/ffi/ffi.rst:122 de889edcd3f04fb1a8eb66015ac56019
msgid ""
"Internally, ``PrimIO Int`` is a function which takes the current (linear)"
" state of the world, and returns an ``Int`` with an updated state of the "
"world. In general, ``IO`` operations in an Idris program are defined as "
"instances of the ``HasIO`` interface. We can convert a primitive "
"operation to one usable in ``HasIO`` using ``primIO``:"
msgstr ""
"在内部， ``PrimIO Int`` 是一个函数，它获取世界的当前（线性）状态，"
"并返回一个带有更新的世界状态的 ``Int`` 。通常，Idris 程序中的 ``IO`` "
"操作被定义为 ``HasIO`` 接口的实例。我们可以使用 ``primIO`` 将原语操作转换为 "
"``HasIO`` 中可用的操作："

#: ../source/ffi/ffi.rst:132 a79cf92866d74bc286dc41144024a8cd
msgid "So, we can extend our program as follows:"
msgstr "因此，我们可以如下扩展我们的程序："

#: ../source/ffi/ffi.rst:145 332ea592a8304bc0ab3eb9b879a1db65
msgid ""
"It is up to the programmer to declare which functions are pure, and which"
" have side effects, via ``PrimIO``. Executing this gives:"
msgstr "程序员可以通过 ``PrimIO`` 声明哪些函数是纯函数，哪些有副作用。执行以下内容："

#: ../source/ffi/ffi.rst:154 1e82cf22261c4a8494afee8054e9326d
msgid "We have seen two specifiers for foreign functions:"
msgstr "我们已经看到了两个外部函数的说明符："

#: ../source/ffi/ffi.rst:161 032761c79aa547b09f40f388c76f70bc
msgid ""
"These both have the same form: ``\"C:[name],libsmall\"`` so instead of "
"writing the concrete ``String``, we write a function to compute the "
"specifier, and use that instead:"
msgstr ""
"它们都具有相同的形式： ``\"C:[name],libsmall\"`` ， 所以我们可以不写具体的 "
"``String`` ，而是写一个函数来计算说明符，并使用它来代替现在的字符串："

#: ../source/ffi/ffi.rst:179 d17e8e810a4c499292090a17391f412e
msgid "Primitive FFI Types"
msgstr "原语 FFI 类型"

#: ../source/ffi/ffi.rst:181 d5ed30566c0746a38f266c2b6d0f5bc3
msgid ""
"The types which can be passed to and returned from foreign functions are "
"restricted to those which it is reasonable to assume any back end can "
"handle. In practice, this means most primitive types, and a limited "
"selection of others.  Argument types can be any of the following "
"primitives:"
msgstr ""
"可以传递给外部函数和从外部函数返回的类型仅限于可以合理假设任何后端都可以处理"
"的类型。在实践中，这意味着大多数原语类型，以及有限的其他类型。参数类型可以是"
"以下任何原语："

#: ../source/ffi/ffi.rst:186 ../source/ffi/ffi.rst:414
#: 19d03656e5d2449eacc8d461cb2cd56a 1d8d8fefc5ac4dc3a8729f9aa74fe76c
msgid "``Int``"
msgstr "``Int``"

#: ../source/ffi/ffi.rst:187 ../source/ffi/ffi.rst:415
#: 0a543e6d842d4c17a4b1d680513e81ed a039b91f3e644d6bbe7622973c51d130
msgid "``Char``"
msgstr "``Char``"

#: ../source/ffi/ffi.rst:188 56be652e95d74928ba77f036fadfc335
msgid "``Double`` (as ``double`` in C)"
msgstr "``Double`` （在 C 中为 ``double`` ）"

#: ../source/ffi/ffi.rst:189 ../source/ffi/ffi.rst:417
#: 183f23d71f764366a80f6fcc4fdaa6c2 49f419f9fb7942559eb0b281a134a3e0
msgid "``Bits8``"
msgstr "``Bits8``"

#: ../source/ffi/ffi.rst:190 ../source/ffi/ffi.rst:418
#: 34ab388071d14c44b5a7334c414ed96d 3a88038c08f64bf7826a2697cb4f9ec7
msgid "``Bits16``"
msgstr "``Bits16``"

#: ../source/ffi/ffi.rst:191 ../source/ffi/ffi.rst:419
#: f4ffe303ceae426085c22aa7b9ec072a f83218198d6d44e8b533d54209d8b869
msgid "``Bits32``"
msgstr "``Bits32``"

#: ../source/ffi/ffi.rst:192 ../source/ffi/ffi.rst:420
#: 9d5e67ebc2e547f6818a361079a43881 b4e52a1822694187ada579ef654e437f
msgid "``Bits64``"
msgstr "``Bits64``"

#: ../source/ffi/ffi.rst:193 6ed130f9029549238eff2e6835ea73d6
msgid "``String`` (as ``char*`` in C)"
msgstr "``String`` (在 C 中作为 ``char*``)"

#: ../source/ffi/ffi.rst:194 c8bc7a84c87b4250868bb18f849efd31
msgid "``Ptr t`` and ``AnyPtr`` (both as ``void*`` in C)"
msgstr "``Ptr t`` 和 ``AnyPtr`` （在 C 中都是 ``void*`` ）"

#: ../source/ffi/ffi.rst:196 3e0ada00b6134a299dbb6b7c7cc4b708
msgid "Return types can be any of the above, plus:"
msgstr "返回类型可以是上述任何一种，加上："

#: ../source/ffi/ffi.rst:198 26508fe32bc14e54aa33f1d372bc6ad4
msgid "``()``"
msgstr "``()``"

#: ../source/ffi/ffi.rst:199 3f5ecd14104e4eddb351363dd5790be0
msgid "``PrimIO t``, where ``t`` is a valid return type other than a ``PrimIO``."
msgstr "``PrimIO t`` ，其中 ``t`` 是除了 ``PrimIO`` 之外的有效返回类型。"

#: ../source/ffi/ffi.rst:201 f9065b8470ee42e9a9a5c1ff4ba55de3
msgid "Handling ``String`` leads to some complications, for a number of reasons:"
msgstr "处理 ``String`` 会导致一些复杂性，原因有很多："

#: ../source/ffi/ffi.rst:203 22031d3b418c4a10bd34c9bc92302192
msgid ""
"Strings can have multiple encodings. In the Idris run time, Strings are "
"encoded as UTF-8, but C makes no assumptions."
msgstr "字符串可以有多种编码。在 Idris 运行时，字符串被编码为 UTF-8，但 C "
"不做任何假设。"

#: ../source/ffi/ffi.rst:205 31f0e0ca150f46988e69bf748f5acb60
msgid ""
"It is not always clear who is responsible for freeing a ``String`` "
"allocated by a C function."
msgstr "谁负责释放由 C 函数分配的字符串并不总是很清楚。"

#: ../source/ffi/ffi.rst:207 90467c3997024d79baeeea0bcdcc0743
msgid "In C, strings can be ``NULL``, but Idris strings always have a value."
msgstr "在 C 中，字符串可以是 ``NULL`` ，但 Idris 字符串总是有一个值。"

#: ../source/ffi/ffi.rst:209 fd0c610bfe64442c8ef3ac1a71e5c334
msgid "So, when passing ``String`` to and from C, remember the following:"
msgstr "因此，当将 ``String`` 传入和传出 C 时，请记住以下几点："

#: ../source/ffi/ffi.rst:211 6459bb5c0a13427386c861b9f05393bc
msgid ""
"A ``char*`` returned by a C function will be copied to the Idris heap, "
"and the Idris run time immediately calls ``free`` with the returned "
"``char*``."
msgstr ""
"C 函数返回的 ``char*`` 将被复制到 Idris 堆，并且 Idris 运行时立即对返回的 "
"``char*`` 调用 ``free`` 函数。"

#: ../source/ffi/ffi.rst:213 612442b4c1d744878b67f8174cfb1252
msgid ""
"If a ``char*`` might be ``NULL`` in ``C``, use ``Ptr String`` rather than"
" ``String``."
msgstr "如果 ``char*`` 在 ``C`` 中可能是 ``NULL`` ，请使用 ``Ptr String`` 而不是 "
"``String`` 。"

#: ../source/ffi/ffi.rst:216 6ded84f2aacb4828a191dbad267c75a8
msgid ""
"When using ``Ptr String``, the value will be passed as a ``void*``, and "
"therefore not accessible directly by Idris code. This is to protect "
"against accidentally trying to use ``NULL`` as a ``String``. You can "
"nevertheless work with them and convert to ``String`` via foreign "
"functions of the following form:"
msgstr ""
"当使用 ``Ptr String`` 时，该值将作为 ``void*`` 传递，因此 Idris "
"代码不能直接访问。这是为了防止意外尝试将 ``NULL`` 用作 ``String`` "
"。尽管如此，您仍然可以使用它们并通过以下形式的外部函数转换为 ``String`` ："

#: ../source/ffi/ffi.rst:236 fc81908c54eb4759b66ae5a2b376992d
msgid "For an example, see the sample :ref:`sect-readline` bindings."
msgstr "例如，请参阅示例 :ref:`sect-readline` 绑定。"

#: ../source/ffi/ffi.rst:238 244dc79782724f87b098c0c64b3b9538
msgid ""
"Additionally, foreign functions can take *callbacks*, and take and return"
" C ``struct`` pointers."
msgstr "此外，外部函数可以接受*回调*，并接受和返回 C ``struct`` 指针。"

#: ../source/ffi/ffi.rst:244 0b0dabe2942543c6be3de533a35b3735
msgid "Callbacks"
msgstr "回调"

#: ../source/ffi/ffi.rst:246 85afb54a94684df68bed2ad7e0838955
msgid ""
"It is often useful in C for a function to take a *callback*, that is a "
"function which is called after doing some work. For example, we can write"
" a function which takes a callback that takes a ``char*`` and an ``int`` "
"and returns a ``char*``, in C, as follows (added to ``smallc.c`` above):"
msgstr ""
"在 C 语言中，函数接受 *callback* 是很有用的，它是在完成一些工作后调用的函数。"
"例如，我们可以编写一个函数，该函数接受一个回调，该回调接受一个 ``char*`` "
"和一个 ``int`` 并返回一个 ``char*`` ，在 C 语言中，如下所示（添加到 ``"
"smallc. c`` 上面）："

#: ../source/ffi/ffi.rst:260 ffd7b1de2e3a4cae8770a29187079b12
#, python-format
msgid ""
"Then, we can access this from Idris by declaring it as a ``%foreign`` "
"function and wrapping it in the ``HasIO`` interface, with the C function "
"calling the Idris function as the callback:"
msgstr ""
"然后，我们可以通过将其声明为 ``%foreign`` 函数并将其包装在 ``HasIO`` "
"接口中来从 Idris 访问它，其中 C 函数调用 Idris 函数作为回调："

#: ../source/ffi/ffi.rst:273 99a1e73347cf4db3ac690c3d097ef334
msgid "For example, we can try this as follows:"
msgstr "例如，我们可以尝试如下："

#: ../source/ffi/ffi.rst:291 ffa635fcd7d641d7a877c6adedca0bf9
msgid "As a variant, the callback could have a side effect:"
msgstr "作为一种变体，回调可能会产生副作用："

#: ../source/ffi/ffi.rst:299 a52daaaee3a7406aaafec5d3b25b6c09
msgid ""
"This is a little more fiddly to lift to a ``HasIO`` function, due to the "
"callback, but we can do so using ``toPrim : IO a -> PrimIO a``:"
msgstr ""
"由于有回调，这对于提升到 ``HasIO`` 函数有点复杂，但是我们可以使用 ``toPrim : "
"IO a -> PrimIO a`` 来做到这一点："

#: ../source/ffi/ffi.rst:308 b8c9953d2637446ea7269c4fddf40776
msgid ""
"Note that the callback is explicitly in ``IO`` here, since ``HasIO`` "
"doesn't have a general method for extracting the primitive ``IO`` "
"operation."
msgstr "请注意，回调显式的被包裹在 ``IO`` 中，因为 ``HasIO`` 没有提取原语 ``IO`` "
"操作的通用方法。"

#: ../source/ffi/ffi.rst:311 cd8b0fe326fb4c31914773c40ce409f0
msgid ""
"For example, we can extend the above ``pluralise`` example to print a "
"message in the callback:"
msgstr "例如，我们可以扩展上面的 ``pluralise`` 示例以在回调中打印一条消息："

#: ../source/ffi/ffi.rst:332 d61d6f93a0184752b80031770fb5a0c8
msgid "Structs"
msgstr "结构体"

#: ../source/ffi/ffi.rst:334 2e802831a1374b9b82b575c7919a7b45
msgid ""
"Many C APIs pass around more complex data structures, as a ``struct``. We"
" do not aim to be completely general in the C types we support, because "
"this will make it harder to write code which is portable across multiple "
"back ends. However, it is still often useful to be able to access a "
"``struct`` directly. For example, add the following to the top of "
"``smallc.c``, and rebuild ``libsmall.so``:"
msgstr ""
"许多 C API 传递更复杂的数据结构，如 ``struct`` 。我们并不打算在我们支持的 C "
"类型中完全通用，因为这会使编写跨多个后端可移植的代码变得更加困难。但是，"
"能够直接访问 ``struct`` 通常会很有用。例如，将以下内容添加到 ``smallc.c`` "
"的顶部，并重新构建 ``libsmall.so`` ："

#: ../source/ffi/ffi.rst:361 2c017625f8364d75b91b45692abac647
msgid ""
"We can define a type for accessing ``point`` in Idris by importing "
"``System.FFI`` and using the ``Struct`` type, as follows:"
msgstr ""
"我们可以通过导入 ``System.FFI`` 并使用 ``Struct`` 类型在 Idris "
"中定义一个访问 ``point`` 的类型，如下所示："

#: ../source/ffi/ffi.rst:378 8c66ff78aad044c9b515eb88ce990bf1
msgid ""
"The ``Point`` type in Idris now corresponds to ``point*`` in C. Fields "
"can be read and written using the following, also from ``System.FFI``:"
msgstr ""
"Idris 中的 ``Point`` 类型现在对应于 C 中的 ``point*`` "
"。可以使用以下命令读取和写入字段，也可以通过 ``System.FFI`` ："

#: ../source/ffi/ffi.rst:388 5497c0ff242543cc94d27b21c4c25b64
msgid ""
"Notice that fields are accessed by name, and must be available in the "
"struct, given the constraint ``FieldType n ty fs``, which states that the"
" field named ``n`` has type ``ty`` in the structure fields ``fs``. So, we"
" can display a ``Point`` as follows by accessing the fields directly:"
msgstr ""
"请注意，字段是按名称访问的，并且必须在结构中可用，给定约束 ``FieldType n ty "
"fs`` ，它指出结构字段 ``fs`` 中名为 ``n`` 的字段具有类型 ``ty`` 。因此，"
"我们可以通过如下所示直接访问字段来显示 ``Point`` ："

#: ../source/ffi/ffi.rst:401 8e4c4304c0264497a4c71baf6edd9782
msgid ""
"And, as a complete example, we can initialise, update, display and delete"
" a ``Point`` as follows:"
msgstr "而且，作为一个完整的例子，我们可以初始化、更新、显示和删除一个 ``Point`` "
"，如下所示："

#: ../source/ffi/ffi.rst:412 4c3a4709be6e476b80ef3345424abb1b
msgid "The field types of a ``Struct`` can be any of the following:"
msgstr "``Struct`` 的字段类型可以是以下任何一种："

#: ../source/ffi/ffi.rst:416 bd6090ba85064ea3a3a9cb4a0bda272a
msgid "``Double`` (``double`` in C)"
msgstr "``Double`` (C 中为 ``double``)"

#: ../source/ffi/ffi.rst:421 b0efaf1d741b42acad32a0e3f0cde8dc
msgid "``Ptr a`` or ``AnyPtr`` (``void*`` in C)"
msgstr "``Ptr a`` 或 ``AnyPtr`` （C 中的 ``void*`` ）"

#: ../source/ffi/ffi.rst:422 c93ce4e7a43440fab525283706117d25
msgid "Another ``Struct``, which is a pointer to a ``struct`` in C"
msgstr "另一个 ``Struct`` ，在C中它是指向 ``struct`` 的指针"

#: ../source/ffi/ffi.rst:424 7d17efe3263642ff90e2d32b6714a79d
msgid ""
"Note that this doesn't include ``String`` or function types! This is "
"primarily because these aren't directly supported by the Chez back end. "
"However, you can use another pointer type and convert. For example, "
"assuming you have, in C:"
msgstr ""
"请注意，这不包括 ``String`` 或函数类型！这主要是因为 Chez "
"后端不直接支持这些。但是，您可以使用另一种指针类型并进行转换。例如，假设你在 "
"C 中有："

#: ../source/ffi/ffi.rst:435 cd2247ccf6d045f585972a120b41822e
msgid "You can represent this in Idris as:"
msgstr "您可以在 Idris 中将其表示为："

#: ../source/ffi/ffi.rst:445 28a39585b6cd4961958a47a55d35c55b
msgid ""
"That is, using a ``Ptr String`` instead of a ``String`` directly. Then "
"you can convert between a ``void*`` and a ``char*`` in C:"
msgstr ""
"也就是说，直接使用 ``Ptr String`` 而不是 ``String`` 。然后你可以在 C 中的 "
"``void*`` 和 ``char*`` 之间进行转换："

#: ../source/ffi/ffi.rst:454 34558a72fe204cf88a1a2baf895dc619
msgid "...and use this to convert to a ``String`` in Idris:"
msgstr "...并在 Idris 中使用它转换为 ``String`` ："

#: ../source/ffi/ffi.rst:463 f0768e94e28a48e9a9f7bb0c349180a5
msgid "Finalisers"
msgstr "决赛选手"

#: ../source/ffi/ffi.rst:465 41d259c61dc64d0c93cc5624df6f1bac
msgid ""
"In some libraries, a foreign function creates a pointer and the caller is"
" responsible for freeing it. In this case, you can make an explicit "
"foreign call to ``free``. However, this is not always convenient, or even"
" possible. Instead, you can ask the Idris run-time to be responsible for "
"freeing the pointer when it is no longer accessible, using ``onCollect`` "
"(or its typeless variant ``onCollectAny``) defined in the Prelude:"
msgstr ""
"在某些库中，外部函数创建一个指针，调用者负责释放它。在这种情况下，您可以对 "
"``free`` 进行显式的外部调用。然而，这并不总是方便的，甚至是不可能的。相反，"
"您可以使用 Prelude 中定义的 ``onCollect`` （或其无类型变体 ``onCollectAny`` "
"）要求 Idris 运行时负责在指针不再可访问时释放它："

#: ../source/ffi/ffi.rst:477 f8d03ab6458040a9a7703013d8b8136c
msgid ""
"A ``GCPtr t`` behaves exactly like ``Ptr t`` when passed to a foreign "
"function (and, similarly, ``GCAnyPtr`` behaves like ``AnyPtr``). A "
"foreign function cannot return a ``GCPtr`` however, because then we can "
"no longer assume the pointer is completely managed by the Idris run-time."
msgstr ""
"当传递给外部函数时， ``GCPtr t`` 的行为与 ``Ptr t`` 完全相同（类似地， "
"``GCAnyPtr`` 的行为类似于 ``AnyPtr`` ）。然而，外部函数不能返回 ``GCPtr`` ，"
"因为我们不能再假设指针完全由 Idris 运行时管理。"

#: ../source/ffi/ffi.rst:482 e6bfdf3307b0476daf82928b69ae0bd5
msgid ""
"The finaliser is called either when the garbage collector determines that"
" the pointer is no longer accessible, or at the end of execution."
msgstr "当垃圾收集器确定指针不再可访问时，或者在执行结束时调用终结器。"

#: ../source/ffi/ffi.rst:485 6d9fb96b3bdf488a9c338f9ffe3f9b00
msgid ""
"Note that finalisers might not be supported by all back ends, since they "
"depend on the facilities offered by a specific back end's run time "
"system. They are certainly supported in the Chez Scheme and Racket back "
"ends."
msgstr "请注意，并非所有后端都支持终结器，因为它们依赖于特定后端运行时系统提供的设施"
"。 Chez Scheme 和 Racket 后端肯定支持它们。"

#: ../source/ffi/index.rst:3 b9a30701f4214f7ea5d8f65e0d1beac0
msgid "Foreign Function Interface"
msgstr "外部函数接口"

#: ../source/ffi/index.rst:7 6843df425ff94108b36cfc6250a51938
msgid ""
"The documentation for Idris has been published under the Creative Commons"
" CC0 License. As such to the extent possible under law, *The Idris "
"Community* has waived all copyright and related or neighboring rights to "
"Documentation for Idris."
msgstr ""
"Idris 的文档已在知识共享 CC0 许可下发布。因此，在法律允许的范围内，*Idris "
"社区* 已经放弃了 Idris 文档的所有版权和相关或邻近的权利。"

#: ../source/ffi/index.rst:12 fd215ff15e3e42edbbeebb16e6beb0d3
msgid ""
"More information concerning the CC0 can be found online at: "
"http://creativecommons.org/publicdomain/zero/1.0/"
msgstr "关于CC0的更多信息，可以在网上找到：http://creativecommons.org/publicdomain/"
"zero/1.0/"

#: ../source/ffi/index.rst:14 6674d924cac040e5880316744685ba32
msgid ""
"Idris 2 is designed to support multiple code generators. The default "
"target is Chez Scheme, with Racket and Gambit code generators also "
"supported. However, the intention is, as with Idris 1, to support "
"multiple targets on multiple platforms, including e.g. JavaScript, JVM, "
".NET, and others yet to be invented. This makes the design of a foreign "
"function interface (FFI), which calls functions in other languages, a "
"little challenging, since ideally it will support all possible targets!"
msgstr ""
"Idris 2 旨在支持多个代码生成器。默认目标是 Chez Scheme，还支持 Racket 和 "
"Gambit 代码生成器。但是，与 Idris 1 一样，其目的是支持多个平台上的多个目标，"
"包括例如 JavaScript、JVM、.NET 和其他尚未发明的。"
"这使得调用其他语言函数的外部函数接口 (FFI) "
"的设计有点挑战，因为理想情况下它将支持所有可能的目标！"

#: ../source/ffi/index.rst:22 7399260b831a406084f500e4e2fc7a13
msgid ""
"To this end, the Idris 2 FFI aims to be flexible and adaptable, while "
"still supporting most common requirements without too much need for "
"\"glue\" code in the foreign language."
msgstr "为此，Idris 2 FFI 的目标是灵活和适应性强，同时仍然支持最常见的需求，"
"而不需要太多外部语言中的 “胶水” 代码。"

#: ../source/ffi/readline.rst:5 7cce367552864c45b99251a561fa631b
msgid "Example: Minimal Readline Bindings"
msgstr "示例：最小化的 Readline 绑定"

#: ../source/ffi/readline.rst:7 5b6a3f8efc8046748091284eb77240ef
#, fuzzy
msgid ""
"In this section, we'll see how to create bindings for a C library (the "
"`GNU Readline <https://tiswww.case.edu/php/chet/readline/rltop.html>`_ "
"library) in Idris, and make them available in a package. We'll only "
"create the most minimal bindings, but nevertheless they demonstrate some "
"of the trickier problems in creating bindings to a C library, in that "
"they need to handle memory allocation of ``String``."
msgstr ""
"在本节中，我们将看到如何在 Idris 中为 C 库（`GNU Readline <https://tiswww."
"case.edu/php/chet/readline/rltop.html>`_ "
"库）创建绑定，以及使它们在一个包中可用。我们将只创建最小的绑定，"
"但是它们展示了创建与 C "
"库的绑定时的一些更棘手的问题，因为它们需要处理“字符串”的内存分配。"

#: ../source/ffi/readline.rst:14 59a7cf0f84df47dbb6fb97c957967ce8
#, fuzzy
msgid ""
"You can find the example in full in the Idris 2 source repository, in "
"`samples/FFI-readline "
"<https://github.com/edwinb/Idris2/tree/master/samples/FFI-readline>`_. As"
" a minimal example, this can be used as a starting point for other C "
"library bindings."
msgstr ""
"您可以在 Idris 2 源代码库的 `samples/FFI-readline <https://github.com/edwinb/"
"Idris2/tree/master/samples/FFI-readline>`_ "
"中找到完整的示例。作为一个最小的示例，这可以用作其他 C 库绑定的起点。"

#: ../source/ffi/readline.rst:20 dc3a8ae2c19441cd838de6dcecb7529a
#, fuzzy
msgid ""
"We are going to provide bindings to the following functions in the "
"Readline API, available via ``#include <readline/readline.h>``:"
msgstr "我们将在 Readline API 中提供对以下函数的绑定，可通过 #include <readline/"
"readline.h> 获得："

#: ../source/ffi/readline.rst:28 84024cdb6efa4ecfa6d78baf74da1097
#, fuzzy
msgid ""
"Additionally, we are going to support tab completion, which in the "
"Readline API is achieved by setting a global variable to a callback "
"function (see Section :ref:`sect-callbacks`) which explains how to handle"
" the completion:"
msgstr ""
"此外，我们将支持制表符补全，在 Readline API "
"中，这是通过将全局变量设置为回调函数来实现的（参见 :ref:`sect-callbacks "
"部分），它解释了如何处理补全："

#: ../source/ffi/readline.rst:38 9b6343eeb45e4ec99009762fb0579d2b
#, fuzzy
msgid ""
"A completion function takes a ``String``, which is the text to complete, "
"and an ``Int``, which is the number of times it has asked for a "
"completion so far. In Idris, this could be a function ``complete : String"
" -> Int -> IO String``. So, for example, if the text so far is "
"``\"id\"``, and the possible completions are ``idiomatic`` and ``idris``,"
" then ``complete \"id\" 0`` would produce the string ``\"idiomatic\"`` "
"and ``complete \"id\" 1`` would produce ``\"idris\"``."
msgstr ""
"完成函数需要一个“字符串”，它是要完成的文本，和一个“整数”，它是到目前为止它要"
"求完成的次数。在 Idris 中，这可能是一个函数 ``complete : String -> Int -> IO "
"String``。因此，例如，如果到目前为止的文本是“id”，并且可能的补全是“惯用”和“id"
"ris”，那么“完整的“id”0 将产生字符串``\"idiomatic\"`` 和 ``complete \"id\" 1``"
" 会产生 ``\"idris\"``。"

#: ../source/ffi/readline.rst:45 61d79f674b344ecc834aa7b814f5da94
#, fuzzy
msgid ""
"We will define *glue* functions in a C file ``idris_readline.c``, which "
"compiles to a shared object ``libidrisreadline``, so we write a function "
"for locating the C functions:"
msgstr ""
"我们将在 C 文件 ``idris_readline.c`` 中定义 *glue* 函数，"
"该文件编译为共享对象 ``libidrisreadline``，因此我们编写了一个用于定位 C "
"函数的函数："

#: ../source/ffi/readline.rst:54 9284e2c8c1474209b6696dd3af6a77b5
#, fuzzy, python-format
msgid ""
"Each of the foreign bindings will have a ``%foreign`` specifier which "
"locates functions via ``rlib``."
msgstr "每个外部绑定都有一个“%foreign”说明符，它通过“rlib”定位函数。"

#: ../source/ffi/readline.rst:58 c628e3c7532c442e96d72ff74b9e5df1
#, fuzzy
msgid "Basic behaviour: Reading input, and history"
msgstr "基本行为：阅读输入和历史"

#: ../source/ffi/readline.rst:60 e5cdbd915fe14fb5ba594146273ce272
#, fuzzy
msgid ""
"We can start by writing a binding for ``readline`` directly. It's "
"interactive, so needs to return a ``PrimIO``:"
msgstr "我们可以从直接为 readline "
"编写绑定开始。它是交互式的，因此需要返回一个“PrimIO”："

#: ../source/ffi/readline.rst:68 4e36f9a67d4b47dc9286e26a2fc30c13
#, fuzzy
msgid "Then, we can write an ``IO`` wrapper:"
msgstr "然后，我们可以编写一个 ``IO`` 包装器："

#: ../source/ffi/readline.rst:75 ae401df0cbce416b845465eba91b0755
#, fuzzy
msgid ""
"Unfortunately, this isn't quite good enough! The C ``readline`` function "
"returns a ``NULL`` string if there is no input due to encountering an end"
" of file. So, we need to handle that - if we don't, we'll get a crash on "
"encountering end of file (remember: it's the Idris programmer's "
"responsibility to give an appropriate type to the C binding!)"
msgstr ""
"不幸的是，这还不够好！如果由于遇到文件结尾而没有输入，则 C ``readline`` "
"函数将返回 ``NULL`` 字符串。所以，我们需要处理它——如果我们不这样做，我们会在"
"遇到文件结尾时崩溃（记住：为 C 绑定提供适当的类型是 Idris 程序员的责任！）"

#: ../source/ffi/readline.rst:81 717869697a294d2eba1a9714166306cc
#, fuzzy
msgid ""
"Instead, we need to use a ``Ptr`` to say that it might be a ``NULL`` "
"pointer (see Section :ref:`sect-ffi-string`):"
msgstr "相反，我们需要使用 ``Ptr`` 来表示它可能是 ``NULL`` 指针（参见章节:ref:`sect-"
"ffi-string`）："

#: ../source/ffi/readline.rst:89 ca124258fa6644f1885a273daf06d47f
#, fuzzy
msgid ""
"We also need to provide a way to check whether the returned ``Ptr "
"String`` is ``NULL``. To do so, we'll write some glue code to convert "
"back and forth between ``Ptr String`` and ``String``, in a file "
"``idris_readline.c`` and a corresponding header ``idris_readline.h``. In "
"``idris_readline.h`` we have:"
msgstr ""
"我们还需要提供一种方法来检查返回的“Ptr String”是否为“NULL”。为此，我们将在 "
"``idris_readline.c`` 文件和相应的 ``idris_readline.h` "
"文件中编写一些胶水代码来在``Ptr String`` 和 ``String`` 之间来回转换`。在 "
"idris_readline.h 中，我们有："

#: ../source/ffi/readline.rst:101 8ae862342eb24aad9d8e2d09da4e3c88
#, fuzzy
msgid "Correspondingly, in ``idris_readline.c``:"
msgstr "相应地，在 idris_readline.c 中："

#: ../source/ffi/readline.rst:121 200536b49d4c43e7ab12914b669112b2
#, fuzzy
msgid ""
"Now, we can use ``prim__readline`` as follows, with a safe API, checking "
"whether the result it returns is ``NULL`` or a concrete ``String``:"
msgstr ""
"现在，我们可以使用 ``prim__readline`` 如下，通过一个安全的 "
"API，检查它返回的结果是``NULL`` 还是具体的``String``："

#: ../source/ffi/readline.rst:141 22c93e6f9d05433ba8ab733a62f320aa
#, fuzzy
msgid ""
"We'll need ``nullString`` and ``mkString`` later, for dealing with "
"completions."
msgstr "稍后我们将需要 ``nullString`` 和 ``mkString`` 来处理完成。"

#: ../source/ffi/readline.rst:143 13a9389b658847d39516f88c60f50618
#, fuzzy
msgid ""
"Once we've read a string, we'll want to add it to the input history. We "
"can provide a binding to ``add_history`` as follows:"
msgstr "一旦我们读取了一个字符串，我们就会想把它添加到输入历史中。我们可以提供对 "
"``add_history`` 的绑定，如下所示："

#: ../source/ffi/readline.rst:155 02c569be8d974702938d8e2260ff8c8a
#, fuzzy
msgid ""
"In this case, since Idris is in control of the ``String``, we know it's "
"not going to be ``NULL``, so we can add it directly."
msgstr "在这种情况下，由于 Idris 控制着 ``String``，我们知道它不会是 "
"``NULL``，所以我们可以直接添加它。"

#: ../source/ffi/readline.rst:158 1d592797b1c24186ab3c2c8426bf0381
#, fuzzy
msgid ""
"A small ``readline`` program that reads input, and echoes it, recording "
"input history for non-empty inputs, can be written as follows:"
msgstr "一个读取输入并回显它的小型“readline”程序，记录非空输入的输入历史，可以编写如"
"下："

#: ../source/ffi/readline.rst:173 d62b372df0504fc493905b514b6364ba
#, fuzzy
msgid ""
"This gives us command history, and command line editing, but Readline "
"becomes much more useful when we add tab completion. The default tab "
"completion, which is available even in the small example above, is to tab"
" complete file names in the current working directory. But for any "
"realistic application, we probably want to tab complete other commands, "
"such as function names, references to local data, or anything that is "
"appropriate for the application."
msgstr ""
"这为我们提供了命令历史记录和命令行编辑，但是当我们添加制表符完成时，Readline "
"变得更加有用。默认的制表符补全，即使在上面的小示例中也可用，是在当前工作目录"
"中补全文件名。但是对于任何实际的应用程序，我们可能希望使用 Tab "
"来完成其他命令，例如函数名称、对本地数据的引用或任何适合该应用程序的命令。"

#: ../source/ffi/readline.rst:181 d602ba22065d441d8a8f56e7de2d6c8d
#, fuzzy
msgid "Completions"
msgstr "完成"

#: ../source/ffi/readline.rst:183 0da557c74f6f4bb7ac623b625d8d43da
#, fuzzy
msgid ""
"Readline has a large API, with several ways of supporting tab completion,"
" typically involving setting a global variable to an appropriate "
"completion function. We'll use the following:"
msgstr "Readline 有一个庞大的 API，有多种支持制表符补全的方法，通常涉及将全局变量设置"
"为适当的补全函数。我们将使用以下内容："

#: ../source/ffi/readline.rst:192 a65527f749964bfaa3925e1be242c528
#, fuzzy
msgid ""
"The completion function takes the prefix of the completion, and the "
"number of times it has been called so far on this prefix, and returns the"
" next completion, or ``NULL`` if there are no more completions. An Idris "
"equivalent would therefore have the following type:"
msgstr ""
"完成函数接受完成的前缀，以及到目前为止在该前缀上调用它的次数，并返回下一个完"
"成，如果没有更多的完成，则返回“NULL”。因此，一个 Idris 等价物将具有以下类型："

#: ../source/ffi/readline.rst:201 2ba1fd12f9cf4c339604718570b79459
#, fuzzy
msgid ""
"The function returns ``Nothing`` if there are no more completions, or "
"``Just str`` for some ``str`` if there is another one for the current "
"input."
msgstr "如果没有更多的完成，该函数返回“Nothing”，或者如果当前输入有另一个完成，则返回"
"“Just str”一些“str”。"

#: ../source/ffi/readline.rst:205 e269edbc98cc4c41b140123107a6bfbe
#, fuzzy
msgid ""
"We might hope that it's a matter of defining a function to assign the "
"completion function..."
msgstr "我们可能希望这是定义一个函数来分配完成函数的问题......"

#: ../source/ffi/readline.rst:214 284fdd72706a4243a14db3625a6db620
#, fuzzy
msgid ""
"...then defining the Idris binding, which needs to take into account that"
" the Readline library expects ``NULL`` when there are no more "
"completions:"
msgstr "...然后定义 Idris 绑定，这需要考虑到 Readline 库在没有更多完成时期望 "
"``NULL``："

#: ../source/ffi/readline.rst:231 4c6b03f147394d60af8330b6d759862c
#, fuzzy
msgid ""
"So, we turn ``Nothing`` into ``nullString`` and ``Just str`` into "
"``mkString str``. Unfortunately, this doesn't quite work. To see what "
"goes wrong, let's try it for the most basic completion function that "
"returns one completion no matter what the input:"
msgstr ""
"所以，我们把“Nothing”变成了“nullString”，“Just str”变成了“mkString str”。不幸"
"的是，这并不完全奏效。为了看看出了什么问题，让我们试试这个最基本的完成函数，"
"不管输入是什么，它都会返回一个完成："

#: ../source/ffi/readline.rst:242 0630383dd94d4a57aa34910bfc2b4d9e
#, fuzzy
msgid ""
"We'll try this in a small modification of ``echoLoop`` above, setting a "
"completion function first:"
msgstr "我们将在上面的“echoLoop”的一个小修改中尝试这个，首先设置一个完成函数："

#: ../source/ffi/readline.rst:251 6c3dc18e08934fba981995e0e909d706
#, fuzzy
msgid ""
"We see that there is a problem when we try running it, and hitting TAB "
"before entering anything:"
msgstr "当我们尝试运行它并在输入任何内容之前点击 TAB 时，我们看到存在问题："

#: ../source/ffi/readline.rst:259 02c2a61f629b4cbf89ed3130badfbf07
#, fuzzy
msgid ""
"The Idris code which sets up the completion is fine, but there is a "
"problem with the memory allocation in the C glue code."
msgstr "设置完成的 Idris 代码很好，但是 C 胶水代码中的内存分配存在问题。"

#: ../source/ffi/readline.rst:262 dac47a69db6b47f688f53ba75aa02b53
#, fuzzy
msgid ""
"This problem arises because we haven't thought carefully enough about "
"which parts of our program are responsible for allocating and freeing "
"strings. When Idris calls a foreign function that returns a string, it "
"copies the string to the Idris heap and frees it immediately. But, if the"
" foreign library also frees the string, it ends up being freed twice. "
"This is what's happening here: the callback passed to "
"``prim__setCompletion`` frees the string and puts it onto the Idris heap,"
" but Readline also frees the string returned by ``prim__setCompletion`` "
"once it has processed it. We can solve this problem by writing a wrapper "
"for the completion function which reallocates the string, and using that "
"in ``idrisrl_setCompletion`` instead."
msgstr ""
"出现这个问题是因为我们没有仔细考虑程序的哪些部分负责分配和释放字符串。当 "
"Idris 调用返回字符串的外部函数时，它会将字符串复制到 Idris 堆并立即释放它。但"
"是，如果外部库也释放了字符串，它最终会被释放两次。这就是这里发生的事情："
"传递给 ``prim__setCompletion`` 的回调释放字符串并将其放入 Idris 堆，但 "
"Readline 也会在处理完 ``prim__setCompletion`` 返回的字符串后释放它。我们可以"
"通过为重新分配字符串的完成函数编写一个包装器来解决这个问题，并在 "
"idrisrl_setCompletion 中使用它。"

#: ../source/ffi/readline.rst:296 341248320fe74660861799085922c856
#, fuzzy
msgid ""
"So, we define the completion function in C, which calls the Idris "
"completion function then makes sure the string returned by the Idris "
"function is copied to the C heap."
msgstr "因此，我们在 C 中定义了完成函数，它调用 Idris 完成函数，然后确保将 Idris "
"函数返回的字符串复制到 C 堆中。"

#: ../source/ffi/readline.rst:300 3dd690fcde5d4382b084cb58f11c64e1
#, fuzzy
msgid ""
"We now have a primitive API that covers the most fundamental features of "
"the readline API:"
msgstr "我们现在有一个原始 API，它涵盖了 readline API 的最基本功能："
