# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 11:10+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/ffi/ffi.rst:3 8b2b2ab17d6d4d9d807d6c974c0e2756
msgid "FFI Overview"
msgstr ""

#: ../../source/ffi/ffi.rst:5 de20f731242d40b498020c99d6220fd2
#, python-format
msgid ""
"Foreign functions are declared with the ``%foreign`` directive, which "
"takes the following general form:"
msgstr ""

#: ../../source/ffi/ffi.rst:13 3fb9068bcf0b4957b366d9ed2b5b1fb5
msgid ""
"The specifier is an Idris ``String`` which says in which language the "
"foreign function is written, what it's called, and where to find it. "
"There may be more than one specifier, and a code generator is free to "
"choose any specifier it understands - or even ignore the specifiers "
"completely and use their own approach. In general, a specifier has the "
"form \"Language:name,library\". For example, in C:"
msgstr ""

#: ../../source/ffi/ffi.rst:25 5ca0ee53676c476e997b406dc16dca3b
msgid ""
"It is up to specific code generators to decide how to locate the function"
" and the library. In this document, we will assume the default Chez "
"Scheme code generator (the examples also work with the Racket or Gambit "
"code generator) and that the foreign language is C."
msgstr ""

#: ../../source/ffi/ffi.rst:31 babe4ee8ab144af79d176f9ce2506df4
msgid "Scheme Sidenote"
msgstr ""

#: ../../source/ffi/ffi.rst:33 3fe1b1abac7c4e019dbc2cbb349c6c07
msgid "Scheme foreign specifiers can be written to target particular flavors."
msgstr ""

#: ../../source/ffi/ffi.rst:35 1a3c6c1a83fe432b8a2b26c4ac747518
msgid ""
"The following example shows a foreign declaration that allocates memory "
"in a way specific to the choice of code generator. In this example there "
"is no general scheme specifier present that matches every flavor, e.g. "
"``scheme:foo``, so it  will only match the specific flavors listed:"
msgstr ""

#: ../../source/ffi/ffi.rst:48 a61c2af6a03c43b99476bc2f3187d7fa
msgid ""
"If your backend (code generator) is not specified but defines a C FFI it "
"will be able to make use of the ``C:malloc,libc`` specifier."
msgstr ""

#: ../../source/ffi/ffi.rst:52 822d7ca2605d4cf69a5a7fbbdec55eea
msgid "C Sidenote"
msgstr ""

#: ../../source/ffi/ffi.rst:54 5044468481df4b0a99ab0c1139208a85
msgid ""
"The ``C`` language specifier is used for common functions that may be "
"used by any backend which can, in turn, FFI out to C. For example, "
"Scheme."
msgstr ""

#: ../../source/ffi/ffi.rst:57 71f51eb9877d43b3a924e3a870028376
msgid ""
"The common C functions do no automatic memory management, deferring that "
"to the individual backends."
msgstr ""

#: ../../source/ffi/ffi.rst:60 f2ed6a086b614f6984bbba0838d7e8e5
msgid ""
"The standard C backend is known as \"RefC\", and uses the ``RefC`` "
"language specifier."
msgstr ""

#: ../../source/ffi/ffi.rst:64 3a28cf2c8ade45659656358d199e2f3e
msgid "FFI Example"
msgstr ""

#: ../../source/ffi/ffi.rst:66 111314fe5907460ea6d262be58d798c7
msgid ""
"As a running example, we are going to work with a small C file. Save the "
"following content to a file ``smallc.c``"
msgstr ""

#: ../../source/ffi/ffi.rst:82 42b4e9801aa246abaee76b3bee5daf26
msgid "Then, compile it to a shared library with::"
msgstr ""

#: ../../source/ffi/ffi.rst:86 c46882a217ac4be0a25ad9b78d6e4b5c
msgid ""
"We can now write an Idris program which calls each of these. First, we'll"
" write a small program which uses ``add`` to add two integers:"
msgstr ""

#: ../../source/ffi/ffi.rst:97 3adabfefc04344b9a0a57e0a9cc8c9cb
#, python-format
msgid ""
"The ``%foreign`` declaration states that ``add`` is written in C, with "
"the name ``add`` in the library ``libsmall``. As long as the run time is "
"able to locate ``libsmall.so`` (in practice it looks in the current "
"directory and the system library paths) we can run this at the REPL:"
msgstr ""

#: ../../source/ffi/ffi.rst:107 1187d619a29a46bfa2eed7b76eb55c8a
msgid ""
"Note that it is the programmer's responsibility to make sure that the "
"Idris function and C function have corresponding types. There is no way "
"for the machine to check this! If you get it wrong, you will get "
"unpredictable behaviour."
msgstr ""

#: ../../source/ffi/ffi.rst:112 44199a5984cf42c6af133d5d5a45896e
msgid ""
"Since ``add`` has no side effects, we've given it a return type of "
"``Int``. But what if the function has some effect on the outside world, "
"like ``addWithMessage``? In this case, we use ``PrimIO Int`` to say that "
"it returns a primitive IO action:"
msgstr ""

#: ../../source/ffi/ffi.rst:122 6f09486b1d8344d292e97f99c11f156e
msgid ""
"Internally, ``PrimIO Int`` is a function which takes the current (linear)"
" state of the world, and returns an ``Int`` with an updated state of the "
"world. In general, ``IO`` operations in an Idris program are defined as "
"instances of the ``HasIO`` interface. We can convert a primitive "
"operation to one usable in ``HasIO`` using ``primIO``:"
msgstr ""

#: ../../source/ffi/ffi.rst:132 5e571bd9f7a045908ccdca4437e61c22
msgid "So, we can extend our program as follows:"
msgstr ""

#: ../../source/ffi/ffi.rst:145 2a4fe88785364e1ca429b567b51911c1
msgid ""
"It is up to the programmer to declare which functions are pure, and which"
" have side effects, via ``PrimIO``. Executing this gives:"
msgstr ""

#: ../../source/ffi/ffi.rst:154 ebc60877ac6f49d4b23eacde8c522f12
msgid "We have seen two specifiers for foreign functions:"
msgstr ""

#: ../../source/ffi/ffi.rst:161 cc03d56393d44d3b8a224091f1240f31
msgid ""
"These both have the same form: ``\"C:[name],libsmall\"`` so instead of "
"writing the concrete ``String``, we write a function to compute the "
"specifier, and use that instead:"
msgstr ""

#: ../../source/ffi/ffi.rst:179 42d9bc57b2c34f7c8d39cb54b6082763
msgid "Primitive FFI Types"
msgstr ""

#: ../../source/ffi/ffi.rst:181 6b701e38b6cc40bb94d44b1d4491def1
msgid ""
"The types which can be passed to and returned from foreign functions are "
"restricted to those which it is reasonable to assume any back end can "
"handle. In practice, this means most primitive types, and a limited "
"selection of others.  Argument types can be any of the following "
"primitives:"
msgstr ""

#: ../../source/ffi/ffi.rst:186 ../../source/ffi/ffi.rst:414
#: 8a7e915e721d4d0ab99455b81ff23e55 a82993c0f6fc47c0bf82823397deae62
msgid "``Int``"
msgstr ""

#: ../../source/ffi/ffi.rst:187 ../../source/ffi/ffi.rst:415
#: 43e0a4e9f00d40d7978dc5f89456bdc6 9eb2650a68a84c22add726988b123af0
msgid "``Char``"
msgstr ""

#: ../../source/ffi/ffi.rst:188 4ebfcdaf19494beeb2422ce8ef78db36
msgid "``Double`` (as ``double`` in C)"
msgstr ""

#: ../../source/ffi/ffi.rst:189 ../../source/ffi/ffi.rst:417
#: 095f2bdbcd424b9fbeb69400f2ec077e 98ed3abb17ca4ec1a1da81c458ebc07d
msgid "``Bits8``"
msgstr ""

#: ../../source/ffi/ffi.rst:190 ../../source/ffi/ffi.rst:418
#: 494538a8cf744b78b32c943a444cfb67 fa18660ee456416c86e250e023653752
msgid "``Bits16``"
msgstr ""

#: ../../source/ffi/ffi.rst:191 ../../source/ffi/ffi.rst:419
#: 54c2cde2a8e54a189b83bf42dfb7e643 d9d3f5f841684a6bbe9980efaf7f8cb3
msgid "``Bits32``"
msgstr ""

#: ../../source/ffi/ffi.rst:192 ../../source/ffi/ffi.rst:420
#: 30b2d87492d6498eb39e7f382b62567e 828ad2b43ef348ddaf91d4b9ebe6ce3b
msgid "``Bits64``"
msgstr ""

#: ../../source/ffi/ffi.rst:193 82b7da281ab044d687750291d05cce38
msgid "``String`` (as ``char*`` in C)"
msgstr ""

#: ../../source/ffi/ffi.rst:194 dae55b5e2d1e46bab8b2b5addc9b80c2
msgid "``Ptr t`` and ``AnyPtr`` (both as ``void*`` in C)"
msgstr ""

#: ../../source/ffi/ffi.rst:196 3def3e414f9043e2b91647c5c14a79b3
msgid "Return types can be any of the above, plus:"
msgstr ""

#: ../../source/ffi/ffi.rst:198 79044e130d7943e092bb1bb879fd13ae
msgid "``()``"
msgstr ""

#: ../../source/ffi/ffi.rst:199 002d9a8b2d244162bf6b518a762492dc
msgid "``PrimIO t``, where ``t`` is a valid return type other than a ``PrimIO``."
msgstr ""

#: ../../source/ffi/ffi.rst:201 b46dee8d58d34273b9633b30acd10451
msgid "Handling ``String`` leads to some complications, for a number of reasons:"
msgstr ""

#: ../../source/ffi/ffi.rst:203 42df1a5594ea46b4a26185f043d84bd3
msgid ""
"Strings can have multiple encodings. In the Idris run time, Strings are "
"encoded as UTF-8, but C makes no assumptions."
msgstr ""

#: ../../source/ffi/ffi.rst:205 733d54b1778c438dacf603c949b2b65b
msgid ""
"It is not always clear who is responsible for freeing a ``String`` "
"allocated by a C function."
msgstr ""

#: ../../source/ffi/ffi.rst:207 1c3ffd927ef04c8883f1656e0e59508b
msgid "In C, strings can be ``NULL``, but Idris strings always have a value."
msgstr ""

#: ../../source/ffi/ffi.rst:209 8d30736b176c4d8284ac701f49ddb4fd
msgid "So, when passing ``String`` to and from C, remember the following:"
msgstr ""

#: ../../source/ffi/ffi.rst:211 e7f757a811544705be64d9547aece6d4
msgid ""
"A ``char*`` returned by a C function will be copied to the Idris heap, "
"and the Idris run time immediately calls ``free`` with the returned "
"``char*``."
msgstr ""

#: ../../source/ffi/ffi.rst:213 f1ada0c3f4f645b380f19ed10acefdaa
msgid ""
"If a ``char*`` might be ``NULL`` in ``C``, use ``Ptr String`` rather than"
" ``String``."
msgstr ""

#: ../../source/ffi/ffi.rst:216 c7de7bdce9bd43fba64b2546b3d79ae6
msgid ""
"When using ``Ptr String``, the value will be passed as a ``void*``, and "
"therefore not accessible directly by Idris code. This is to protect "
"against accidentally trying to use ``NULL`` as a ``String``. You can "
"nevertheless work with them and convert to ``String`` via foreign "
"functions of the following form:"
msgstr ""

#: ../../source/ffi/ffi.rst:236 349fd3127e7d4ed0beca25506c0ca3e9
msgid "For an example, see the sample :ref:`sect-readline` bindings."
msgstr ""

#: ../../source/ffi/ffi.rst:238 237f53c7b6e14a1b982a53bb0f6ec87a
msgid ""
"Additionally, foreign functions can take *callbacks*, and take and return"
" C ``struct`` pointers."
msgstr ""

#: ../../source/ffi/ffi.rst:244 397afea80bd74873a440c98a1cfd5b8f
msgid "Callbacks"
msgstr ""

#: ../../source/ffi/ffi.rst:246 b398be0ec94c43159a5c8986f4219442
msgid ""
"It is often useful in C for a function to take a *callback*, that is a "
"function which is called after doing some work. For example, we can write"
" a function which takes a callback that takes a ``char*`` and an ``int`` "
"and returns a ``char*``, in C, as follows (added to ``smallc.c`` above):"
msgstr ""

#: ../../source/ffi/ffi.rst:260 14a0dae8f2904b1f938fb647e36a56b3
#, python-format
msgid ""
"Then, we can access this from Idris by declaring it as a ``%foreign`` "
"function and wrapping it in the ``HasIO`` interface, with the C function "
"calling the Idris function as the callback:"
msgstr ""

#: ../../source/ffi/ffi.rst:273 72953f46a82b4992a0fda6bc1910cfdb
msgid "For example, we can try this as follows:"
msgstr ""

#: ../../source/ffi/ffi.rst:291 f964a0cbfa2d47208afb57a062e64a20
msgid "As a variant, the callback could have a side effect:"
msgstr ""

#: ../../source/ffi/ffi.rst:299 7315e5a8680e4b5994f27c1a8ea40e02
msgid ""
"This is a little more fiddly to lift to a ``HasIO`` function, due to the "
"callback, but we can do so using ``toPrim : IO a -> PrimIO a``:"
msgstr ""

#: ../../source/ffi/ffi.rst:308 7231860f0251479798521e5af4f3baf5
msgid ""
"Note that the callback is explicitly in ``IO`` here, since ``HasIO`` "
"doesn't have a general method for extracting the primitive ``IO`` "
"operation."
msgstr ""

#: ../../source/ffi/ffi.rst:311 f6f8c2c64f424e53bcb97f627f0a4c92
msgid ""
"For example, we can extend the above ``pluralise`` example to print a "
"message in the callback:"
msgstr ""

#: ../../source/ffi/ffi.rst:332 1f2ade0ead39474eaf96275e3c057ee6
msgid "Structs"
msgstr ""

#: ../../source/ffi/ffi.rst:334 7701d42d91c149ff8ad882da97de5d4e
msgid ""
"Many C APIs pass around more complex data structures, as a ``struct``. We"
" do not aim to be completely general in the C types we support, because "
"this will make it harder to write code which is portable across multiple "
"back ends. However, it is still often useful to be able to access a "
"``struct`` directly. For example, add the following to the top of "
"``smallc.c``, and rebuild ``libsmall.so``:"
msgstr ""

#: ../../source/ffi/ffi.rst:361 363a670256db45649280e731bdc32db8
msgid ""
"We can define a type for accessing ``point`` in Idris by importing "
"``System.FFI`` and using the ``Struct`` type, as follows:"
msgstr ""

#: ../../source/ffi/ffi.rst:378 0750ebc2bc914418950bff1628fcfd98
msgid ""
"The ``Point`` type in Idris now corresponds to ``point*`` in C. Fields "
"can be read and written using the following, also from ``System.FFI``:"
msgstr ""

#: ../../source/ffi/ffi.rst:388 0f21e9889bbb4b7880a96b8d5f720fe3
msgid ""
"Notice that fields are accessed by name, and must be available in the "
"struct, given the constraint ``FieldType n ty fs``, which states that the"
" field named ``n`` has type ``ty`` in the structure fields ``fs``. So, we"
" can display a ``Point`` as follows by accessing the fields directly:"
msgstr ""

#: ../../source/ffi/ffi.rst:401 79bea6bb300e497594a1e087d2270a0a
msgid ""
"And, as a complete example, we can initialise, update, display and delete"
" a ``Point`` as follows:"
msgstr ""

#: ../../source/ffi/ffi.rst:412 ba6e5ccf6e7d4d0da89809078240a3f7
msgid "The field types of a ``Struct`` can be any of the following:"
msgstr ""

#: ../../source/ffi/ffi.rst:416 5991b1dd90ea4bbc9654fb4f399cf1c7
msgid "``Double`` (``double`` in C)"
msgstr ""

#: ../../source/ffi/ffi.rst:421 34493a122006475a9515623955336dd2
msgid "``Ptr a`` or ``AnyPtr`` (``void*`` in C)"
msgstr ""

#: ../../source/ffi/ffi.rst:422 fdb215c213994a1b9aca68cf157b1d0d
msgid "Another ``Struct``, which is a pointer to a ``struct`` in C"
msgstr ""

#: ../../source/ffi/ffi.rst:424 ee92a8690eac47ff83bdda91e3586faf
msgid ""
"Note that this doesn't include ``String`` or function types! This is "
"primarily because these aren't directly supported by the Chez back end. "
"However, you can use another pointer type and convert. For example, "
"assuming you have, in C:"
msgstr ""

#: ../../source/ffi/ffi.rst:435 1bd4a26748ed42a7a0eb4afaf92a9cb3
msgid "You can represent this in Idris as:"
msgstr ""

#: ../../source/ffi/ffi.rst:445 87e2ae172e664458990d0e3d33ba1fc8
msgid ""
"That is, using a ``Ptr String`` instead of a ``String`` directly. Then "
"you can convert between a ``void*`` and a ``char*`` in C:"
msgstr ""

#: ../../source/ffi/ffi.rst:454 dd3487978c7b4d5d9f41562e109a97b2
msgid "...and use this to convert to a ``String`` in Idris:"
msgstr ""

#: ../../source/ffi/ffi.rst:463 6919b29eb1a046259fc700c2c1de72ff
msgid "Finalisers"
msgstr ""

#: ../../source/ffi/ffi.rst:465 6b81d4b3c0fe48b89e2106998591d59f
msgid ""
"In some libraries, a foreign function creates a pointer and the caller is"
" responsible for freeing it. In this case, you can make an explicit "
"foreign call to ``free``. However, this is not always convenient, or even"
" possible. Instead, you can ask the Idris run-time to be responsible for "
"freeing the pointer when it is no longer accessible, using ``onCollect`` "
"(or its typeless variant ``onCollectAny``) defined in the Prelude:"
msgstr ""

#: ../../source/ffi/ffi.rst:477 e0a55287651c4d6db0ac2759e02ed66f
msgid ""
"A ``GCPtr t`` behaves exactly like ``Ptr t`` when passed to a foreign "
"function (and, similarly, ``GCAnyPtr`` behaves like ``AnyPtr``). A "
"foreign function cannot return a ``GCPtr`` however, because then we can "
"no longer assume the pointer is completely managed by the Idris run-time."
msgstr ""

#: ../../source/ffi/ffi.rst:482 e8d9ee7a77c547efba713b7d7b8e6461
msgid ""
"The finaliser is called either when the garbage collector determines that"
" the pointer is no longer accessible, or at the end of execution."
msgstr ""

#: ../../source/ffi/ffi.rst:485 dc8da7bbba76412391d746a301d1652a
msgid ""
"Note that finalisers might not be supported by all back ends, since they "
"depend on the facilities offered by a specific back end's run time "
"system. They are certainly supported in the Chez Scheme and Racket back "
"ends."
msgstr ""

