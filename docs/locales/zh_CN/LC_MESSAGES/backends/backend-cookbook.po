# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: 467195537@qq.com\n"
"POT-Creation-Date: 2022-07-12 11:10+0800\n"
"PO-Revision-Date: 2022-08-25 06:52+0000\n"
"Last-Translator: Anonymous <noreply@weblate.org>\n"
"Language-Team: Chinese (Simplified) <https://weblate.grass.work:30443/"
"projects/idris2/backendsbackend-cookbook/zh_Hans/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.13.1\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/backends/backend-cookbook.rst:2
#: 0387fd1e9eb347a8b42ff4e401b9b18b
msgid "Custom backend cookbook"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:4
#: e06865158a4544d39d53d938c3bce0e6
msgid ""
"This document addresses the details on how to implement a custom code "
"generation backend for the Idris compiler."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:7
#: a82d2266f9f946dda7afc725ac78a9ff
msgid ""
"This part has no insights about how to implement the dependently typed "
"bits. For that part of the compiler Edwin Brady gave lectures at SPLV20_ "
"which are available online."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:11
#: dd25aa3c0af248898eebc4744a20b192
msgid ""
"The architecture of the Idris2 compiler makes it easy to implement a "
"custom code generation back-end."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:14
#: ec092e9e50cc40cfa24058d2f576ac63
#, fuzzy
msgid ""
"The way to extend Idris with new back-ends is to use it as a library. The"
" module ``Idris.Driver`` exports the function ``mainWithCodegens``, that "
"takes a list of ``(String, Codegen)``, starting idris with these codegens"
" in addition to the built-in ones. The first codegen in the list will be "
"set as the default codegen."
msgstr ""
"使用新后端扩展 Idris 2 的方法是将其用作库。模块 ``Idris.Driver`` 导出函数 "
"``mainWithCodegens`` ，它接受一个 ``(String, Codegen)`` "
"列表，除了内置代码之外，还使用这些代码生成器启动\n"
" idris 。列表中的第一个 codegen 将被设置为默认 codegen。"

#: ../../source/backends/backend-cookbook.rst:20
#: 14aefb90740441e0b905c8bda28ff660
msgid ""
"Anyone who is interested in implementing a custom back-end needs to "
"answer the following questions:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:23
#: ../../source/backends/backend-cookbook.rst:119
#: bab39b34067e4e7f91eaa69aaa3891e6 c7e9560472784b27ae49d4efc6bf7f82
msgid ""
"Which Intermediate Representation (IR) should be consumed by the custom "
"back-end?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:24
#: ../../source/backends/backend-cookbook.rst:136
#: 970d3a824b1145998e3c45753378b4e3 aa2c71f3c9d44ce7b4b6c5dcac0662bc
msgid ""
"How to represent primitive values defined by the ``Core.TT.Constant`` "
"type?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:25
#: ../../source/backends/backend-cookbook.rst:218
#: 15efdbce89444b0eb02779847bc78f0e 96c3388ab0184d86adb1943177fa1ccd
msgid "How to represent Algebraic Data Types?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:26
#: ../../source/backends/backend-cookbook.rst:288
#: 13aed8354c2148dbb8ed50d828f051d2 6ceb6924b7364ff9804e8d629e3188d3
msgid "How to implement special values?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:27
#: ../../source/backends/backend-cookbook.rst:351
#: 5af82cf4f75c421190c89d36f11bb0cb c857b38e01e841b49db57029b7d00cc3
msgid "How to implement primitive operations?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:28
#: ../../source/backends/backend-cookbook.rst:443
#: 06b6329ac5e2489cb3756a6a4da9b9b9 7e8ecd74a7bb4d72810dc0ae4bfb4a85
msgid "How to compile IR expressions?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:29
#: 8d1a432a67f9488aa22c1de90ec08e2b
msgid "How to compile Definitions?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:30
#: 32e04566f0e04f0c8b2c79e8f9355f79
msgid "How to implement Foreign Function Interface?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:31
#: ../../source/backends/backend-cookbook.rst:673
#: 9df72a4b05e8466199d2818440557502 ce456c3df89349eb97ab30ba4e841d49
msgid "How to compile modules?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:32
#: ../../source/backends/backend-cookbook.rst:692
#: 7658206c77b748fea6ea591937ed1948 78b5d6fb8dc944e685d23c9ccfe8bc21
msgid "How to embed code snippets?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:33
#: ../../source/backends/backend-cookbook.rst:713
#: 61e94de03ac8449888060ceb41c4019b 83137e82fa5e4a569385bcf6c903d2b0
msgid "What should the runtime system support?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:35
#: b8b21b27070042e9a6494530856ef639
msgid ""
"First of all, we should know that Idris2 is not an optimizing compiler. "
"Currently its focus is only to compile dependently typed functional code "
"in a timely manner. Its main purpose is to check if the given program is "
"correct in a dependently typed setting and generate code in form of a "
"lambda-calculus like IR where higher-order functions are present. Idris "
"has 3 intermediate representations for code generation. At every level we"
" get a simpler representation, closer to machine code, but it should be "
"stressed that all the aggressive code optimizations should happen in the "
"custom back-ends. The quality and readability of the generated back-end "
"code is on the shoulders of the implementor of the back-end. Idris erases"
" type information, in the IRs as it compiles to scheme by default, and "
"there is no need to keep the type information around. With this in mind "
"let's answer the questions above."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:52
#: efbac1bd271449e3ab36b18fa7745cb6
msgid "The architecture of an Idris back-end"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:54
#: 2b29e789b26d47a68f69530c03a46849
msgid ""
"Idris compiles its dependently typed front-end language into a "
"representation which is called ``Compile.TT.Term`` . This data type has a"
" few constructors and it represents a dependently typed term. This "
"``Term`` is transformed to ``Core.CompileExpr.CExp`` which has more "
"constructors than ``Term`` and it is a very similar construct to a lambda"
" calculus with let bindings, structured and tagged data representation, "
"primitive operations, external operations, and case expressions. The "
"``CExp`` is closer in the compiling process to code generation."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:64
#: 0fc309b9f3874a3c861496fa78de618e
msgid ""
"The custom code generation back-end gets a context of definitions, a "
"template directory and an output directory, a ``Core.TT.ClosedTerm`` to "
"compile and a path to an output file."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:75
#: 6a60b0673f5e439e8f4f05c38d45ae23
msgid ""
"The ``ClosedTerm`` is a special ``Term`` where the list of the unbound "
"variables is empty. This technicality is not important for the code "
"generation of the custom back-end as the back-end needs to call the "
"``getCompileData`` function which produces the "
"``Compiler.Common.CompileData`` record."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:81
#: 82705227a8a94e8389aa8b70f4b9346e
msgid "The ``CompileData`` contains:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:83
#: 8beb91bea28740b981eed4d31ecb03ca
msgid "A main expression that will be the entry point for the program in ``CExp``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:84
#: 8186c8cda77247f7a751cf9542a6cf7c
msgid "A list of ``Core.CompileExpr.NamedDef``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:85
#: e663d12b477c464990a74dcada335deb
msgid "A list of lambda-lifted definitions ``Compiler.LambdaLift.LiftedDef``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:86
#: 13ffb6677a9b45cfae7585405914457e
msgid "A list of ``Compiler.ANF.ANFDef``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:87
#: 263f55b5ca984f6e83e2ca4db25accc8
msgid "A list of ``Compiler.VMCode.VMDef`` definitions"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:89
#: 1709fd7c9faf4945a2dde0fa1dc04fae
msgid "These lists contain:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:91
#: a4e923d353394149a4ed93e31b0bc359
msgid "Functions"
msgstr "函数"

#: ../../source/backends/backend-cookbook.rst:92
#: d99e979069e6459da4fce75b17bec53b
msgid "Top-level data definitions"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:93
#: fc04ca13ecf1448bb004d5c699d69932
msgid ""
"Runtime crashes which represent unfilled holes, explicit calls by the "
"user to ``idris_crash``, and unreachable branches in case trees"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:96
#: 2b4e3e0d1b97450dba2b5809cc634c61
msgid "Foreign call constructs"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:98
#: 995df888540146c9b04588cc65ef9f39
msgid ""
"The job of the custom code generation back-end is to transform one of the"
" phase encoded definitions (``NamedDef``, ``LiftedDef``, ``CExp``, "
"``ANF``, or ``VM``) into the intermediate representation of the code "
"generator. It can then run optimizations and generate some form of "
"executable. In summary, the code generator has to understand how to "
"represent tagged data and function applications (even if the function "
"application is partial), how to handle let expressions, how to implement "
"and invoke primitive operations, how to handle ``Erased`` arguments, and "
"how to do runtime crashes."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:107
#: 8affe1f9be6c4c25a77d2f90333722b4
msgid ""
"The implementor of the custom back-end should pick the closest Idris IR "
"which fits to the abstraction of the technology that is aimed to compile "
"to. The implementor should also consider how to transform the simple main"
" expression which is represented in CExp. As Idris does not focus on "
"memory management and threading. The custom back-end should model these "
"concepts for the program that is compiled. One possible approach is to "
"target a fairly high level language and reuse as much as possible from it"
" for the custom back-end. Another possibility is to implement a runtime "
"that is capable of handling memory management and threading."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:121
#: b2c4bfed0fe24a7ea6184a07a43af302
msgid ""
"Now lets turn our attention to the different intermediate representations"
" (IRs) that Idris provides. When the ``getCompiledData`` function is "
"invoked with the ``Phase`` parameter it will produce a ``CompileData`` "
"record, which will contain lists of top-level definitions that needs to "
"be compiled. These are:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:127
#: 74888a235a06459ab7ea2a011ddac442
msgid "``NamedDef``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:128
#: 6a0a03d1ab134eccbfb37bb4d1f6f383
msgid "``LiftedDef``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:129
#: c82dcccae54a492a8a876e48dbb7d8e9
msgid "``ANFDef``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:130
#: 4d37f7407810495487bb135bebe070c1
msgid "``VMDef``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:132
#: e8389e91630047fca07158e0704de640
msgid ""
"The question to answer here is: Which one should be picked? Which one "
"fits to the custom back-end?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:138
#: f66ac33fd4804cbd8e1e40c21805be24
msgid ""
"After one selects the IR to be used during code generation, the next "
"question to answer is how primitive types should be represented in the "
"back-end. Idris has the following primitive types:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:142
#: 38a3b83f4f6c40458dd316a03ba7eb5c
msgid "``Int``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:143
#: e64a1aa07d794cbba242b452da4eda82
msgid "``Integer`` (arbitrary precision)"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:144
#: b3c30f21ef8d476da3236843bd632fe7
msgid "``Bits(8/16/32/64)``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:145
#: 87698520af1749c08d0346dfe5db75e5
msgid "``Char``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:146
#: e6fb3319eb194baa90282bed4b350d45
msgid "``String``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:147
#: f13119de965341e093d63c4080400afb
msgid "``Double``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:148
#: 75c9802eb0d24a499b2ae159b6790fd4
msgid "``WorldVal`` (token for IO computations)"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:150
#: 41f041d91be848789a3b622a5ade5ca0
msgid ""
"And as Idris allows pattern matching on types all the primitive types "
"have their primitive counterpart for describing a type:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:153
#: a246a03e56414aa9b447b880ac6f8166
msgid "``IntType``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:154
#: a71e58dd36d94e889cdb771f966881a8
msgid "``IntegerType``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:155
#: 42bbeaa0aa134931a875fe934ac58b44
msgid "``Bits(8/16/32/64)Type``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:156
#: 230c887efeb64bae897be5f002391436
msgid "``StringType``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:157
#: 428ad2f7378747208597e7a0b26ccd8f
msgid "``CharType``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:158
#: de759abf3d0a42b1b655269813fcc8de
msgid "``DoubleType``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:159
#: d255bcafdba04c98b603fa3cd7b978df
msgid "``WorldType``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:161
#: 7dda023a576b4867b740743f65cb78ee
msgid ""
"The representation of these primitive types should be a well-thought out "
"design decision as it affects many parts of the code generation, such as "
"conversion from the back-end values when FFI is involved, big part of the"
" data during the runtime is represented in these forms. Representation of"
" primitive types affect the possible optimisation techniques, and they "
"also affect the memory management and garbage collection."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:168
#: 8818bbce42504bf3aaa8c64a2bc6f9ee
msgid "There are two special primitive types: String and World."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:170
#: 45e879e0ddbf440a94db0d0de5c591f2
msgid "**String**"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:172
#: 1c41668d59d24f609e35bfe5fe6cb3a2
msgid ""
"As its name suggest this type represent a string of characters. As "
"mentioned in `Primitive FFI Types "
"<https://idris2.readthedocs.io/en/latest/ffi/ffi.html#primitive-ffi-"
"types>`_, Strings are encoded in UTF-8."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:176
#: f1efe68798644eb5ae1148e4c2ebf327
msgid ""
"It is not always clear who is responsible for freeing up a ``String`` "
"created by a component other than the Idris runtime. Strings created in "
"Idris will always have value, unlike possible String representation of "
"the host technology, where for example NULL pointer can be a value, which"
" can not happen on the Idris side. This creates constraints on the "
"possible representations of the Strings in the custom back-end and "
"diverging from the Idris representation is not a good idea. The best "
"approach here is to build a conversion layer between the string "
"representation of the custom back-end and the runtime."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:185
#: 9a8bdc6a55314178a4e1249386aa271a
msgid "**World**"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:187
#: c2718d1749324090af6d2e41265a9785
msgid ""
"In pure functional programming, causality needs to be represented "
"whenever we want to maintain the order in which subexpressions are "
"executed. In Idris a token is used to chain IO function calls. This is an"
" abstract notion about the state of the world. For example this "
"information could be the information that the runtime needs for "
"bookkeeping of the running program."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:194
#: ce3cf3fe2413410e8d10e1a1efb18e83
msgid ""
"The ``WorldVal`` value in Idris programs is accessed via the ``primIO`` "
"construction which leads us to the ``PrimIO`` module. Let's see the "
"relevant snippets:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:209
#: c11f9e06893c4fb686416256b4bb2c5d
msgid ""
"The world value is referenced as ``%World`` in Idris. It is created by "
"the runtime when the program starts. Its content is changed by the custom"
" runtime. More precisely, the World is created when the ``WorldVal`` is "
"evaluated during the execution of the program. This can happen when the "
"program gets initialized or when an ``unsafePerformIO`` function is "
"executed."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:220
#: 8ddbedfa15a3447f9774d5ee610af9a2
msgid ""
"In Idris there are two different ways to define a data type: tagged "
"unions are introduced using the ``data`` keyword while structs are "
"declared via the ``record`` keyword. Declaring a ``record`` amounts to "
"defining a named collection of fields. Let's see examples for both:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:239
#: 6b283682cc554ebebe7898ded125ba77
msgid ""
"Idris offers not only algebraic data types but also indexed families. "
"These are tagged union where different constructors may have different "
"return types. Here is ``Vect`` an example of a data type which is an "
"indexed family corresponding to a linked-list whose length is known at "
"compile time. It has one index (of type ``Nat``) representing the length "
"of the list (the value of this index is therefore different for the "
"``[]`` and ``(::)`` constructors) and a parameter (of type ``Type``) "
"corresponding to the type of values stored in the list."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:254
#: 871e272308b64d4498a47f10b65cf7d3
msgid ""
"Both data and record are compiled to constructors in the intermediate "
"representations. Two examples of such Constructors are "
"``Core.CompileExpr.CExp.CCon`` and ``Core.CompileExpr.CDef.MkCon``."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:258
#: 3374b611bf764d1fafe5e5756f7bc9ca
msgid ""
"Compiling the ``Either`` data type will produce three constructor "
"definitions in the IR:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:261
#: 4140d4e566b140bdb90351c579426df2
msgid ""
"One for the ``Either`` type itself, with the arity of two. Arity tells "
"how many parameters of the constructor should have. Two is reasonable in "
"this case as the original Idris ``Either`` type has two parameters."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:265
#: b33ff45fa2ea4122b923defb89e873ed
msgid ""
"One for the ``Left`` constructor with arity of three. Three may be "
"surprising, as the constructor only has one argument in Idris, but we "
"should keep in mind the type parameters for the data type too."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:268
#: 64227f29ae5c47d691055fcad15bea9e
msgid "One for the ``Right`` constructor with arity of three."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:270
#: cc9931347a734260840f4691d78f433f
msgid ""
"In the IR constructors have unique names. For efficiency reasons, Idris "
"assigns a unique integer tag to each data constructors so that "
"constructor matching is reduced to comparisons of integers instead of "
"strings. In the ``Either`` example above ``Left`` gets tag 0 and "
"``Right`` gets tag 1."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:275
#: ef7b7619eb004ed2a82628aa7941c82e
msgid ""
"Constructors can be considered structured information: a name together "
"with parameters. The custom back-end needs to decide how to represent "
"such data. For example using ``Dict`` in Python, ``JSON`` in JavaScript, "
"etc. The most important aspect to consider is that these structured "
"values are heap related values, which should be created and stored "
"dynamically. If there is an easy way to map in the host technology, the "
"memory management for these values could be inherited. If not, then the "
"host technology is responsible for implementing an appropriate memory "
"management. For example ``RefC`` is a C backend that implements its own "
"memory management based on reference counting."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:290
#: f99bf192042441e782cd468bda270650
msgid ""
"Apart from the data constructors there are two special kind of values "
"present in the Idris IRs: type constructors and ``Erased``."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:294
#: 822e7d4b5c814be496ffe2bc8328e725
msgid "Type constructors"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:296
#: 2cfac3f3bd8142f290e50d001667540c
msgid ""
"Type and data constructors that are not relevant for the program's "
"runtime behaviour may be used at compile butand will be erased from the "
"intermediate representation."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:300
#: b444619dfb7d4a718e04acc6d4e635a7
msgid ""
"However some type constructors need to be kept around even at runtime "
"because pattern matching on types is allowed in Idris:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:309
#: a0a4417a35d14ac69ad601cf541be0bd
msgid ""
"Here we can pattern match on ``a`` and ensure that ``notId`` behaves "
"differently on ``Int`` than all the other types. This will generate an IR"
" that will contain a ``Case`` expression with two branches: one ``Alt`` "
"matching on the ``Int`` type constructor and a default for the "
"non-``Int`` matching part of the ``notId`` function."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:316
#: bde2c9c989c040e7a515e5dd1a27d40c
msgid ""
"This is not that special: ``Type`` is a bit like an infinite data type "
"that contains all of the types a user may ever declare or use. This can "
"be handled in the back-end and host language using the same mechanisms "
"that were mobilised to deal with data constructors. The reason for using "
"the same approach is that in dependently typed languages, the same "
"language is used to form both type and value level expressions. "
"Compilation of type level terms will be the same as that of value level "
"terms. This is one of the things that make dependently typed abstraction "
"elegant."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:326
#: 142f450d30a344098fa8ca51f8c9ce40
msgid "``Erased``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:328
#: 4fa2506095dd440cb905938a0fdfc246
msgid ""
"The other kind of special value is ``Erased``. This is generated by the "
"Idris compiler and part of the IR if the original value is only needed "
"during the type elaboration process. For example:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:342
#: 47a1878a0d374b7f9b770d652dbfa8d2
msgid ""
"Because ``prf`` has quantity ``0``, it is guaranteed to be erased during "
"compilation and thus not present at runtime. Therefore ``prf`` will be "
"represented as ``Erased`` in the IR. The custom back-end needs to "
"represent this value too as any other data value, as it could occur in "
"place of normal values. The simplest approach is to implement it as a "
"special data constructor and let the host technology provided "
"optimizations take care of its removal."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:353
#: c62f7ff7677d48d380ac865f140a3736
msgid ""
"Primitive operations are defined in the module ``Core.TT.PrimFn``. The "
"constructors of this data type represent the primitive operations that "
"the custom back-end needs to implement. These primitive operations can be"
" grouped as:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:358
#: 60e0738b649c46b7aa024df0cf118df4
msgid ""
"Arithmetic operations (``Add``, ``Sub``, ``Mul``, ``Div``, ``Mod``, "
"``Neg``)"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:359
#: ac1b4f642f684d63895406f5bc39d7b5
msgid "Bit operations (``ShiftL``, ``ShiftR``, ``BAnd``, ``BOr``, ``BXor``)"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:360
#: 3c01dadfc89a4925ab8adc3931f7ba4c
msgid "Comparison operations (``LT``, ``LTE``, ``EQ``, ``GTE``, ``GT``)"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:361
#: d4279cfacb4247b6a70508ca48b2812c
msgid ""
"String operations (``Length``, ``Head``, ``Tail``, ``Index``, ``Cons``, "
"``Append``, ``Reverse``, ``Substr``)"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:364
#: 7899b547167344eba1503b57f5f891db
msgid ""
"Double precision floating point operations (``Exp``, ``Log``, ``Sin``, "
"``Cos``, ``Tan``, ``ASin``, ``ACos``, ``ATan``, ``Sqrt``, ``Floor``, "
"``Ceiling``)"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:367
#: b312ca4d434f4a54949b29160f97e765
msgid "Casting of numeric and string values"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:368
#: fe794a5733e3433da9f6f0765e5e6322
msgid "An unsafe  cast operation ``BelieveMe``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:369
#: 929e3ec5f8c244e8b3e3022fdeb7a94e
msgid ""
"A ``Crash`` operation taking a type and a string and creating a value at "
"that type by raising an error."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:373
#: 3a9e74fbb2a7434aae73b5c946667410
msgid "BelieveMe"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:375
#: 469de419b62e42329ecf498abfefee01
msgid ""
"The primitive ``believe_me`` is an unsafe cast that allows users to "
"bypass the typechecker when they know something to be true even though it"
" cannot be proven."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:378
#: 59344b2ed0624c89a63985fad17a34ac
msgid ""
"For instance, assuming that Idris' primitives are correctly implemented, "
"it should be true that if a boolean equality test on two ``Int`` ``i`` "
"and ``j`` returns ``True`` then ``i`` and ``j`` are equal. Such a theorem"
" can be implemented by using ``believe_me`` to cast ``Refl`` (the "
"constructor for proofs of a propositional equality) from ``i === i`` to "
"``i === j``. In this case, it should be safe to implement."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:386
#: 66a0bcdd7e97472d9f9ea0306db52639
msgid "Boxing"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:388
#: 2832c08a4a97438dbc41f0b5a3ec74ec
msgid ""
"Idris assumes that the back-end representation of the data is not "
"strongly typed and that all the data type have the same kind of "
"representation. This could introduce a constraint on the representation "
"of the primitives and constructor represented data types. One possible "
"solution is that the custom back-end should represent primitive data "
"types the same way it does constructors, using special tags. This is "
"called boxing."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:396
#: 47bdb40643434868ba93ba6c15b06b4d
msgid "Official backends represent primitive data types as boxed ones."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:398
#: 183d5d483659412c921b454826afd434
msgid "RefC: Boxes the primitives, which makes them easy to put on the heap."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:399
#: 721a28c57889480a85fda72297ce9116
msgid "Scheme: Prints the values that are a ``Constant`` as Scheme literals."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:402
#: b6a0d57c49074cb6befd988043c7d7f6
msgid "How to compile top-level definitions?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:404
#: 55633c913dd54878b9191f64fc977d4b
msgid ""
"As mentioned earlier, Idris has 4 different IRs that are available in the"
" ``CompileData`` record: ``Named``, ``LambdaLifted``, ``ANF``, and "
"``VMDef``. When assembling the ``CompileData`` we have to tell the Idris "
"compiler which level we are interested in. The ``CompileData`` contains "
"lists of definitions that can be considered as top level definitions that"
" the custom back-end need to generate functions for."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:411
#: 1ef12e53d28145af8b6e9e718b9f62a2
msgid ""
"There are four types of top-level definitions that the code generation "
"back-end needs to support:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:414
#: 188ac92867464449a598187bd7ecb795
#, fuzzy
msgid "Function"
msgstr "函数"

#: ../../source/backends/backend-cookbook.rst:415
#: 7eae2d4f664e42138e7d94c10af7f956
msgid "Constructor"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:416
#: c34a25e839664c0cb9c201550b6fcd83
msgid "Foreign call"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:417
#: ccc278073df1455fa8d27f2ae3576bcb
msgid "Error"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:419
#: ae3ed9fe0e8b4a60b1f71af2d3a79abe
msgid "**Function** contains a lambda calculus like expression."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:421
#: 81288e07c25e4ef1a0a9ec2d5bacd19e
msgid ""
"**Constructor** represents a data or a type constructor, and it should be"
" implemented as a function creating the corresponding data structure in "
"the custom back-end."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:425
#: 217a0cf257a94fecb50f3c9b2ea685f7
msgid ""
"A top-level **foreign call** defines an entry point for calling functions"
" implemented outside the Idris program under compilation. The Foreign "
"construction contains a list of Strings which are the snippets defined by"
" the programmer, the type of the arguments and the return type of the "
"foreign function. The custom back-end should generate a wrapper function."
" More on this on `How to implement the Foreign Function Interface?`_"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:432
#: 9d010e51f14747febd8dab8bcb9aeea8
msgid ""
"A top-level **error** definition represents holes in Idris programs, uses"
" of ``idris_crash``, or unreachable branches in a case tree. Users may "
"want to execute incomplete programs for testing purposes which is fine as"
" long as we never actually need the value of any of the holes. Library "
"writers may want to raise an exception if an unrecoverable error has "
"happened. Finally, Idris compiles the unreachable branches of a case tree"
" to runtime error as it is dead code anyway."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:445
#: 3c3b4944a4f4420db55d1d345248341c
msgid ""
"The custom back-end should decide which intermediate representation is "
"used as a starting point. The result of the transformation should be "
"expressions and functions of the host technology."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:449
#: 67955913b5de4cc888d373a12b7a7675
msgid ""
"Definitions in ``ANF`` and ``Lifted`` are represented as a tree like "
"expression, where control flow is based on the ``Let`` and ``Case`` "
"expressions."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:453
#: 81c62449b8284769b708b20c45e5ba11
#, fuzzy
msgid "Case expressions"
msgstr "Case 表达式"

#: ../../source/backends/backend-cookbook.rst:455
#: 0dee6d29945a48fd9c31be48831854f6
msgid ""
"There are two types of case expressions, one for matching and branching "
"on primitive values such as ``Int``, and the second one is matching and "
"branching on constructor values. The two types of case expressions will "
"have two different representation for alternatives of the cases. These "
"are ``ConstCase`` (for matching on constant values) and ``ConCase`` (for "
"matching on constructors)."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:462
#: f14da13c569649419cacbbbaf6b8ed42
msgid ""
"Matching on constructors can be implemented as matching on their tags or,"
" less efficiently, as matching on the name of the constructor. In both "
"cases a match should bind the values of the constructor's arguments to "
"variables in the body of the matching branch. This can be implemented in "
"various ways depending on the host technology: switch expressions, case "
"with pattern matching, or if-then-else chains."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:469
#: b8dac1d98d30493582d473a2b06cb421
msgid ""
"When pattern matching binds variables, the number of arguments can be "
"different from the arity of the constructor defined in top-level "
"definitions and in ``GlobalDef``. This is because all the arguments are "
"kept around at typechecking time, but the code generator for the case "
"tree removes the ones which are marked as erased. The code generator of "
"the custom back-end also needs to remove the erased arguments in the "
"constructor implementation. In ``GlobalDef``, ``eraseArg`` contains this "
"information, which can be used to extract the number of arguments which "
"needs to be kept around."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:480
#: 7791593f97f7450b9086fefeeaa9c8a6
msgid "Creating values"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:482
#: c0b66a57fbaf43eda6efd05cb125c617
msgid "Values can be created in two ways."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:484
#: 451fb04134a94d758b808d1494bfb598
msgid ""
"If the value is a primitive value, it will be handed to the back-end as a"
" ``PrimVal``. It should be compiled to a constant in the host language "
"following the  design decisions made in the 'How to represent primitive "
"values?' section."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:489
#: 10d0c93e8ce14499be1e389cc802d323
msgid ""
"If it is a structured value (i.e. a ``Con``) it should be compiled to a "
"function in the host language which creates a dynamic value. Design "
"decisions made for 'How to represent constructor values?' is going to "
"have effect here."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:494
#: 812bebd453f847018592c7780135db65
msgid "Function calls"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:496
#: 860a14b330e542108909657aa77ec630
msgid ""
"There are four types of function calls: - Saturated function calls (all "
"the arguments are there) - Under-applied function calls (some arguments "
"are missing) - Primitive function calls (necessarily saturated, "
"``PrimFn`` constructor) - Foreign Function calls (referred to by its "
"name)"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:502
#: 0e4aa6a732564ba5851660f6d8a44ee9
msgid ""
"The ``ANF`` and ``Lifted`` intermediate representations support under-"
"applied function calls (using the ``UnderApp`` constructor in both IR). "
"The custom back-end needs to support partial application of functions and"
" creating closures in the host technology. This is not a problem with "
"back-ends like Scheme where we get the partial application of a function "
"for free. But if the host language does not have this tool in its "
"toolbox, the custom back-end needs to simulate closures. One possible "
"solution is to manufacture a closure as a special object storing the "
"function and the values it is currently applied to and wait until all the"
" necessary arguments have been received before evaluating it. The same "
"approach is needed if the ``VMCode`` IR was chosen for code generation."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:516
#: 0ac5de0346dd4436973e4b376f67dc44
msgid "Let bindings"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:518
#: a6f876e4847243488e43c8c5bd881e6f
msgid ""
"Both the ``ANF`` and ``Lifted`` intermediate representations have a "
"``Let`` construct that lets users assign values to local variables. These"
" two IRs differ in their representation of bound variables."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:522
#: 5c8872d1abcd460186f1f91a72205715
msgid ""
"``Lifted`` is a type family indexed by the ``List Name`` of local "
"variables in scope. A variable is represented using ``LLocal``, a "
"constructor that stores a ``Nat`` together with a proof that it points to"
" a valid name in the local scope."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:527
#: d208c20b4f8244cfb4b028ab648cd716
msgid ""
"``ANF`` is a lower level representation where this kind of guarantees are"
" not present anymore. A local variable is represented using the ``AV`` "
"constructor which stores an ``AVar`` whose definition we include below. "
"The ``ALocal`` constructor stores an ``Int`` that corresponds to the "
"``Nat`` we would have seen in ``Lifted``. The ``ANull`` constructor "
"refers to an erased variable and its representation in the host language "
"will depend on the design choices made in the 'How to represent "
"``Erased`` values' section."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:542
#: d5f1439536854d43bcdd702a676f0fa0
msgid "VMDef specificities"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:544
#: cd331bfdb21f435c9cf2e1f19c1b7d24
msgid ""
"``VMDef`` is meant to be the closest IR to machine code. In ``VMDef``, "
"all the definitions have been compiled to instructions for a small "
"virtual machine with registers and closures."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:548
#: 7c1a5e0b94c04778a23d1f75d60f3a31
msgid ""
"Instead of ``Let`` expressions, there only are ``ASSIGN`` statements at "
"this level."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:551
#: 6dce022abc5540d39146035809ff3ae4
msgid ""
"Instead of ``Case`` expressions binding variables when they successfully "
"match on a data constructor, ``CASE`` picks a branch based on the "
"constructor itself. An extra operation called ``PROJECT`` is introduced "
"to explicitly extract a constructor's argument based on their position."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:556
#: 921f865d3c46467f8d3045c1960a7b51
msgid ""
"There are no ``App`` or ``UnderApp``. Both are replaced by ``APPLY`` "
"which applies only one value and creates a closure from the application. "
"For erased values the operation ``NULL`` assigns an empty/null value for "
"the register."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:561
#: be9c40f501a24287a1595c84f2f71352
msgid "How to implement the Foreign Function Interface?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:563
#: 3c61f42140684b91a9a03f14ac0f2c30
msgid ""
"The Foreign Function Interface (FFI) plays a big role in running Idris "
"programs. The primitive operations which are mentioned above are "
"functions for manipulating values and those functions aren't meant for "
"complex interaction with the runtime system. Many of the primitive types "
"can be thought of as abstract types provided via ``external`` and foreign"
" functions to manipulate them."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:570
#: 6c9bddad5d86452dbb6f84f23dedde1a
msgid ""
"The responsibility of the custom back-end and the host technology is to "
"represent these computations the operationally correct way. The design "
"decisions with respect to representing primitive types in the host "
"technology will inevitably have effects on the design of the FFI."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:576
#: e8a987a4156f40b391b32d849c580b29
msgid "Foreign Types"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:578
#: ad7e2f99cdcc4421af23a382bffefdc3
msgid ""
"Originally Idris had an official back-end implementation in C. Even "
"though this has changed, the names in the types for the FFI kept their C "
"prefix. The ``Core.CompileExpr.CFType`` contains the following "
"definitions, many of them one-to-one mapping from the corresponding "
"primitive type, but some of them needs explanation."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:584
#: 2496ddd9f91d4374bd9856d70bc531da
msgid "The foreign types are:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:586
#: 89b8ddbc1bba4c3dab15286344859420
msgid "``CFUnit``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:587
#: fac50015a0614898b008b53d88294feb
msgid "``CFInt``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:588
#: 228a508642224a8a9357e4da67f7c2fd
msgid "``CFUnsigned(8/16/32/64)``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:589
#: c04bf47224ca4124b2dd2b2cbbd8e170
msgid "``CFString``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:590
#: 7350a735a6d8433cb9a382a333ea827b
msgid "``CFDouble``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:591
#: 77ab845aa7a94571a509078e0f063fdd
msgid "``CFChar``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:592
#: b6e925777487486692809a762a9dcada
msgid ""
"``CFFun`` of type  ``CFType -> CFType -> CFType`` Callbacks can be "
"registered in the host technology via parameters that have CFFun type. "
"The back-end should be able to handle functions that are defined in Idris"
" side and compiled to the host technology. If the custom back-end "
"supports higher order functions then it should be used to implement the "
"support for this kind of FFI type."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:598
#: 18cec4ea990f4f0d995856e35338fd76
msgid ""
"``CFIORes`` of type ``CFType -> CFType`` Any ``PrimIO`` defined "
"computation will have this extra layer. Pure functions shouldn't have any"
" observable IO effect on the program state in the host technology "
"implemented runtime. NOTE: ``IORes`` is also used when callback functions"
" are registered in the host technology."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:604
#: b912a6bde5cd409ab8d2f280c58b64e8
msgid ""
"``CFWorld`` Represents the current state of the world. This should refer "
"to a token that is passed around between function calls. The "
"implementation of the World value should contain back-end specific values"
" and information about the state of the Idris runtime."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:609
#: baed2976fdf14688858b7c1174ec2a36
msgid ""
"``CFStruct`` of type ``String -> List (String, CFType) -> CFType`` is the"
" foreign type associated with the ``System.FFI.Struct``. It represents a "
"C like structure in the custom back-end. ``prim__getField`` and "
"``prim__setField`` primitives should be implemented to support this "
"CFType."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:614
#: ddd2d11a902541a98548c8898249395e
msgid ""
"``CFUser`` of type ``Name -> List CFType -> CFType`` Types defined with "
"[external] are represented with ``CFUser``. For example ``data MyType : "
"Type where [external]`` will be represented as ``CFUser Module.MyType "
"[]``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:618
#: 2906ea1bfb1e48a0a32ee6e08de3c3ec
msgid ""
"``CFBuffer`` Foreign type defined for ``Data.Buffer``. Although this is "
"an external type, Idris builds on a random access buffer."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:621
#: 9d8d365ee1fd472daa9aa6403ee6d59b
msgid ""
"``CFPtr`` The ``Ptr t`` and ``AnyPtr`` are compiled to ``CFPtr`` Any "
"complex structured data that can not be represented as a simple primitive"
" can use this CFPtr to keep track where the value is used. In Idris ``Ptr"
" t`` is defined as external type."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:625
#: dedf114af9024ea690f6c499f2455de6
msgid ""
"``CFGCPtr`` The ``GCPtr t`` and ``GCAnyPtr`` are compiled to ``CFGCPtr``."
" ``GCPtr`` is inferred from a Ptr value calling the ``onCollect`` "
"function and has a special property. The ``onCollect`` attaches a "
"finalizer for the pointer which should run when the pointer is freed."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:631
#: baccb25f7eb742099843285be2d2126f
msgid "Examples"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:633
#: d30bcefc83bd4bf29feea937012e9bd9
#, python-format
msgid ""
"Let's step back and look into how this is represented at the Idris source"
" level. The simplest form of a definition involving the FFI a function "
"definition with a ``%foreign`` pragma. The pragma is passed a list of "
"strings corresponding to a mapping from backends to names for the foreign"
" calls. For instance:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:643
#: b1e9b5a0854a4946a96b238784f28177
msgid ""
"this function should be translated by the C back end as a call to the "
"``add`` function defined in the ``smallc.c`` file. In the FFI, ``Int`` is"
" translated to ``CFInt``. The back-end assumes that the data "
"representation specified in the library file correspond to that of normal"
" Idris values."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:648
#: f0012a0896e242a8bed8f042953e9486
msgid "We can also define ``external`` types like in the following examples:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:657
#: f9f2b25c96024c50bd386c047591aa95
msgid ""
"Here ``ThreadID`` is defined as an external type and this type will be "
"represented as ``CFUser \"ThreadID\" []`` internally. The value which is "
"created by the scheme runtime will be considered as a black box."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:661
#: 2cea2102e5af4d07af1cf7a397e44633
msgid ""
"The type of ``prim__fork``, once translated as a foreign type, is "
"``[%World -> IORes Unit, %World] -> IORes Main.ThreadID`` Here we see "
"that the ``%World`` is added to the IO computations. The ``%World`` "
"parameter is always the last in the argument list."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:666
#: 39fd25bea293407da47574dcd640d877
#, python-format
msgid ""
"For the FFI functions, the type information and the user defined string "
"can be found in the top-level definitions. The custom back-end should use"
" the definitions to generate wrapper code, which should convert the types"
" that are described by the ``CFType`` to the types that the function in "
"the ``%foreign`` directive needs.."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:675
#: 6d576a54185d439c84ac83c2a1540315
msgid ""
"The Idris compiler generates intermediate files for modules, the content "
"of the files are neither part of ``Lifted``, ``ANF``, nor ``VMCode``. "
"Because of this, when the compilation pipeline enters the stage of code "
"generation, all the information will be in one instance of the "
"``CompileData`` record and the custom code generator back-end can process"
" them as it would see the whole program."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:682
#: 109d829dd7b24c97a16c41fa5f8d0b3b
msgid ""
"The custom back-end has the option to introduce some hierarchy for the "
"functions in different namespaces and organize some module structure to "
"let the host technology process the bits and pieces in different sized "
"chunks. However, this feature is not in the scope of the Idris compiler."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:687
#: 98adb8420dcb4ef6a6684a3297d76293
msgid ""
"It is worth noting that modules can be mutually recursive in Idris. So a "
"direct compilation of Idris modules to modules in the host language may "
"be unsuccessful."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:694
#: 8d4224fd0d414dc89ffc77115b08eafa
msgid ""
"A possible motivation for implementing a custom back-end for Idris is to "
"generate code that is meant to be used in a larger project. This project "
"may be bound to another language that has many useful librarie  but could"
" benefit from relying on Idris' strong type system in places."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:699
#: 12d53498e8784fc89e060000333ac10a
msgid ""
"When writing a code generator for this purpose, the interoperability of "
"the host technology and Idris based on the Foreign Interface can be "
"inconvenient. In this situation, the need to embed code of the host "
"technology arises naturally. Elaboration can be an answer for that."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:704
#: 84b464b943424a8b800a6057823c2b20
msgid ""
"Elaboration is a typechecking time code generation technique. It relies "
"on the ``Elab`` monad to write scripts that can interact with the "
"typechecking machinery to generate Idris code in ``Core.TT``."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:708
#: 5ece00a8ae084c5e9dce7bbe1d9b8f15
msgid ""
"When code snippets need to be embedded a custom library should be "
"provided with the custom back-end to turn the valid code snippets into "
"their representation in ``Core.TT``."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:715
#: c17c82ad78aa4f0493e82592b1b8a6a3
msgid ""
"As a summary, a custom back-end for the Idris compiler should create an "
"environment in the host technology that is able to run Idris programs. As"
" Idris is part of the family of functional programming languages, its "
"computation model is based on graph reduction. Programs represented as "
"simple graphs in the memory are based on the closure creation mechanism "
"during evaluation. Closure creation exist even on the lowest levels of "
"IRs. For that reason any runtime in any host technology needs to support "
"some kind of representation of closures and be able to store them on the "
"heap, thus the responsibility of memory management falls on the lap of "
"the implementor of the custom back-end. If the host technology has memory"
" management, the problem is not difficult. It is also likely that storing"
" closures can be easily implemented via the tools of the host technology."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:727
#: 65ebce828a324a9aa130520b3ace81c1
msgid ""
"Although it is not clear how much functionality a back-end should "
"support. Tools from the Scheme back-end are brought into the Idris world "
"via external types and primitive operations around them. This is a good "
"practice and gives the community the ability to focus on the "
"implementation of a quick compiler for a dependently typed language. One "
"of these hidden features is the concurrency primitives. These are part of"
" the different libraries that could be part of the compiler or part of "
"the contribution package. If the threading model is different for the "
"host technology that the Idris default back-end inherits currently from "
"the Scheme technology it could be a bigger piece of work."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:737
#: d16d3fe5b5c44a17ab1cb2b844979d2d
msgid ""
"IO in Idris is implemented using an abstract ``%World`` value, which "
"serves as token for functions that operate interactively with the World "
"through simple calls to the underlying runtime system. The entry point of"
" the program is the main function, which has the type of the IO unit, "
"such as ``main : IO ()``. This means that every program which runs, "
"starts its part of some IO computation. Under the hood this is "
"implemented via the creation of the ``%World`` abstract value, and "
"invoking the main function, which is compiled to pass the abstract %World"
" value for IO related foreign or external operations."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:746
#: 6401fba1c4e34bad81f845db23fb9777
msgid ""
"There is an operation called ``unsafePerformIO`` in the ``PrimIO`` "
"module. The type signature of ``unsafePerformIO`` tells us that it is "
"capable of evaluating an ``IO`` computation in a pure context. Under the "
"hood it is run in exactly the same way the ``main`` function is. It "
"manufactures a fresh ``%World`` token and passes it to the ``IO`` "
"computations. This leads to a design decision: How to represent the state"
" of the World, and how to represent the world that is instantiated for "
"the sake of the ``unsafePerformIO`` operation via the "
"``unsafeCreateWorld``? Both the mechanisms of ``main`` and "
"``unsafeCreateWorld`` use the ``%MkWorld`` constructor, which will be "
"compiled to ``WorldVal`` and its type to ``WorldType``, which means the "
"implementation of the runtime is responsible for creating the abstraction"
" around the World. Implementation of an abstract World value could be "
"based on a singleton pattern, where we can have just one world, or we "
"could have more than one world, resulting in parallel universes for "
"``unsafePerformIO``."
msgstr ""
