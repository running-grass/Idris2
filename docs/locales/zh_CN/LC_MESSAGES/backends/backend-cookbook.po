# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 09:10+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/backends/backend-cookbook.rst:2
#: 77b5a612c2a4434098aa6df7ce9e76eb
msgid "Custom backend cookbook"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:4
#: 1f205c306b2243929fbe494aac2f5dee
msgid ""
"This document addresses the details on how to implement a custom code "
"generation backend for the Idris compiler."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:7
#: d67c14f0e25147be8423d2e75e3246ba
msgid ""
"This part has no insights about how to implement the dependently typed "
"bits. For that part of the compiler Edwin Brady gave lectures at SPLV20_ "
"which are available online."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:11
#: d3bdd9407d9640eeb13b4b1f7bbd4cad
msgid ""
"The architecture of the Idris2 compiler makes it easy to implement a "
"custom code generation back-end."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:14
#: 581c7dffc81749f69762829f25966c54
msgid ""
"The way to extend Idris with new back-ends is to use it as a library. The"
" module ``Idris.Driver`` exports the function ``mainWithCodegens``, that "
"takes a list of ``(String, Codegen)``, starting idris with these codegens"
" in addition to the built-in ones. The first codegen in the list will be "
"set as the default codegen."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:20
#: feab668f1c3e49078719e62a725b979e
msgid ""
"Anyone who is interested in implementing a custom back-end needs to "
"answer the following questions:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:23
#: ../../source/backends/backend-cookbook.rst:119
#: 147dd9d2131541e291aabe29714d20bd 8325c33d90af498b9f0123eab64c9534
msgid ""
"Which Intermediate Representation (IR) should be consumed by the custom "
"back-end?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:24
#: ../../source/backends/backend-cookbook.rst:136
#: 3a84efb4e7cf4912b29ca3b292d03c5b c990287bd9c74037a0dc0f5ea30aa794
msgid ""
"How to represent primitive values defined by the ``Core.TT.Constant`` "
"type?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:25
#: ../../source/backends/backend-cookbook.rst:218
#: 0560da610fe5473fa5b16ff52a082b2e df03672d5cf24eacb8e0dca60d1629ca
msgid "How to represent Algebraic Data Types?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:26
#: ../../source/backends/backend-cookbook.rst:288
#: 21ae6c3f81ae494b8c9fae1e6069e60c 596251abbada44e19a66d6cb2cbbb46e
msgid "How to implement special values?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:27
#: ../../source/backends/backend-cookbook.rst:351
#: 4cb08b75390847f4bf330ae7d24b420f b9abe6814ee44e07a6f61d062563093d
msgid "How to implement primitive operations?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:28
#: ../../source/backends/backend-cookbook.rst:443
#: 17607a546ea84b4c8060004c935d47ae 4c6632650fb342f5833de5af373b85eb
msgid "How to compile IR expressions?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:29
#: 9e66d3b140c346248a9f2fbe9e218c88
msgid "How to compile Definitions?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:30
#: 86b2c6f6fa654a03b44d507014ce8638
msgid "How to implement Foreign Function Interface?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:31
#: ../../source/backends/backend-cookbook.rst:673
#: 6d0b2cd5073049a6b333c8344a2c7f5f 92a96861a01342b4ae16904c16a34c82
msgid "How to compile modules?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:32
#: ../../source/backends/backend-cookbook.rst:692
#: 718569fe5b284cf6b770367f2e02fb80 78b24378013b4203a55fefdbb51af144
msgid "How to embed code snippets?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:33
#: ../../source/backends/backend-cookbook.rst:713
#: 8ce97da70ae842cdb653becd76e1516e c1812a450c0545558090ddfe8148743c
msgid "What should the runtime system support?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:35
#: d83d51aa19b340278b501684618fd2e6
msgid ""
"First of all, we should know that Idris2 is not an optimizing compiler. "
"Currently its focus is only to compile dependently typed functional code "
"in a timely manner. Its main purpose is to check if the given program is "
"correct in a dependently typed setting and generate code in form of a "
"lambda-calculus like IR where higher-order functions are present. Idris "
"has 3 intermediate representations for code generation. At every level we"
" get a simpler representation, closer to machine code, but it should be "
"stressed that all the aggressive code optimizations should happen in the "
"custom back-ends. The quality and readability of the generated back-end "
"code is on the shoulders of the implementor of the back-end. Idris erases"
" type information, in the IRs as it compiles to scheme by default, and "
"there is no need to keep the type information around. With this in mind "
"let's answer the questions above."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:52
#: 8df5d9b0c18148cda230db3bede4a3f0
msgid "The architecture of an Idris back-end"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:54
#: a84b14e5b7084216864bbdc02db637f4
msgid ""
"Idris compiles its dependently typed front-end language into a "
"representation which is called ``Compile.TT.Term`` . This data type has a"
" few constructors and it represents a dependently typed term. This "
"``Term`` is transformed to ``Core.CompileExpr.CExp`` which has more "
"constructors than ``Term`` and it is a very similar construct to a lambda"
" calculus with let bindings, structured and tagged data representation, "
"primitive operations, external operations, and case expressions. The "
"``CExp`` is closer in the compiling process to code generation."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:64
#: f990c814d2fc4303b01da6c9c1c050f0
msgid ""
"The custom code generation back-end gets a context of definitions, a "
"template directory and an output directory, a ``Core.TT.ClosedTerm`` to "
"compile and a path to an output file."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:75
#: 5b2db04fbe364987966dd24e7765b3e1
msgid ""
"The ``ClosedTerm`` is a special ``Term`` where the list of the unbound "
"variables is empty. This technicality is not important for the code "
"generation of the custom back-end as the back-end needs to call the "
"``getCompileData`` function which produces the "
"``Compiler.Common.CompileData`` record."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:81
#: 447f49027df44c29bedcfa462428910a
msgid "The ``CompileData`` contains:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:83
#: 898d8123775c478f8fcd7c094ad7d0cf
msgid "A main expression that will be the entry point for the program in ``CExp``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:84
#: 97bfd306457841bfa4afad0775a047f5
msgid "A list of ``Core.CompileExpr.NamedDef``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:85
#: c3322336e1b748b3bf363917a0268c49
msgid "A list of lambda-lifted definitions ``Compiler.LambdaLift.LiftedDef``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:86
#: 441cd60c63af4c5688d41cc9421be22c
msgid "A list of ``Compiler.ANF.ANFDef``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:87
#: 7cb37eb92ede47cd9dcfeb0fa080d879
msgid "A list of ``Compiler.VMCode.VMDef`` definitions"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:89
#: 7f393dbc1ac84bb59ae0a4c282a262a1
msgid "These lists contain:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:91
#: b5a8d1b0729840649742d33ce2eaeaa7
msgid "Functions"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:92
#: ca72e0e7728d4646a281167cd2aec8b7
msgid "Top-level data definitions"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:93
#: cd59c735df674261a093dba53fe88c63
msgid ""
"Runtime crashes which represent unfilled holes, explicit calls by the "
"user to ``idris_crash``, and unreachable branches in case trees"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:96
#: c85fa66f25804b93911d6edfbf31d18d
msgid "Foreign call constructs"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:98
#: bb29363d93d042108c6ccb0d358200b3
msgid ""
"The job of the custom code generation back-end is to transform one of the"
" phase encoded definitions (``NamedDef``, ``LiftedDef``, ``CExp``, "
"``ANF``, or ``VM``) into the intermediate representation of the code "
"generator. It can then run optimizations and generate some form of "
"executable. In summary, the code generator has to understand how to "
"represent tagged data and function applications (even if the function "
"application is partial), how to handle let expressions, how to implement "
"and invoke primitive operations, how to handle ``Erased`` arguments, and "
"how to do runtime crashes."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:107
#: 592f8ee12d2b4f57ab22c78b55602d07
msgid ""
"The implementor of the custom back-end should pick the closest Idris IR "
"which fits to the abstraction of the technology that is aimed to compile "
"to. The implementor should also consider how to transform the simple main"
" expression which is represented in CExp. As Idris does not focus on "
"memory management and threading. The custom back-end should model these "
"concepts for the program that is compiled. One possible approach is to "
"target a fairly high level language and reuse as much as possible from it"
" for the custom back-end. Another possibility is to implement a runtime "
"that is capable of handling memory management and threading."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:121
#: e03391975b074e9686b2f3787b1f4845
msgid ""
"Now lets turn our attention to the different intermediate representations"
" (IRs) that Idris provides. When the ``getCompiledData`` function is "
"invoked with the ``Phase`` parameter it will produce a ``CompileData`` "
"record, which will contain lists of top-level definitions that needs to "
"be compiled. These are:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:127
#: 636aeb0b35a748748737d2334943e141
msgid "``NamedDef``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:128
#: 5f37ccb8dac34a2b971bb20f851a045b
msgid "``LiftedDef``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:129
#: 611bae42fe1a4c14b20729327d0c08ec
msgid "``ANFDef``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:130
#: b20b0d55e1224053a1e7f7909a0f4ee5
msgid "``VMDef``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:132
#: b818a36659e247b4977d44bbe2ba6ae7
msgid ""
"The question to answer here is: Which one should be picked? Which one "
"fits to the custom back-end?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:138
#: 417f0746e81443f0b378a41126a690b5
msgid ""
"After one selects the IR to be used during code generation, the next "
"question to answer is how primitive types should be represented in the "
"back-end. Idris has the following primitive types:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:142
#: e7016540e29142f7aef05de32266865d
msgid "``Int``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:143
#: 2e34c075722444109441275e3bdae6e2
msgid "``Integer`` (arbitrary precision)"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:144
#: bf4d9c5df0f44104a8b5b68ca52839a1
msgid "``Bits(8/16/32/64)``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:145
#: 311ed83a2e4548d1b80275068c69fe23
msgid "``Char``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:146
#: 785cb1e7bcb24e93a2b9826e368357b7
msgid "``String``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:147
#: d8ceb502f01a4bd3a60d877858a745f4
msgid "``Double``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:148
#: 7c81bebf391c447e8f731ef781c8e423
msgid "``WorldVal`` (token for IO computations)"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:150
#: fc8656934cb947db8a1b3dda06a76dd7
msgid ""
"And as Idris allows pattern matching on types all the primitive types "
"have their primitive counterpart for describing a type:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:153
#: efe6bc62989a44a9b7e15e32e36cf61b
msgid "``IntType``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:154
#: 9d215d4298af4448bf0e2b0d7ff402d4
msgid "``IntegerType``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:155
#: 3af6534bd637488d8d9e2fff052be38f
msgid "``Bits(8/16/32/64)Type``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:156
#: 408b2ce23124408d823fdd50cfcb65fc
msgid "``StringType``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:157
#: 8cbc183f51094b26b67efd3675e86ed4
msgid "``CharType``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:158
#: 4d41ba1e20f34db5a266d48923fe5dcb
msgid "``DoubleType``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:159
#: eed5468c77b24496a7afb8a56d8f918e
msgid "``WorldType``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:161
#: 8113af58241c431b8ec4022bde47f7d2
msgid ""
"The representation of these primitive types should be a well-thought out "
"design decision as it affects many parts of the code generation, such as "
"conversion from the back-end values when FFI is involved, big part of the"
" data during the runtime is represented in these forms. Representation of"
" primitive types affect the possible optimisation techniques, and they "
"also affect the memory management and garbage collection."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:168
#: 46a92f46377c486bab8e78231b71d43d
msgid "There are two special primitive types: String and World."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:170
#: 665531c8866c4dbfb34543a2c0da0e2d
msgid "**String**"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:172
#: 332f28274fe043fda0693aa0f982d0a1
msgid ""
"As its name suggest this type represent a string of characters. As "
"mentioned in `Primitive FFI Types "
"<https://idris2.readthedocs.io/en/latest/ffi/ffi.html#primitive-ffi-"
"types>`_, Strings are encoded in UTF-8."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:176
#: 18072e7dbdd245228fc79fc16ca5988e
msgid ""
"It is not always clear who is responsible for freeing up a ``String`` "
"created by a component other than the Idris runtime. Strings created in "
"Idris will always have value, unlike possible String representation of "
"the host technology, where for example NULL pointer can be a value, which"
" can not happen on the Idris side. This creates constraints on the "
"possible representations of the Strings in the custom back-end and "
"diverging from the Idris representation is not a good idea. The best "
"approach here is to build a conversion layer between the string "
"representation of the custom back-end and the runtime."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:185
#: f77da0d7e52847d08e20041664f3e660
msgid "**World**"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:187
#: 8000ac9c88554e3584ecb130c54f51f4
msgid ""
"In pure functional programming, causality needs to be represented "
"whenever we want to maintain the order in which subexpressions are "
"executed. In Idris a token is used to chain IO function calls. This is an"
" abstract notion about the state of the world. For example this "
"information could be the information that the runtime needs for "
"bookkeeping of the running program."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:194
#: b5d5bbab7ba949b880a030824296c900
msgid ""
"The ``WorldVal`` value in Idris programs is accessed via the ``primIO`` "
"construction which leads us to the ``PrimIO`` module. Let's see the "
"relevant snippets:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:209
#: 8af6804a6aeb46d19bae9aeae89cca23
msgid ""
"The world value is referenced as ``%World`` in Idris. It is created by "
"the runtime when the program starts. Its content is changed by the custom"
" runtime. More precisely, the World is created when the ``WorldVal`` is "
"evaluated during the execution of the program. This can happen when the "
"program gets initialized or when an ``unsafePerformIO`` function is "
"executed."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:220
#: e8e5fbdf7ada455699e608088da44ab9
msgid ""
"In Idris there are two different ways to define a data type: tagged "
"unions are introduced using the ``data`` keyword while structs are "
"declared via the ``record`` keyword. Declaring a ``record`` amounts to "
"defining a named collection of fields. Let's see examples for both:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:239
#: 2d7a44ab896a4af0a44a63420557e6b4
msgid ""
"Idris offers not only algebraic data types but also indexed families. "
"These are tagged union where different constructors may have different "
"return types. Here is ``Vect`` an example of a data type which is an "
"indexed family corresponding to a linked-list whose length is known at "
"compile time. It has one index (of type ``Nat``) representing the length "
"of the list (the value of this index is therefore different for the "
"``[]`` and ``(::)`` constructors) and a parameter (of type ``Type``) "
"corresponding to the type of values stored in the list."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:254
#: 5f0db4ca8f36497e9580e7456432aa6b
msgid ""
"Both data and record are compiled to constructors in the intermediate "
"representations. Two examples of such Constructors are "
"``Core.CompileExpr.CExp.CCon`` and ``Core.CompileExpr.CDef.MkCon``."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:258
#: c96ca31117b94675ab439d5c7a72981b
msgid ""
"Compiling the ``Either`` data type will produce three constructor "
"definitions in the IR:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:261
#: 15ccf4238ca34267bd9e18cd9ed63271
msgid ""
"One for the ``Either`` type itself, with the arity of two. Arity tells "
"how many parameters of the constructor should have. Two is reasonable in "
"this case as the original Idris ``Either`` type has two parameters."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:265
#: 436e58dacd5241f8a7f943cdf810d2c0
msgid ""
"One for the ``Left`` constructor with arity of three. Three may be "
"surprising, as the constructor only has one argument in Idris, but we "
"should keep in mind the type parameters for the data type too."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:268
#: 09a370f22ffd4399b6c9d85fb1180084
msgid "One for the ``Right`` constructor with arity of three."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:270
#: b6c776b6421441beb3021b37223bbceb
msgid ""
"In the IR constructors have unique names. For efficiency reasons, Idris "
"assigns a unique integer tag to each data constructors so that "
"constructor matching is reduced to comparisons of integers instead of "
"strings. In the ``Either`` example above ``Left`` gets tag 0 and "
"``Right`` gets tag 1."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:275
#: 7f6b29897f024c3cb47f97d682d52e08
msgid ""
"Constructors can be considered structured information: a name together "
"with parameters. The custom back-end needs to decide how to represent "
"such data. For example using ``Dict`` in Python, ``JSON`` in JavaScript, "
"etc. The most important aspect to consider is that these structured "
"values are heap related values, which should be created and stored "
"dynamically. If there is an easy way to map in the host technology, the "
"memory management for these values could be inherited. If not, then the "
"host technology is responsible for implementing an appropriate memory "
"management. For example ``RefC`` is a C backend that implements its own "
"memory management based on reference counting."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:290
#: 15ef43b03cda440bbfe6952ecab2da6f
msgid ""
"Apart from the data constructors there are two special kind of values "
"present in the Idris IRs: type constructors and ``Erased``."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:294
#: 9cbffcd78f0e461ea1d2f6e4786c3f4d
msgid "Type constructors"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:296
#: d93ce6dea1504315a6a17416c7b4ebf0
msgid ""
"Type and data constructors that are not relevant for the program's "
"runtime behaviour may be used at compile butand will be erased from the "
"intermediate representation."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:300
#: ed0d9df067124de6b07a0da5f64d3207
msgid ""
"However some type constructors need to be kept around even at runtime "
"because pattern matching on types is allowed in Idris:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:309
#: 256f77191bd94a29b84967afeda4e97c
msgid ""
"Here we can pattern match on ``a`` and ensure that ``notId`` behaves "
"differently on ``Int`` than all the other types. This will generate an IR"
" that will contain a ``Case`` expression with two branches: one ``Alt`` "
"matching on the ``Int`` type constructor and a default for the "
"non-``Int`` matching part of the ``notId`` function."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:316
#: 2ce6c400b5824108a881d459cb605495
msgid ""
"This is not that special: ``Type`` is a bit like an infinite data type "
"that contains all of the types a user may ever declare or use. This can "
"be handled in the back-end and host language using the same mechanisms "
"that were mobilised to deal with data constructors. The reason for using "
"the same approach is that in dependently typed languages, the same "
"language is used to form both type and value level expressions. "
"Compilation of type level terms will be the same as that of value level "
"terms. This is one of the things that make dependently typed abstraction "
"elegant."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:326
#: 9b75092c072b41fda9b2dc40d6cd4bcf
msgid "``Erased``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:328
#: 8194af4841814e299ec0881adebb2859
msgid ""
"The other kind of special value is ``Erased``. This is generated by the "
"Idris compiler and part of the IR if the original value is only needed "
"during the type elaboration process. For example:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:342
#: 72d56b10e708408cab797275a621e9a3
msgid ""
"Because ``prf`` has quantity ``0``, it is guaranteed to be erased during "
"compilation and thus not present at runtime. Therefore ``prf`` will be "
"represented as ``Erased`` in the IR. The custom back-end needs to "
"represent this value too as any other data value, as it could occur in "
"place of normal values. The simplest approach is to implement it as a "
"special data constructor and let the host technology provided "
"optimizations take care of its removal."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:353
#: f6a8a3c1839f418988c370e1feefadaf
msgid ""
"Primitive operations are defined in the module ``Core.TT.PrimFn``. The "
"constructors of this data type represent the primitive operations that "
"the custom back-end needs to implement. These primitive operations can be"
" grouped as:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:358
#: 475c0589e78d4142bf9b6ea76e5a6dd8
msgid ""
"Arithmetic operations (``Add``, ``Sub``, ``Mul``, ``Div``, ``Mod``, "
"``Neg``)"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:359
#: 960e45edfca0421dbd0d829147c92e90
msgid "Bit operations (``ShiftL``, ``ShiftR``, ``BAnd``, ``BOr``, ``BXor``)"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:360
#: 0e7f199b093c44ef86cda131803f2c0d
msgid "Comparison operations (``LT``, ``LTE``, ``EQ``, ``GTE``, ``GT``)"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:361
#: 297863a8e4c245ba81ca28ebabc89432
msgid ""
"String operations (``Length``, ``Head``, ``Tail``, ``Index``, ``Cons``, "
"``Append``, ``Reverse``, ``Substr``)"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:364
#: 51682f7dd76c4fab94ec665ab91153fa
msgid ""
"Double precision floating point operations (``Exp``, ``Log``, ``Sin``, "
"``Cos``, ``Tan``, ``ASin``, ``ACos``, ``ATan``, ``Sqrt``, ``Floor``, "
"``Ceiling``)"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:367
#: 496653e60ece4ead87b71d11641d60f2
msgid "Casting of numeric and string values"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:368
#: 61e451f57d0445ecac9f317c6a5cf173
msgid "An unsafe  cast operation ``BelieveMe``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:369
#: f4c3811954b74d43937b84fae295dbe4
msgid ""
"A ``Crash`` operation taking a type and a string and creating a value at "
"that type by raising an error."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:373
#: 26dd2b1ac6c44fe2ab03ebb309c82bbe
msgid "BelieveMe"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:375
#: bb1b3b7222854f9cbaa7ba2ec80255df
msgid ""
"The primitive ``believe_me`` is an unsafe cast that allows users to "
"bypass the typechecker when they know something to be true even though it"
" cannot be proven."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:378
#: 2f5bd079d1a7481988df28f264ac14be
msgid ""
"For instance, assuming that Idris' primitives are correctly implemented, "
"it should be true that if a boolean equality test on two ``Int`` ``i`` "
"and ``j`` returns ``True`` then ``i`` and ``j`` are equal. Such a theorem"
" can be implemented by using ``believe_me`` to cast ``Refl`` (the "
"constructor for proofs of a propositional equality) from ``i === i`` to "
"``i === j``. In this case, it should be safe to implement."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:386
#: e593356361c7467c9ea37676b5957d79
msgid "Boxing"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:388
#: ca8883003c0a47a090deb42ec06e0ac5
msgid ""
"Idris assumes that the back-end representation of the data is not "
"strongly typed and that all the data type have the same kind of "
"representation. This could introduce a constraint on the representation "
"of the primitives and constructor represented data types. One possible "
"solution is that the custom back-end should represent primitive data "
"types the same way it does constructors, using special tags. This is "
"called boxing."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:396
#: 0da3af048af3406db025856fc10d550c
msgid "Official backends represent primitive data types as boxed ones."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:398
#: 1bf1eb8d9ee941fc94a0bb6d41c2811a
msgid "RefC: Boxes the primitives, which makes them easy to put on the heap."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:399
#: 7dfc119ec6d6497cb8bc0fd9bf908588
msgid "Scheme: Prints the values that are a ``Constant`` as Scheme literals."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:402
#: 0250f0cd819c4a0f849d3b9793b235e5
msgid "How to compile top-level definitions?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:404
#: 8483944c32ab43bbb9e5d92d71231d24
msgid ""
"As mentioned earlier, Idris has 4 different IRs that are available in the"
" ``CompileData`` record: ``Named``, ``LambdaLifted``, ``ANF``, and "
"``VMDef``. When assembling the ``CompileData`` we have to tell the Idris "
"compiler which level we are interested in. The ``CompileData`` contains "
"lists of definitions that can be considered as top level definitions that"
" the custom back-end need to generate functions for."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:411
#: df4e8976028f4adeb6dbbff339905196
msgid ""
"There are four types of top-level definitions that the code generation "
"back-end needs to support:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:414
#: c1c7e4bd14cf4e288af916ce4914ece5
msgid "Function"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:415
#: dc8fb76e03d84a809180530d96804642
msgid "Constructor"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:416
#: 781d9257b5f1434e90cb7585fcef8ef9
msgid "Foreign call"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:417
#: 16db02cf91574e009c4afe5e107fdef9
msgid "Error"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:419
#: 68f52b64d176413999704c14b9c4df26
msgid "**Function** contains a lambda calculus like expression."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:421
#: a8fa631cb79749bb9d05acac6d18cdc0
msgid ""
"**Constructor** represents a data or a type constructor, and it should be"
" implemented as a function creating the corresponding data structure in "
"the custom back-end."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:425
#: 92b7a83a40ee4beba320955650080cb6
msgid ""
"A top-level **foreign call** defines an entry point for calling functions"
" implemented outside the Idris program under compilation. The Foreign "
"construction contains a list of Strings which are the snippets defined by"
" the programmer, the type of the arguments and the return type of the "
"foreign function. The custom back-end should generate a wrapper function."
" More on this on `How to implement the Foreign Function Interface?`_"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:432
#: e00e9a1f6b2a4d1caacf16e6a7f1b52f
msgid ""
"A top-level **error** definition represents holes in Idris programs, uses"
" of ``idris_crash``, or unreachable branches in a case tree. Users may "
"want to execute incomplete programs for testing purposes which is fine as"
" long as we never actually need the value of any of the holes. Library "
"writers may want to raise an exception if an unrecoverable error has "
"happened. Finally, Idris compiles the unreachable branches of a case tree"
" to runtime error as it is dead code anyway."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:445
#: b1d15c519a674205859190aa735c7d33
msgid ""
"The custom back-end should decide which intermediate representation is "
"used as a starting point. The result of the transformation should be "
"expressions and functions of the host technology."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:449
#: ce8b82a47f6048f5ac2dde0694912ce6
msgid ""
"Definitions in ``ANF`` and ``Lifted`` are represented as a tree like "
"expression, where control flow is based on the ``Let`` and ``Case`` "
"expressions."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:453
#: af46e76c8a0f4e93ad5bba2ac3f30b9d
msgid "Case expressions"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:455
#: f69a32180a35466998df5924ff356a71
msgid ""
"There are two types of case expressions, one for matching and branching "
"on primitive values such as ``Int``, and the second one is matching and "
"branching on constructor values. The two types of case expressions will "
"have two different representation for alternatives of the cases. These "
"are ``ConstCase`` (for matching on constant values) and ``ConCase`` (for "
"matching on constructors)."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:462
#: 6bd58b78d0594ae1aec1ef4601bcfe9e
msgid ""
"Matching on constructors can be implemented as matching on their tags or,"
" less efficiently, as matching on the name of the constructor. In both "
"cases a match should bind the values of the constructor's arguments to "
"variables in the body of the matching branch. This can be implemented in "
"various ways depending on the host technology: switch expressions, case "
"with pattern matching, or if-then-else chains."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:469
#: 68a37b89fa9d44e3815f17c501a284db
msgid ""
"When pattern matching binds variables, the number of arguments can be "
"different from the arity of the constructor defined in top-level "
"definitions and in ``GlobalDef``. This is because all the arguments are "
"kept around at typechecking time, but the code generator for the case "
"tree removes the ones which are marked as erased. The code generator of "
"the custom back-end also needs to remove the erased arguments in the "
"constructor implementation. In ``GlobalDef``, ``eraseArg`` contains this "
"information, which can be used to extract the number of arguments which "
"needs to be kept around."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:480
#: 856927b0bc0a40ed9d80f4efc9dc120a
msgid "Creating values"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:482
#: ab2c2c5f2494455d931b78c9f80eb13a
msgid "Values can be created in two ways."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:484
#: 7c067322c2d34bccb2f8e824a35b749e
msgid ""
"If the value is a primitive value, it will be handed to the back-end as a"
" ``PrimVal``. It should be compiled to a constant in the host language "
"following the  design decisions made in the 'How to represent primitive "
"values?' section."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:489
#: a03eb6af8d1247ae9fee7317d63f41e9
msgid ""
"If it is a structured value (i.e. a ``Con``) it should be compiled to a "
"function in the host language which creates a dynamic value. Design "
"decisions made for 'How to represent constructor values?' is going to "
"have effect here."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:494
#: 5f4741200c3c4bd79377d12e7dafdf5f
msgid "Function calls"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:496
#: 372e1007277648a499cf3a8b19222846
msgid ""
"There are four types of function calls: - Saturated function calls (all "
"the arguments are there) - Under-applied function calls (some arguments "
"are missing) - Primitive function calls (necessarily saturated, "
"``PrimFn`` constructor) - Foreign Function calls (referred to by its "
"name)"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:502
#: 9b366368154d493cab2e2816704db805
msgid ""
"The ``ANF`` and ``Lifted`` intermediate representations support under-"
"applied function calls (using the ``UnderApp`` constructor in both IR). "
"The custom back-end needs to support partial application of functions and"
" creating closures in the host technology. This is not a problem with "
"back-ends like Scheme where we get the partial application of a function "
"for free. But if the host language does not have this tool in its "
"toolbox, the custom back-end needs to simulate closures. One possible "
"solution is to manufacture a closure as a special object storing the "
"function and the values it is currently applied to and wait until all the"
" necessary arguments have been received before evaluating it. The same "
"approach is needed if the ``VMCode`` IR was chosen for code generation."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:516
#: 013b70303d614219a67dcf6aeb76120e
msgid "Let bindings"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:518
#: 44ba7f50e6d746d980dc4fa1bb29183c
msgid ""
"Both the ``ANF`` and ``Lifted`` intermediate representations have a "
"``Let`` construct that lets users assign values to local variables. These"
" two IRs differ in their representation of bound variables."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:522
#: 4b210100759d47b996b3e5c110cd0191
msgid ""
"``Lifted`` is a type family indexed by the ``List Name`` of local "
"variables in scope. A variable is represented using ``LLocal``, a "
"constructor that stores a ``Nat`` together with a proof that it points to"
" a valid name in the local scope."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:527
#: b24f50aa26854dc284282800572443e7
msgid ""
"``ANF`` is a lower level representation where this kind of guarantees are"
" not present anymore. A local variable is represented using the ``AV`` "
"constructor which stores an ``AVar`` whose definition we include below. "
"The ``ALocal`` constructor stores an ``Int`` that corresponds to the "
"``Nat`` we would have seen in ``Lifted``. The ``ANull`` constructor "
"refers to an erased variable and its representation in the host language "
"will depend on the design choices made in the 'How to represent "
"``Erased`` values' section."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:542
#: 91b1b3fb24244f47bb8fb1a8d2a737ac
msgid "VMDef specificities"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:544
#: 117e534187264214a3717818e6688ad5
msgid ""
"``VMDef`` is meant to be the closest IR to machine code. In ``VMDef``, "
"all the definitions have been compiled to instructions for a small "
"virtual machine with registers and closures."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:548
#: a3288c1f514041459e4de34d6a0f7246
msgid ""
"Instead of ``Let`` expressions, there only are ``ASSIGN`` statements at "
"this level."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:551
#: 485d5874e8fb487aa1cc8203aa9f592c
msgid ""
"Instead of ``Case`` expressions binding variables when they successfully "
"match on a data constructor, ``CASE`` picks a branch based on the "
"constructor itself. An extra operation called ``PROJECT`` is introduced "
"to explicitly extract a constructor's argument based on their position."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:556
#: 59cad0e0be644ce688aec5fcbc8f227a
msgid ""
"There are no ``App`` or ``UnderApp``. Both are replaced by ``APPLY`` "
"which applies only one value and creates a closure from the application. "
"For erased values the operation ``NULL`` assigns an empty/null value for "
"the register."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:561
#: a63fe468ef454bc6bac490c18c78432b
msgid "How to implement the Foreign Function Interface?"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:563
#: 2b562e285e2546c6b3f4ac9b7ec75e11
msgid ""
"The Foreign Function Interface (FFI) plays a big role in running Idris "
"programs. The primitive operations which are mentioned above are "
"functions for manipulating values and those functions aren't meant for "
"complex interaction with the runtime system. Many of the primitive types "
"can be thought of as abstract types provided via ``external`` and foreign"
" functions to manipulate them."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:570
#: c4fb0b84aabf4feb9b8575a1077c979b
msgid ""
"The responsibility of the custom back-end and the host technology is to "
"represent these computations the operationally correct way. The design "
"decisions with respect to representing primitive types in the host "
"technology will inevitably have effects on the design of the FFI."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:576
#: 5c5347f24b434edcb15f3ae2fdbdd7ec
msgid "Foreign Types"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:578
#: 2885f1721cb24e228b0c1676f2b9c6c3
msgid ""
"Originally Idris had an official back-end implementation in C. Even "
"though this has changed, the names in the types for the FFI kept their C "
"prefix. The ``Core.CompileExpr.CFType`` contains the following "
"definitions, many of them one-to-one mapping from the corresponding "
"primitive type, but some of them needs explanation."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:584
#: 835e2e849fe346efb6504d183dd35736
msgid "The foreign types are:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:586
#: fc1756928b80472c8bbfb674236c9cf5
msgid "``CFUnit``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:587
#: a1383af4144440999060fc12aa47cb5a
msgid "``CFInt``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:588
#: e8f6740daab64c308910564e8a069d85
msgid "``CFUnsigned(8/16/32/64)``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:589
#: e8a69dcb9bd3476296b81a493b5afe90
msgid "``CFString``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:590
#: 1af96b0d8086474297d7908d7165526f
msgid "``CFDouble``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:591
#: 7de1a2d6378b455abd2f19243fc53763
msgid "``CFChar``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:592
#: 79d12e5a772e4e4dace136194822fb38
msgid ""
"``CFFun`` of type  ``CFType -> CFType -> CFType`` Callbacks can be "
"registered in the host technology via parameters that have CFFun type. "
"The back-end should be able to handle functions that are defined in Idris"
" side and compiled to the host technology. If the custom back-end "
"supports higher order functions then it should be used to implement the "
"support for this kind of FFI type."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:598
#: e1ea7e16cadd4181bce8ba39f8ff542a
msgid ""
"``CFIORes`` of type ``CFType -> CFType`` Any ``PrimIO`` defined "
"computation will have this extra layer. Pure functions shouldn't have any"
" observable IO effect on the program state in the host technology "
"implemented runtime. NOTE: ``IORes`` is also used when callback functions"
" are registered in the host technology."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:604
#: 11acc2aaeec440ff943efc793ca8078c
msgid ""
"``CFWorld`` Represents the current state of the world. This should refer "
"to a token that is passed around between function calls. The "
"implementation of the World value should contain back-end specific values"
" and information about the state of the Idris runtime."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:609
#: 2b3af222ef6a47e6ae42c6ce6440f43d
msgid ""
"``CFStruct`` of type ``String -> List (String, CFType) -> CFType`` is the"
" foreign type associated with the ``System.FFI.Struct``. It represents a "
"C like structure in the custom back-end. ``prim__getField`` and "
"``prim__setField`` primitives should be implemented to support this "
"CFType."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:614
#: e9d1501f6bc245e9a78ac2293100aebd
msgid ""
"``CFUser`` of type ``Name -> List CFType -> CFType`` Types defined with "
"[external] are represented with ``CFUser``. For example ``data MyType : "
"Type where [external]`` will be represented as ``CFUser Module.MyType "
"[]``"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:618
#: d6e38aafeca94ae0b2512e3763974ac8
msgid ""
"``CFBuffer`` Foreign type defined for ``Data.Buffer``. Although this is "
"an external type, Idris builds on a random access buffer."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:621
#: 715f81142bb64dc0b8709037b6149b2e
msgid ""
"``CFPtr`` The ``Ptr t`` and ``AnyPtr`` are compiled to ``CFPtr`` Any "
"complex structured data that can not be represented as a simple primitive"
" can use this CFPtr to keep track where the value is used. In Idris ``Ptr"
" t`` is defined as external type."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:625
#: 910d25505769475aa1adb9a6a4c261ea
msgid ""
"``CFGCPtr`` The ``GCPtr t`` and ``GCAnyPtr`` are compiled to ``CFGCPtr``."
" ``GCPtr`` is inferred from a Ptr value calling the ``onCollect`` "
"function and has a special property. The ``onCollect`` attaches a "
"finalizer for the pointer which should run when the pointer is freed."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:631
#: 1aad41b73b7a40179bed57374ed341ff
msgid "Examples"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:633
#: 88df234d322748978f95a8e0014be741
#, python-format
msgid ""
"Let's step back and look into how this is represented at the Idris source"
" level. The simplest form of a definition involving the FFI a function "
"definition with a ``%foreign`` pragma. The pragma is passed a list of "
"strings corresponding to a mapping from backends to names for the foreign"
" calls. For instance:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:643
#: cc8dafe2ef674fcf8d0aa13afaae48d1
msgid ""
"this function should be translated by the C back end as a call to the "
"``add`` function defined in the ``smallc.c`` file. In the FFI, ``Int`` is"
" translated to ``CFInt``. The back-end assumes that the data "
"representation specified in the library file correspond to that of normal"
" Idris values."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:648
#: f80c94bf200c4bf5b2ed7edcc83dbf60
msgid "We can also define ``external`` types like in the following examples:"
msgstr ""

#: ../../source/backends/backend-cookbook.rst:657
#: ac8e2f37beb54f86b37b0cbb4725bcf1
msgid ""
"Here ``ThreadID`` is defined as an external type and this type will be "
"represented as ``CFUser \"ThreadID\" []`` internally. The value which is "
"created by the scheme runtime will be considered as a black box."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:661
#: 26f75d8ae3f043519f7f5f3d40379ae6
msgid ""
"The type of ``prim__fork``, once translated as a foreign type, is "
"``[%World -> IORes Unit, %World] -> IORes Main.ThreadID`` Here we see "
"that the ``%World`` is added to the IO computations. The ``%World`` "
"parameter is always the last in the argument list."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:666
#: 41d44595e51448b9912913467874b2c9
#, python-format
msgid ""
"For the FFI functions, the type information and the user defined string "
"can be found in the top-level definitions. The custom back-end should use"
" the definitions to generate wrapper code, which should convert the types"
" that are described by the ``CFType`` to the types that the function in "
"the ``%foreign`` directive needs.."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:675
#: e60d2b4a8ceb427b9748fa1b8415e9cb
msgid ""
"The Idris compiler generates intermediate files for modules, the content "
"of the files are neither part of ``Lifted``, ``ANF``, nor ``VMCode``. "
"Because of this, when the compilation pipeline enters the stage of code "
"generation, all the information will be in one instance of the "
"``CompileData`` record and the custom code generator back-end can process"
" them as it would see the whole program."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:682
#: 44274755b9ef4bb98a56ffc2a003543e
msgid ""
"The custom back-end has the option to introduce some hierarchy for the "
"functions in different namespaces and organize some module structure to "
"let the host technology process the bits and pieces in different sized "
"chunks. However, this feature is not in the scope of the Idris compiler."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:687
#: 146dc89703b84a94812216338ca4e196
msgid ""
"It is worth noting that modules can be mutually recursive in Idris. So a "
"direct compilation of Idris modules to modules in the host language may "
"be unsuccessful."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:694
#: 567cfe5b02084831b096d1fd51289fc8
msgid ""
"A possible motivation for implementing a custom back-end for Idris is to "
"generate code that is meant to be used in a larger project. This project "
"may be bound to another language that has many useful librarie  but could"
" benefit from relying on Idris' strong type system in places."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:699
#: 8c928b5ef6074231b44014f7471919cf
msgid ""
"When writing a code generator for this purpose, the interoperability of "
"the host technology and Idris based on the Foreign Interface can be "
"inconvenient. In this situation, the need to embed code of the host "
"technology arises naturally. Elaboration can be an answer for that."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:704
#: 88f3d1545e52461b9776cc082771ca81
msgid ""
"Elaboration is a typechecking time code generation technique. It relies "
"on the ``Elab`` monad to write scripts that can interact with the "
"typechecking machinery to generate Idris code in ``Core.TT``."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:708
#: ce640b5f210b49bcace9825e92a530f3
msgid ""
"When code snippets need to be embedded a custom library should be "
"provided with the custom back-end to turn the valid code snippets into "
"their representation in ``Core.TT``."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:715
#: df8a64ae8e8b405b903db8a8285f0006
msgid ""
"As a summary, a custom back-end for the Idris compiler should create an "
"environment in the host technology that is able to run Idris programs. As"
" Idris is part of the family of functional programming languages, its "
"computation model is based on graph reduction. Programs represented as "
"simple graphs in the memory are based on the closure creation mechanism "
"during evaluation. Closure creation exist even on the lowest levels of "
"IRs. For that reason any runtime in any host technology needs to support "
"some kind of representation of closures and be able to store them on the "
"heap, thus the responsibility of memory management falls on the lap of "
"the implementor of the custom back-end. If the host technology has memory"
" management, the problem is not difficult. It is also likely that storing"
" closures can be easily implemented via the tools of the host technology."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:727
#: f45cd1f8d05241c98f64ba365337f833
msgid ""
"Although it is not clear how much functionality a back-end should "
"support. Tools from the Scheme back-end are brought into the Idris world "
"via external types and primitive operations around them. This is a good "
"practice and gives the community the ability to focus on the "
"implementation of a quick compiler for a dependently typed language. One "
"of these hidden features is the concurrency primitives. These are part of"
" the different libraries that could be part of the compiler or part of "
"the contribution package. If the threading model is different for the "
"host technology that the Idris default back-end inherits currently from "
"the Scheme technology it could be a bigger piece of work."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:737
#: 30973d82b43e48a4b11dc10e09626b1f
msgid ""
"IO in Idris is implemented using an abstract ``%World`` value, which "
"serves as token for functions that operate interactively with the World "
"through simple calls to the underlying runtime system. The entry point of"
" the program is the main function, which has the type of the IO unit, "
"such as ``main : IO ()``. This means that every program which runs, "
"starts its part of some IO computation. Under the hood this is "
"implemented via the creation of the ``%World`` abstract value, and "
"invoking the main function, which is compiled to pass the abstract %World"
" value for IO related foreign or external operations."
msgstr ""

#: ../../source/backends/backend-cookbook.rst:746
#: e1d2044b63cb49b39dad0d74af909695
msgid ""
"There is an operation called ``unsafePerformIO`` in the ``PrimIO`` "
"module. The type signature of ``unsafePerformIO`` tells us that it is "
"capable of evaluating an ``IO`` computation in a pure context. Under the "
"hood it is run in exactly the same way the ``main`` function is. It "
"manufactures a fresh ``%World`` token and passes it to the ``IO`` "
"computations. This leads to a design decision: How to represent the state"
" of the World, and how to represent the world that is instantiated for "
"the sake of the ``unsafePerformIO`` operation via the "
"``unsafeCreateWorld``? Both the mechanisms of ``main`` and "
"``unsafeCreateWorld`` use the ``%MkWorld`` constructor, which will be "
"compiled to ``WorldVal`` and its type to ``WorldType``, which means the "
"implementation of the runtime is responsible for creating the abstraction"
" around the World. Implementation of an abstract World value could be "
"based on a singleton pattern, where we can have just one world, or we "
"could have more than one world, resulting in parallel universes for "
"``unsafePerformIO``."
msgstr ""

