# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 09:10+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/tutorial/typesfuns.rst:5 ee288698c00a4915b8cae51ba3974cfc
msgid "Types and Functions"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:8 df87c90ce3c14039973446897d002906
msgid "Primitive Types"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:10 49761108021a4f09890aeb52472a06c1
msgid ""
"Idris defines several primitive types: ``Int``, ``Integer`` and "
"``Double`` for numeric operations, ``Char`` and ``String`` for text "
"manipulation, and ``Ptr`` which represents foreign pointers. There are "
"also several data types declared in the library, including ``Bool``, with"
" values ``True`` and ``False``. We can declare some constants with these "
"types. Enter the following into a file ``Prims.idr`` and load it into the"
" Idris interactive environment by typing ``idris2 Prims.idr``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:34 6a9d271b70de48fca4a9f33ea680f2e2
msgid ""
"An Idris file consists of an optional module declaration (here ``module "
"Prims``) followed by an optional list of imports and a collection of "
"declarations and definitions. In this example no imports have been "
"specified. However Idris programs can consist of several modules and the "
"definitions in each module each have their own namespace. This is "
"discussed further in Section :ref:`sect-namespaces`. When writing Idris "
"programs both the order in which definitions are given and indentation "
"are significant. Functions and data types must be defined before use, "
"incidentally each definition must have a type declaration, for example "
"see ``x : Int``, ``foo : String``, from the above listing. New "
"declarations must begin at the same level of indentation as the preceding"
" declaration. Alternatively, a semicolon ``;`` can be used to terminate "
"declarations."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:48 719b64f256d242a48b4711abf955a999
msgid ""
"A library module ``prelude`` is automatically imported by every Idris "
"program, including facilities for IO, arithmetic, data structures and "
"various common functions. The prelude defines several arithmetic and "
"comparison operators, which we can use at the prompt. Evaluating things "
"at the prompt gives an answer, for example:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:61 8ef5948404d240cbad41b5b5d0de87f0
msgid ""
"All of the usual arithmetic and comparison operators are defined for the "
"primitive types. They are overloaded using interfaces, as we will discuss"
" in Section :ref:`sect-interfaces` and can be extended to work on user "
"defined types. Boolean expressions can be tested with the "
"``if...then...else`` construct, for example:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:73 09d2d01674754cefa3fc1e0b15773e03
msgid "Data Types"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:75 16a7bf454ae8460c9999cca8c84ff811
msgid ""
"Data types are declared in a similar way and with similar syntax to "
"Haskell. Natural numbers and lists, for example, can be declared as "
"follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:85 4877b7fa027f4169bad6af97e3db7bb5
msgid ""
"Data type names cannot begin with a lower case letter (we will see later "
"why not!).  The above declarations are taken from the standard library. "
"Unary natural numbers can be either zero (``Z``), or the successor of "
"another natural number (``S k``). Lists can either be empty (``Nil``) or "
"a value added to the front of another list (``x :: xs``). In the "
"declaration for ``List``, we used an infix operator ``::``. New operators"
" such as this can be added using a fixity declaration, as follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:97 7e963db8aad74d9aa2d2e9247dcdf0b7
msgid ""
"Functions, data constructors and type constructors may all be given infix"
" operators as names. They may be used in prefix form if enclosed in "
"brackets, e.g. ``(::)``. Infix operators can use any of the symbols:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:106 7a666323cba249e7a20dc917e02be684
msgid "Some operators built from these symbols can't be user defined. These are"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:108 bc53e8a5619a4136a13e830657853b17
msgid ""
"``%``, ``\\``, ``:``, ``=``, ``|``, ``|||``, ``<-``, ``->``, ``=>``, "
"``?``, ``!``, ``&``, ``**``, ``..``"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:112 133fec69f5d84cbaad27cdd6dd838cab
msgid "Functions"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:114 91ed78118cd044b2822ed589d9af7b6f
msgid ""
"Functions are implemented by pattern matching, again using a similar "
"syntax to Haskell. The main difference is that Idris requires type "
"declarations for all functions, using a single colon ``:`` (rather than "
"Haskell’s double colon ``::``). Some natural number arithmetic functions "
"can be defined as follows, again taken from the standard library:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:133 3d6d4d8653f646bba50be1e2d9dd8fe5
msgid ""
"The standard arithmetic operators ``+`` and ``*`` are also overloaded for"
" use by ``Nat``, and are implemented using the above functions. Unlike "
"Haskell, there is no restriction on whether function names must begin "
"with a capital letter or not. Function names (``plus`` and ``mult`` "
"above), data constructors (``Z``, ``S``, ``Nil`` and ``::``) and type "
"constructors (``Nat`` and ``List``) are all part of the same namespace. "
"By convention, however, data types and constructor names typically begin "
"with a capital letter. We can test these functions at the Idris prompt:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:150 6bf9d2b99a91422f858308bf1a45fb14
msgid ""
"Like arithmetic operations, integer literals are also overloaded using "
"interfaces, meaning that we can also test the functions as follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:160 8f1ff2af9b624904be8b831d7cb72de1
msgid ""
"You may wonder, by the way, why we have unary natural numbers when our "
"computers have perfectly good integer arithmetic built in. The reason is "
"primarily that unary numbers have a very convenient structure which is "
"easy to reason about, and easy to relate to other data structures as we "
"will see later. Nevertheless, we do not want this convenience to be at "
"the expense of efficiency. Fortunately, Idris knows about the "
"relationship between ``Nat`` (and similarly structured types) and "
"numbers. This means it can optimise the representation, and functions "
"such as ``plus`` and ``mult``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:171 aef277369b8f49e9b82b60e22c47f257
msgid "``where`` clauses"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:173 dd84e7de16f64827a9b6fd3477ea2442
msgid ""
"Functions can also be defined *locally* using ``where`` clauses. For "
"example, to define a function which reverses a list, we can use an "
"auxiliary function which accumulates the new, reversed list, and which "
"does not need to be visible globally:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:186 e0a39a967d5e44eebb678ea0be561103
msgid ""
"Indentation is significant — functions in the ``where`` block must be "
"indented further than the outer function."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:189 7ae67010055b44409ec59f54ccf64004
msgid "Scope"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:191 8788875cae9443a0a6df9222156e67c7
msgid ""
"Any names which are visible in the outer scope are also visible in the "
"``where`` clause (unless they have been redefined, such as ``xs`` here). "
"A name which appears in the type will be in scope in the ``where`` "
"clause."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:196 8febaa28ac714ec89606048e5e6beb16
msgid ""
"As well as functions, ``where`` blocks can include local data "
"declarations, such as the following where ``MyLT`` is not accessible "
"outside the definition of ``foo``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:212 49d06587da9347db83e9b96f7395e97e
msgid ""
"Functions defined in a ``where`` clause need a type declaration just like"
" any top level function. Here is another example of how this works in "
"practice:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:238 74a5fa340db44ead8ac57f93081093f8
msgid "Totality and Covering"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:240 30706341eef2468fbfe8e14de764a8bd
msgid ""
"By default, functions in Idris must be ``covering``. That is, there must "
"be patterns which cover all possible values of the inputs types. For "
"example, the following definition will give an error:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:249 869c3f54ce2545b1b0d763511fa79315
msgid ""
"This gives an error because ``fromMaybe Nothing`` is not defined. Idris "
"reports:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:257 589b874a0e2c46be9d01175f55a27bdb
msgid "You can override this with a ``partial`` annotation:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:264 b8fe23e9a429484bb6f69294100ef5d7
msgid ""
"However, this is not advisable, and in general you should only do this "
"during the initial development of a function, or during debugging.  If "
"you try to evaluate ``fromMaybe Nothing`` at run time you will get a run "
"time error."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:269 e1f322cbf5b64009968b9948dea80733
msgid "Holes"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:271 97fe7efcca9f4b8897894fadec77970b
msgid ""
"Idris programs can contain *holes* which stand for incomplete parts of "
"programs. For example, we could leave a hole for the greeting in our "
"\"Hello world\" program:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:280 38e679673bec4649b483c65df1543ac9
msgid ""
"The syntax ``?greeting`` introduces a hole, which stands for a part of a "
"program which is not yet written. This is a valid Idris program, and you "
"can check the type of ``greeting``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:290 4fa59d9e06f9457a993127a2defff0b7
msgid ""
"Checking the type of a hole also shows the types of any variables in "
"scope. For example, given an incomplete definition of ``even``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:299 f107f7b094654e2e9be8eeade7255bf7
msgid ""
"We can check the type of ``even_rhs`` and see the expected return type, "
"and the type of the variable ``k``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:309 91b01c0d84984dc6869640d3b4bc76b8
msgid ""
"Holes are useful because they help us write functions *incrementally*. "
"Rather than writing an entire function in one go, we can leave some parts"
" unwritten and use Idris to tell us what is necessary to complete the "
"definition."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:315 a6b7cc803c50472e91873be6057d6acd
msgid "Dependent Types"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:320 e6f512da83fb474c8745a301b3f98626
msgid "First Class Types"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:322 1b488d3270104a83a69a94503ccf0426
msgid ""
"In Idris, types are first class, meaning that they can be computed and "
"manipulated (and passed to functions) just like any other language "
"construct. For example, we could write a function which computes a type:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:332 fad30a01e7724aa794a6d35b96e17dd1
msgid ""
"This function calculates the appropriate type from a ``Bool`` which flags"
" whether the type should be a singleton or not. We can use this function "
"to calculate a type anywhere that a type can be used. For example, it can"
" be used to calculate a return type:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:343 be8fc96ec1cf48f1847d31d07fee1fca
msgid ""
"Or it can be used to have varying input types. The following function "
"calculates either the sum of a list of ``Nat``, or returns the given "
"``Nat``, depending on whether the singleton flag is true:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:355 04dcfe5e23e94030b6f0cc6f8a621669
msgid "Vectors"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:357 ba8659c39b8b48a8a363ebe746ca586a
msgid ""
"A standard example of a dependent data type is the type of “lists with "
"length”, conventionally called vectors in the dependent type literature. "
"They are available as part of the Idris library, by importing "
"``Data.Vect``, or we can declare them as follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:368 397e81ed61704fe09456cf645483a59b
msgid ""
"Note that we have used the same constructor names as for ``List``. Ad-hoc"
" name overloading such as this is accepted by Idris, provided that the "
"names are declared in different namespaces (in practice, normally in "
"different modules). Ambiguous constructor names can normally be resolved "
"from context."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:374 4b43951c6b3345cd87b82fde2ba0a30a
msgid ""
"This declares a family of types, and so the form of the declaration is "
"rather different from the simple type declarations above. We explicitly "
"state the type of the type constructor ``Vect`` — it takes a ``Nat`` and "
"a type as an argument, where ``Type`` stands for the type of types. We "
"say that ``Vect`` is *indexed* over ``Nat`` and *parameterised* by "
"``Type``. Each constructor targets a different part of the family of "
"types. ``Nil`` can only be used to construct vectors with zero length, "
"and ``::`` to construct vectors with non-zero length. In the type of "
"``::``, we state explicitly that an element of type ``a`` and a tail of "
"type ``Vect k a`` (i.e., a vector of length ``k``) combine to make a "
"vector of length ``S k``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:386 309f011c5c85437d8fd688812f7b1df8
msgid ""
"We can define functions on dependent types such as ``Vect`` in the same "
"way as on simple types such as ``List`` and ``Nat`` above, by pattern "
"matching. The type of a function over ``Vect`` will describe what happens"
" to the lengths of the vectors involved. For example, ``++``, defined as "
"follows, appends two ``Vect``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:398 993efef78c8f4f359cdcddd4171a11c2
msgid ""
"The type of ``(++)`` states that the resulting vector’s length will be "
"the sum of the input lengths. If we get the definition wrong in such a "
"way that this does not hold, Idris will not accept the definition. For "
"example:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:409 5988ce33dce34de6a50d53c8c94e1202
msgid "When run through the Idris type checker, this results in the following:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:423 c495a3d0e36048048b5dd7b96b3c28a0
msgid ""
"This error message suggests that there is a length mismatch between two "
"vectors — we needed a vector of length ``k + m``, but provided a vector "
"of length ``k + k``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:428 ac84381c5b5242009ea23d25c37bac7f
msgid "The Finite Sets"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:430 9af1f5ff27184e84a02c8b4cb73ac005
msgid ""
"Finite sets, as the name suggests, are sets with a finite number of "
"elements. They are available as part of the Idris library, by importing "
"``Data.Fin``, or can be declared as follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:440 61775184539d4061a6618d3db79e8209
msgid ""
"From the signature,  we can see that this is a type constructor that "
"takes a ``Nat``, and produces a type. So this is not a set in the sense "
"of a collection that is a container of objects, rather it is the "
"canonical set of unnamed elements, as in \"the set of 5 elements,\" for "
"example. Effectively, it is a type that captures integers that fall into "
"the range of zero to ``(n - 1)`` where ``n`` is the argument used to "
"instantiate the ``Fin`` type. For example, ``Fin 5`` can be thought of as"
" the type of integers between 0 and 4."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:447 57aebd80636d48ec853bc8da6f8f7ad0
msgid "Let us look at the constructors in greater detail."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:449 a513fe86c9ca4915af995396078023a3
msgid ""
"``FZ`` is the zeroth element of a finite set with ``S k`` elements; ``FS "
"n`` is the ``n+1``\\ th element of a finite set with ``S k`` elements. "
"``Fin`` is indexed by a ``Nat``, which represents the number of elements "
"in the set. Since we can’t construct an element of an empty set, neither "
"constructor targets ``Fin Z``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:455 2deee1a2dcdd41ddaa63dea7c5aebb5a
msgid ""
"As mentioned above, a useful application of the ``Fin`` family is to "
"represent bounded natural numbers. Since the first ``n`` natural numbers "
"form a finite set of ``n`` elements, we can treat ``Fin n`` as the set of"
" integers greater than or equal to zero and less than ``n``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:460 362a60870d22404d80dbd903d7d95da3
msgid ""
"For example, the following function which looks up an element in a "
"``Vect``, by a bounded index given as a ``Fin n``, is defined in the "
"prelude:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:470 8048ddfccedc4c859f2216c2b9e2315a
msgid ""
"This function looks up a value at a given location in a vector. The "
"location is bounded by the length of the vector (``n`` in each case), so "
"there is no need for a run-time bounds check. The type checker guarantees"
" that the location is no larger than the length of the vector, and of "
"course no less than zero."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:476 ed11229c27cb45e28736b3589b2c0d01
msgid ""
"Note also that there is no case for ``Nil`` here. This is because it is "
"impossible. Since there is no element of ``Fin Z``, and the location is a"
" ``Fin n``, then ``n`` can not be ``Z``. As a result, attempting to look "
"up an element in an empty vector would give a compile time type error, "
"since it would force ``n`` to be ``Z``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:483 eb3a7d1e91774b299ddee267d6bbd331
msgid "Implicit Arguments"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:485 7a79ee3857b74b11a1ef1b313b5e2899
msgid "Let us take a closer look at the type of ``index``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:491 487fb29ef4b34c60b276ff9c2fa314b3
msgid ""
"It takes two arguments, an element of the finite set of ``n`` elements, "
"and a vector with ``n`` elements of type ``a``. But there are also two "
"names, ``n`` and ``a``, which are not declared explicitly. These are "
"*implicit* arguments to ``index``. We could also write the type of "
"``index`` as:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:501 4c86dd9ba4474807b7e525ebda8ab63d
msgid ""
"Implicit arguments, given with the ``forall`` declaration, are not given "
"in applications of ``index``; their values can be inferred from the types"
" of the ``Fin n`` and ``Vect n a`` arguments. Any name beginning with a "
"lower case letter which appears as a parameter or index in a type "
"declaration, which is not applied to any arguments, will *always* be "
"automatically bound as an implicit argument; this is why data type names "
"cannot begin with a lower case letter. Implicit arguments can still be "
"given explicitly in applications, using ``{a=value}`` and ``{n=value}``, "
"for example:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:517 1af920576c9e4c60a7e777b5e3b13025
msgid ""
"In fact, any argument, implicit or explicit, may be given a name. We "
"could have declared the type of ``index`` as:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:524 945ff42482ca447eb2615fdbaeb3534c
msgid ""
"It is a matter of taste whether you want to do this — sometimes it can "
"help document a function by making the purpose of an argument more clear."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:528 5cb6be430e9c49edafb6d9eac5146ec9
msgid ""
"The names of implicit arguments are in scope in the body of the function,"
" although they cannot be used at run time. There is much more to say "
"about implicit arguments - we will discuss the question of what is "
"available at run time, among other things, in Section :ref:`sect-"
"multiplicities`"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:534 3b3b40c6873046c38c409e276c960cef
msgid "Note: Declaration Order and ``mutual`` blocks"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:536 d968db372f3c4068802c14c84e7ef06e
msgid ""
"In general, functions and data types must be defined before use, since "
"dependent types allow functions to appear as part of types, and type "
"checking can rely on how particular functions are defined (though this is"
" only true of total functions; see Section :ref:`sect-totality`). "
"However, this restriction can be relaxed by using a ``mutual`` block, "
"which allows data types and functions to be defined simultaneously:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:554 5a7c06efe0de40b49a2bec67e578f996
msgid ""
"In a ``mutual`` block, first all of the type declarations are added, then"
" the function bodies. As a result, none of the function types can depend "
"on the reduction behaviour of any of the functions in the block."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:559 9c530ca5f6fa4d5e9fbbc050a02713df
msgid ""
"Forward declarations can allow you to have more fine-grained control over"
" the order in which mutually defined concepts are declared. This can be "
"useful if you need to mention a datatype's constructor in the type of a "
"mutually defined function, or need to rely on the behaviour of a mutually"
" defined function for something to typecheck."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:602 bd6a1141e7a14794ab07820d19d10d77
msgid ""
"Placing signature declarations forward can suggest Idris to detect their "
"corresponding mutual definitions."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:606 87bc4fc80feb428b9d6e6300212db375
msgid "I/O"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:608 678d910e58e1476aa8807eaca116db80
msgid ""
"Computer programs are of little use if they do not interact with the user"
" or the system in some way. The difficulty in a pure language such as "
"Idris — that is, a language where expressions do not have side-effects — "
"is that I/O is inherently side-effecting. So, Idris provides a "
"parameterised type ``IO`` which *describes* the interactions that the "
"run-time system will perform when executing a function:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:619 32c867f7c9f5470a9686daed30625ff0
msgid ""
"We’ll leave the definition of ``IO`` abstract, but effectively it "
"describes what the I/O operations to be executed are, rather than how to "
"execute them. The resulting operations are executed externally, by the "
"run-time system. We’ve already seen one I/O program:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:629 dc9987126b4b44949ed30c57f4629aa4
msgid ""
"The type of ``putStrLn`` explains that it takes a string, and returns an "
"I/O action which produces an element of the unit type ``()``. There is a "
"variant ``putStr`` which decribes the output of a string without a "
"newline:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:638 eb0dc24b9c55498dbfc853bb2b99680c
msgid "We can also read strings from user input:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:644 3dea6e8dd8d84f52bc4bb533b6953303
msgid ""
"A number of other I/O operations are available. For example, by adding "
"``import System.File`` to your program, you get access to functions for "
"reading and writing files, including:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:660 f90eb48c69f848e18bfc8c63533c0ec3
msgid "Note that several of these return ``Either``, since they may fail."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:665 196ef858bfce4155815f6422fc94fdd5
msgid "“``do``” notation"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:667 37eb8036b7b0417cbc86244d265012f5
msgid ""
"I/O programs will typically need to sequence actions, feeding the output "
"of one computation into the input of the next. ``IO`` is an abstract "
"type, however, so we can’t access the result of a computation directly. "
"Instead, we sequence operations with ``do`` notation:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:679 31c8658fbee34c9e8d9f30026bc780a1
msgid ""
"The syntax ``x <- iovalue`` executes the I/O operation ``iovalue``, of "
"type ``IO a``, and puts the result, of type ``a`` into the variable "
"``x``. In this case, ``getLine`` returns an ``IO String``, so ``name`` "
"has type ``String``. Indentation is significant — each statement in the "
"do block must begin in the same column. The ``pure`` operation allows us "
"to inject a value directly into an IO operation:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:690 02448b0295014af39a3d78f64677c0de
msgid ""
"As we will see later, ``do`` notation is more general than this, and can "
"be overloaded."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:693 46771e2438774e89b5ae3855e8fe7c07
msgid ""
"You can try executing ``greet`` at the Idris 2 REPL by running the "
"command ``:exec greet``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:704 277cf3d9775f4da18e1bb410247a6290
msgid "Laziness"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:706 5de0fae9b2a8471f99f0cf3a78a44b03
msgid ""
"Normally, arguments to functions are evaluated before the function itself"
" (that is, Idris uses *eager* evaluation). However, this is not always "
"the best approach. Consider the following function:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:716 908427c621254bf3abbad1a9e7c7992b
msgid ""
"This function uses one of the ``t`` or ``e`` arguments, but not both. We "
"would prefer if *only* the argument which was used was evaluated. To "
"achieve this, Idris provides a ``Lazy`` primitive, which allows "
"evaluation to be suspended. It is a primitive, but conceptually we can "
"think of it as follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:728 120235aa623746319ff8da6be7f202e2
msgid ""
"A value of type ``Lazy a`` is unevaluated until it is forced by "
"``Force``. The Idris type checker knows about the ``Lazy`` type, and "
"inserts conversions where necessary between ``Lazy a`` and ``a``, and "
"vice versa. We can therefore write ``ifThenElse`` as follows, without any"
" explicit use of ``Force`` or ``Delay``:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:741 12c8a43ea09440fd86dacc0e0e1a4d23
msgid "Infinite data Types"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:743 f5e8743191ff40a097d7edd2ea144eb2
msgid ""
"Infinite data types (codata) allow us to define infinite data structures "
"by marking recursive arguments as potentially infinite. One example of an"
" infinite type is Stream, which is defined as follows."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:752 55d6b428c2664633a8eb3dfd0d63f958
msgid ""
"The following is an example of how the codata type ``Stream`` can be used"
" to form an infinite data structure. In this case we are creating an "
"infinite stream of ones."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:762 49077848d31b469ab5904abed778ce10
msgid "Useful Data Types"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:764 b6008ea2458d404292573c17fba809e0
msgid ""
"Idris includes a number of useful data types and library functions (see "
"the ``libs/`` directory in the distribution, and the `documentation "
"<https://www.idris-lang.org/pages/documentation.html>`_). This section "
"describes a few of these, and how to import them."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:770 53e95971025b492282a44b787e4416eb
msgid "``List`` and ``Vect``"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:772 0a3ed2db6d9e44a18ce8bc0c3febe625
msgid "We have already seen the ``List`` and ``Vect`` data types:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:782 6c128cd54e0e4710be4a39cca07fda23
msgid ""
"You can get access to ``Vect`` with ``import Data.Vect``. Note that the "
"constructor names are the same for each — constructor names (in fact, "
"names in general) can be overloaded, provided that they are declared in "
"different namespaces (see Section :ref:`sect-namespaces`), and will "
"typically be resolved according to their type. As syntactic sugar, any "
"implementation of the names ``Nil`` and ``::`` can be written in list "
"form. For example:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:790 766b62d8447b41eb89b8ba63ac1c2f74
msgid "``[]`` means ``Nil``"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:792 35977f3aa6f0468ca62e10b7efc333d6
msgid "``[1,2,3]`` means ``1 :: 2 :: 3 :: Nil``"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:794 0aec7fafb646427bb54574202830d7a2
msgid ""
"Similarly, any implementation of the names ``Lin`` and ``:<`` can be "
"written in **snoc**-list form:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:797 da71d2eba5fb4141abbbdf08e4cbbdd7
msgid "``[<]`` mean ``Lin``"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:798 d0ee74594dfb4e64ac390a380a034036
msgid "``[< 1, 2, 3]`` means ``Lin :< 1 :< 2 :< 3``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:800 c87f367d779340fcbc804a83eb8a653c
msgid "and the prelude includes a pre-defined datatype for snoc-lists:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:807 3aaaa0cf55b84d8f81d0c80af1f5e264
msgid ""
"The library also defines a number of functions for manipulating these "
"types. ``map`` is overloaded both for ``List`` and ``Vect`` (we'll see "
"more details of precisely how later when we cover interfaces in Section "
":ref:`sect-interfaces`) and applies a function to every element of the "
"list or vector."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:823 6d60f1686ef54feaa02e5acc6e99b4e2
msgid ""
"For example, given the following vector of integers, and a function to "
"double an integer:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:834 7b2164988afe426eaa4139570babe662
msgid ""
"the function ``map`` can be used as follows to double every element in "
"the vector:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:842 efac8965a72b436786fb8aba39d5c43b
msgid ""
"For more details of the functions available on ``List`` and ``Vect``, "
"look in the library files:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:845 c04a61977dbc4e18ad022254c8d0aecd
msgid "``libs/base/Data/List.idr``"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:847 2995a7770ef24267b9716d1327cdf1c3
msgid "``libs/base/Data/Vect.idr``"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:849 8fa2b41ce5d74a34a292e5307f0fe727
msgid "Functions include filtering, appending, reversing, and so on."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:852 273bbd68e1014e07a8a021ef122af2d2
msgid "Aside: Anonymous functions and operator sections"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:854 7dd15a445fc24deb843fb9078928492b
msgid ""
"There are neater ways to write the above expression. One way would be to "
"use an anonymous function:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:862 8bf94ec216134d57831eba9dd881cd31
msgid ""
"The notation ``\\x => val`` constructs an anonymous function which takes "
"one argument, ``x`` and returns the expression ``val``. Anonymous "
"functions may take several arguments, separated by commas, e.g. ``\\x, y,"
" z => val``. Arguments may also be given explicit types, e.g. ``\\x : Int"
" => x * 2``, and can pattern match, e.g. ``\\(x, y) => x + y``. We could "
"also use an operator section:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:874 4d69cae8bafb4fa69bca58953648ac77
msgid ""
"``(*2)`` is shorthand for a function which multiplies a number by 2. It "
"expands to ``\\x => x * 2``. Similarly, ``(2*)`` would expand to ``\\x =>"
" 2 * x``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:879 03a5eed0bc2244a98e9c2c061956b88f
msgid "Maybe"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:881 3a961c3c96cc4b92bf1a0b01e036436e
msgid ""
"``Maybe``, defined in the Prelude, describes an optional value. Either "
"there is a value of the given type, or there isn’t:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:888 a38a6f800d384fd89a6852ba250bbfc7
msgid ""
"``Maybe`` is one way of giving a type to an operation that may fail. For "
"example, looking something up in a ``List`` (rather than a vector) may "
"result in an out of bounds error:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:899 d123af5a138e4d0e94bdd6dfd2fdca5a
msgid ""
"The ``maybe`` function is used to process values of type ``Maybe``, "
"either by applying a function to the value, if there is one, or by "
"providing a default value:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:907 9f4ffd5629c2441bae19aa85ecb4ff48
msgid ""
"Note that the types of the first two arguments are wrapped in ``Lazy``. "
"Since only one of the two arguments will actually be used, we mark them "
"as ``Lazy`` in case they are large expressions where it would be wasteful"
" to compute and then discard them."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:913 5afbdb751c334bb696df012998ebd9ee
msgid "Tuples"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:915 7388ecdaa43545d48cd4c4872e757977
msgid "Values can be paired with the following built-in data type:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:921 743b85c6e38241418630949f8e0140d4
msgid ""
"As syntactic sugar, we can write ``(a, b)`` which, according to context, "
"means either ``Pair a b`` or ``MkPair a b``. Tuples can contain an "
"arbitrary number of values, represented as nested pairs:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:943 58808565c1f84b7c97db4639f3ed4555
msgid "Dependent Pairs"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:945 b417ce960814457f8618232b0c53d8b7
msgid ""
"Dependent pairs allow the type of the second element of a pair to depend "
"on the value of the first element:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:953 7199cafd5db24dfb8e677738e1d28b68
msgid ""
"Again, there is syntactic sugar for this. ``(x : a ** p)`` is the type of"
" a pair of A and P, where the name ``x`` can occur inside ``p``. ``( x **"
" p )`` constructs a value of this type. For example, we can pair a number"
" with a ``Vect`` of a particular length:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:963 5e1e379ef35a4e0c878266cec40ada9b
msgid "If you like, you can write it out the long way; the two are equivalent:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:970 2908da9534c74f95a62fac1dd587e1d4
msgid ""
"The type checker could infer the value of the first element from the "
"length of the vector. We can write an underscore ``_`` in place of values"
" which we expect the type checker to fill in, so the above definition "
"could also be written as:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:980 07dbbe30bf7541dfbdec9457a182d971
msgid ""
"We might also prefer to omit the type of the first element of the pair, "
"since, again, it can be inferred:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:988 0c295108c3cd4d9095a793ce79b7beb8
msgid ""
"One use for dependent pairs is to return values of dependent types where "
"the index is not necessarily known in advance. For example, if we filter "
"elements out of a ``Vect`` according to some predicate, we will not know "
"in advance what the length of the resulting vector will be:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:998 7d13e992fc0d44bdb9906719ea1ce769
msgid "If the ``Vect`` is empty, the result is:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1004 73f969cbb3094c1c919e3def7b7bf620
msgid ""
"In the ``::`` case, we need to inspect the result of a recursive call to "
"``filter`` to extract the length and the vector from the result. To do "
"this, we use a ``case`` expression, which allows pattern matching on "
"intermediate values:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1018 806c08d795324cf0bbc15c098e990c65
msgid "Dependent pairs are sometimes referred to as “Sigma types”."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1021 551e2800e683480b8f80ab0f90afc3a5
msgid "Records"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1023 b0918fd9637248168ed5b88296b48463
msgid ""
"*Records* are data types which collect several values (the record's "
"*fields*) together. Idris provides syntax for defining records and "
"automatically generating field access and update functions. Unlike the "
"syntax used for data structures, records in Idris follow a different "
"syntax to that seen with Haskell. For example, we can represent a "
"person’s name and age in a record:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1039 6659126e06de4b98a54aa2e3afc67378
msgid ""
"The constructor name is provided using the ``constructor`` keyword, and "
"the *fields* are then given which are in an indented block following the "
"`where` keyword (here, ``firstName``, ``middleName``, ``lastName``, and "
"``age``). You can declare multiple fields on a single line, provided that"
" they have the same type. The field names can be used to access the field"
" values:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1054 7503e252d429424facee72231f3ff4d2
msgid "We can use prefix field projections, like in Haskell:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1065 eca624392c994cd9bf4fd5875640d37e
msgid ""
"Prefix field projections can be disabled per record definition using "
"pragma ``%prefix_record_projections off``, which makes all subsequently "
"defined records generate only dotted projections. This pragma has effect "
"until the end of the module or until the closest occurrence of "
"``%prefix_record_projections on``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1071 adcc787e690947469f03d88a86705786
msgid ""
"We can also use the field names to update a record (or, more precisely, "
"produce a copy of the record with the given fields updated):"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1082 28322a8a531d42fa94d5df8b95b7619d
msgid ""
"The syntax ``{ field := val, ... }`` generates a function which updates "
"the given fields in a record. ``:=`` assigns a new value to a field, and "
"``$=`` applies a function to update its value."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1086 48a85d7d26724752a3eff61f6bb5fc73
msgid ""
"Each record is defined in its own namespace, which means that field names"
" can be reused in multiple records."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1089 57e954b69fd942eb91111908ab4c768d
msgid ""
"Records, and fields within records, can have dependent types. Updates are"
" allowed to change the type of a field, provided that the result is well-"
"typed."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1100 fde827c130384a83982fba021d0b00bd
msgid ""
"It is safe to update the ``students`` field to a vector of a different "
"length because it will not affect the type of the record:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1113 4a594faa4e044106971195bb87952157
msgid "We could also use ``$=`` to define ``addStudent`` more concisely:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1121 2baf9c0428e24a3c80a8333785a5283a
msgid "Nested record projection"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1123 ef862b4c9b6a4c11adfb618070b85e71
msgid "Nested record fields can be accessed using the dot notation:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1130 238a3dfb70bb48cc8ae40a53458ea2c2
msgid ""
"For the dot notation, there must be no spaces after the dots but there "
"may be spaces before the dots. The composite projection must be "
"parenthesised, otherwise ``map .a.b.c xs`` would be understood as "
"``map.a.b.c xs``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1134 8c2db0ae4378445db98c4e8a6f8c2c69
msgid "Nested record fields can be accessed using the prefix notation, too:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1141 19819fb8546241b488e4d2a667cc145f
msgid "Dots with spaces around them stand for function composition operators."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1144 543b4ea475074105b0926a9bcb82b7ae
msgid "Nested record update"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1146 9cdfca2f755f48f4a28295cd7ee26e6c
msgid ""
"Idris also provides a convenient syntax for accessing and updating nested"
" records. For example, if a field is accessible with the expression "
"``x.a.b.c``, it can be updated using the following syntax:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1155 22c275ed0317411ba8e72ceb57a3e87f
msgid ""
"This returns a new record, with the field accessed by the path ``a.b.c`` "
"set to ``val``. The syntax is first class, i.e. ``{ a.b.c := val }`` "
"itself has a function type."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1159 24f546e68b134a63b49ce27b9098276e
msgid "The ``$=`` notation is also valid for nested record updates."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1162 d1f7b5faaa5d4ac791362c369d946ce7
msgid "Dependent Records"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1164 f09d6e7f854a494c829aa4b0e86e4248
msgid ""
"Records can also be dependent on values. Records have *parameters*, which"
" cannot be updated like the other fields. The parameters appear as "
"arguments to the resulting type, and are written following the record "
"type name. For example, a pair type could be defined as follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1176 f55d1bf7297e40bd80b50523f39559ab
msgid ""
"Using the ``Class`` record from earlier, the size of the class can be "
"restricted using a ``Vect`` and the size included in the type by "
"parameterising the record with the size.  For example:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1187 c4fe56c8efa04dc9bfd5d93aa0622e06
msgid ""
"In the case of ``addStudent`` earlier, we can still add a student to a "
"``SizedClass`` since the size is implicit, and will be updated when a "
"student is added:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1196 dac0fda2814d42cebac517a65b432c23
msgid ""
"In fact, the dependent pair type we have just seen is, in practice, "
"defined as a record, with fields ``fst`` and ``snd`` which allow "
"projecting values out of the pair:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1207 bd573502434741f6baffbfe0e1bbbafe
msgid ""
"It is possible to use record update syntax to update dependent fields, "
"provided that all related fields are updated at once. For example:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1217 18614a9611a0493883044165526f9701
msgid "Or even:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1230 2e4dae8e8daa42e1a20f4a59e6389dba
msgid "More Expressions"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1235 80628047f81640ae9f1004c124beae77
msgid "``let`` bindings"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1237 4f058efe6e9e4d6d88798875a517685f
msgid "Intermediate values can be calculated using ``let`` bindings:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1245 7a1fac80a6614be8893bd6a3418a3259
msgid ""
"We can do pattern matching in ``let`` bindings too. For example, we can "
"extract fields from a record as follows, as well as by pattern matching "
"at the top level:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1257 a5e97a7fdc3a487198db62d52356d1f5
msgid "These let bindings can be annotated with a type:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1265 2b95b81fbcf94acd8ed73a9b109dcb35
msgid ""
"We can also use the symbol ``:=`` instead of ``=`` to, among other "
"things, avoid ambiguities with propositional equality:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1273 e0c7a1fa0b694184a0f351b5a216a796
msgid ""
"Local definitions can also be introduced using ``let``. Just like top "
"level ones and ones defined in a ``where`` clause you need to:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1276 4e9efe68aaf94fd7bb6557414d52218b
msgid "declare the function and its type"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1277 afaa8611762f4576b8b2c3fac32bee5f
msgid "define the function by pattern matching"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1286 f20d36bd16da46db82a9f6335ffd97da
msgid ""
"The symbol ``:=`` cannot be used in a local function definition. Which "
"means that it can be used to interleave let bindings and local "
"definitions without introducing ambiguities."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1301 d02dea97e19f46ee9a9858c64ab8699b
msgid "List comprehensions"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1303 43ceb2f3e9264f688bbcab9bcecbf941
msgid ""
"Idris provides *comprehension* notation as a convenient shorthand for "
"building lists. The general form is:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1310 8b809aab4c934b86a99293a81cfd0c3b
msgid ""
"This generates the list of values produced by evaluating the "
"``expression``, according to the conditions given by the comma separated "
"``qualifiers``. For example, we can build a list of Pythagorean triples "
"as follows:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1321 6f8aab6584a0450da0f374066cb391ca
msgid ""
"The ``[a..b]`` notation is another shorthand which builds a list of "
"numbers between ``a`` and ``b``. Alternatively ``[a,b..c]`` builds a list"
" of numbers between ``a`` and ``c`` with the increment specified by the "
"difference between ``a`` and ``b``. This works for type ``Nat``, ``Int`` "
"and ``Integer``, using the ``enumFromTo`` and ``enumFromThenTo`` function"
" from the prelude."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1329 afa686c2535f49c8a961b7e56bf7c318
msgid "``case`` expressions"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1331 18d0a1aa1bff43fda87647b0e18f18ef
msgid ""
"Another way of inspecting intermediate values is to use a ``case`` "
"expression. The following function, for example, splits a string into two"
" at a given character:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1341 9b6528b85f574d92919feed1a9e67b7b
msgid ""
"``break`` is a library function which breaks a string into a pair of "
"strings at the point where the given function returns true. We then "
"deconstruct the pair it returns, and remove the first character of the "
"second string."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1346 1eaafd6760194c2da759d106984a9c28
msgid ""
"A ``case`` expression can match several cases, for example, to inspect an"
" intermediate value of type ``Maybe a``. Recall ``list_lookup`` which "
"looks up an index in a list, returning ``Nothing`` if the index is out of"
" bounds. We can use this to write ``lookup_default``, which looks up an "
"index and returns a default value if the index is out of bounds:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1360 02e7b25f173a4b41bc50488484734255
msgid ""
"If the index is in bounds, we get the value at that index, otherwise we "
"get a default value:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1371 29c20daf4d3844608e0979bd2b9473c9
msgid "Totality"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1373 b6f0456bcf114af3b2c63d92c5ef27e0
msgid ""
"Idris distinguishes between *total* and *partial* functions. A total "
"function is a function that either:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1376 2a1a7d280b15401889730b7012e38647
msgid "Terminates for all possible inputs, or"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1377 425380fb2cc6443db120061458c0c7cb
msgid "Produces a non-empty, finite, prefix of a possibly infinite result"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1379 46da799ce7134cf493336cbd42576548
msgid ""
"If a function is total, we can consider its type a precise description of"
" what that function will do. For example, if we have a function with a "
"return type of ``String`` we know something different, depending on "
"whether or not it's total:"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1384 f84da1a3963e4eb787e3ffa656071088
msgid "If it's total, it will return a value of type ``String`` in finite time;"
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1385 ea0639984e5c42c1b4d134da6003ba6c
msgid ""
"If it's partial, then as long as it doesn't crash or enter an infinite "
"loop, it will return a ``String``."
msgstr ""

#: ../../source/tutorial/typesfuns.rst:1388 07a7bebaeb924b37b464c347bf9ec802
msgid ""
"Idris makes this distinction so that it knows which functions are safe to"
" evaluate while type checking (as we've seen with :ref:`sect-fctypes`). "
"After all, if it tries to evaluate a function during type checking which "
"doesn't terminate, then type checking won't terminate! Therefore, only "
"total functions will be evaluated during type checking. Partial functions"
" can still be used in types, but will not be evaluated further."
msgstr ""

