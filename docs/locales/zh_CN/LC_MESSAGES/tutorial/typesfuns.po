# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: 467195537@qq.com\n"
"POT-Creation-Date: 2022-07-12 11:10+0800\n"
"PO-Revision-Date: 2022-07-22 00:29+0000\n"
"Last-Translator: Leo Liu <leo19920823@gmail.com>\n"
"Language-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/"
"idris2/tutorialtypesfuns/zh_Hans/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.14-dev\n"

#: ../../source/tutorial/typesfuns.rst:5 25f9a49e6a31495197f5141cd8dd0bb6
msgid "Types and Functions"
msgstr "类型和函数"

#: ../../source/tutorial/typesfuns.rst:8 476ccd0e15574f7bb673f6b7c6c40747
msgid "Primitive Types"
msgstr "原语类型"

#: ../../source/tutorial/typesfuns.rst:10 6fc4e0ab8441460aa60cddd7b383e5a0
msgid ""
"Idris defines several primitive types: ``Int``, ``Integer`` and ``Double`` "
"for numeric operations, ``Char`` and ``String`` for text manipulation, and "
"``Ptr`` which represents foreign pointers. There are also several data types "
"declared in the library, including ``Bool``, with values ``True`` and "
"``False``. We can declare some constants with these types. Enter the "
"following into a file ``Prims.idr`` and load it into the Idris interactive "
"environment by typing ``idris2 Prims.idr``:"
msgstr ""
"Idris 定义了几个原语类型。 ``Int`` , ``Integer`` 和 ``Double`` 用于数字操作，"
" ``Char`` 和 ``String`` 用于文本操作，以及 ``Ptr`` "
"表示外来指针。库中还声明了几种数据类型，包括 ``Bool`` ，其值为 ``True`` 和 "
"``False`` 。我们可以用这些类型声明一 些常量。在文件 ``Prims.idr`` "
"中输入以下内容，并通过输入 ``idris2 Prims.idr`` 将其加载到 Idris 交互环境中："

#: ../../source/tutorial/typesfuns.rst:34 d2f6789c0a9141a7bd5e4cbca464089f
msgid ""
"An Idris file consists of an optional module declaration (here ``module "
"Prims``) followed by an optional list of imports and a collection of "
"declarations and definitions. In this example no imports have been "
"specified. However Idris programs can consist of several modules and the "
"definitions in each module each have their own namespace. This is discussed "
"further in Section :ref:`sect-namespaces`. When writing Idris programs both "
"the order in which definitions are given and indentation are significant. "
"Functions and data types must be defined before use, incidentally each "
"definition must have a type declaration, for example see ``x : Int``, "
"``foo : String``, from the above listing. New declarations must begin at the "
"same level of indentation as the preceding declaration. Alternatively, a "
"semicolon ``;`` can be used to terminate declarations."
msgstr ""
"一个 Idris 文件由一个可选的模块声明（这里是 ``module Prims`` ）组成，后面是可"
"选的导入列表和声明与定义的集合。在这个例子中没有指定导入。然而 Idris 程序可以"
"由几个模块组成，每个模块的定义都有自己的命名空间。这将在 :ref:`sect-"
"namespaces` 部分进一步讨论。当编写 Idris 程序时，定义的顺序和缩进都很重要。函"
"数和数据类型必须在使用前定义，顺便说一下，每个定义都必须有一个类型声明，例如"
"上面列表中的 ``x : Int`` , ``foo : String`` ,。新的声明必须从与前一个声明相同"
"的缩进层次开始。或者用分号 ``;`` 来终止声明。"

#: ../../source/tutorial/typesfuns.rst:48 dacb93e27b324fb191373fd2bcc6d8ef
msgid ""
"A library module ``prelude`` is automatically imported by every Idris "
"program, including facilities for IO, arithmetic, data structures and "
"various common functions. The prelude defines several arithmetic and "
"comparison operators, which we can use at the prompt. Evaluating things at "
"the prompt gives an answer, for example:"
msgstr ""
"库模块 ``prelude`` 会被每个 Idris 程序自动导入，包括 IO 、算术、数据结构和各"
"种常用函数的设施。preclude 模块定义了几个算术和比较运算符，我们可以在提示符下"
"使用。在提示符下对事物进行求值会得到一个答案，例如："

#: ../../source/tutorial/typesfuns.rst:61 85ff232364184dbfafb0ca6da54cde08
msgid ""
"All of the usual arithmetic and comparison operators are defined for the "
"primitive types. They are overloaded using interfaces, as we will discuss in "
"Section :ref:`sect-interfaces` and can be extended to work on user defined "
"types. Boolean expressions can be tested with the ``if...then...else`` "
"construct, for example:"
msgstr ""
"所有常见的算术和比较运算符都是被定义为原语类型的。它们通过接口被重载，"
"我们将在 :ref:`sect-interfaces` "
"一节中讨论，并且可以被扩展到用户定义的类型上工作。例如，布尔表达式可以用 "
"``if...then...else`` 构建来测试："

#: ../../source/tutorial/typesfuns.rst:73 0f8b86288a204a8090114c38d31197b5
msgid "Data Types"
msgstr "数据类型"

#: ../../source/tutorial/typesfuns.rst:75 9f6bbef6026543df9b0e40cc71fc3b74
msgid ""
"Data types are declared in a similar way and with similar syntax to Haskell. "
"Natural numbers and lists, for example, can be declared as follows:"
msgstr ""
"数据类型的声明方式和语法与 Haskell 类似。例如，自然数和列表可以被声明如下："

#: ../../source/tutorial/typesfuns.rst:85 a0e134b23314405097c382fcfbf69ae8
msgid ""
"Data type names cannot begin with a lower case letter (we will see later why "
"not!).  The above declarations are taken from the standard library. Unary "
"natural numbers can be either zero (``Z``), or the successor of another "
"natural number (``S k``). Lists can either be empty (``Nil``) or a value "
"added to the front of another list (``x :: xs``). In the declaration for "
"``List``, we used an infix operator ``::``. New operators such as this can "
"be added using a fixity declaration, as follows:"
msgstr ""
"数据类型名称不能以小写字母开头（我们将在后面看到为什么不可以！）。 上面的声明"
"来自标准库。一进制自然数可以是零 (``Z``)，也可以是另一个自然数的后继者 (``S "
"k``)。列表可以是空的 (``Nil`` )，也可以是添加到另一个列表前面的值 (``x :: "
"xs`` )。在 ``List`` 的声明中，我们使用了一个 infix 运算符 ``::`` 。像这样的新"
"运算符可以使用缀序声明来添加，如下所示："

#: ../../source/tutorial/typesfuns.rst:97 fffcbf84b2524a2d95249698fd4f3cfe
msgid ""
"Functions, data constructors and type constructors may all be given infix "
"operators as names. They may be used in prefix form if enclosed in brackets, "
"e.g. ``(::)``. Infix operators can use any of the symbols:"
msgstr ""
"函数、数据构造器和类型构造器都可以被赋予 infix 运算符作为名称。它们可以以前缀"
"的形式使用，如果用括号括起来，例如： ``(::)`` 。中缀运算符可以使用任何符号："

#: ../../source/tutorial/typesfuns.rst:106 85a8741c864d455c94a0c0d25bb80932
msgid ""
"Some operators built from these symbols can't be user defined. These are"
msgstr "一些由这些符号构建的运算符不能被用户定义。这些是"

#: ../../source/tutorial/typesfuns.rst:108 1e7fa3b7966d4ebc90cc098b5988aa7d
msgid ""
"``%``, ``\\``, ``:``, ``=``, ``|``, ``|||``, ``<-``, ``->``, ``=>``, ``?``, "
"``!``, ``&``, ``**``, ``..``"
msgstr ""
"``%``, ``\\``, ``:``, ``=``, ``|``, ``|||``, ``<-``, ``->``, ``=>``, ``?``, "
"``!``, ``&``, ``**``, ``..``"

#: ../../source/tutorial/typesfuns.rst:112 72e2603c0d064ce995d010baa2cbddb5
msgid "Functions"
msgstr "函数"

#: ../../source/tutorial/typesfuns.rst:114 451012a1ef754beca1d5b96185f5bb5c
msgid ""
"Functions are implemented by pattern matching, again using a similar syntax "
"to Haskell. The main difference is that Idris requires type declarations for "
"all functions, using a single colon ``:`` (rather than Haskell’s double "
"colon ``::``). Some natural number arithmetic functions can be defined as "
"follows, again taken from the standard library:"
msgstr ""
"函数是通过模式匹配实现的，同样使用与 Haskell 类似的语法。主要的区别是 Idris "
"要求所有函数的类型声明使用单冒号 ``:`` (而不是Haskell的双冒号 ``::`` ）。一些"
"自然数算术函数可以定义如下，同样取自标准库："

#: ../../source/tutorial/typesfuns.rst:133 1f494f35a2f0475c9b6662e759d0cafa
msgid ""
"The standard arithmetic operators ``+`` and ``*`` are also overloaded for "
"use by ``Nat``, and are implemented using the above functions. Unlike "
"Haskell, there is no restriction on whether function names must begin with a "
"capital letter or not. Function names (``plus`` and ``mult`` above), data "
"constructors (``Z``, ``S``, ``Nil`` and ``::``) and type constructors "
"(``Nat`` and ``List``) are all part of the same namespace. By convention, "
"however, data types and constructor names typically begin with a capital "
"letter. We can test these functions at the Idris prompt:"
msgstr ""
"标准的算术运算符 ``+`` 和 ``*`` 也被重载，供 ``Nat`` 使用，并用上述函数实现。"
"与 Haskell 不同，对函数名是否必须以大写字母开头没有任何限制。函数名 (上面的 "
"``plus`` 和 ``mult`` )、数据构造函数 ( ``Z``, ``S``, ``Nil`` 和 ``::``) 和类"
"型构造函数 ( ``Nat`` 和 ``List``) 都属于同一个命名空间。然而，根据惯例，数据"
"类型和构造函数名称通常以大写字母开头。我们可以在 Idris 提示下测试这些函数："

#: ../../source/tutorial/typesfuns.rst:150 0e433ef1748e4ccfa3d405f7ea757724
msgid ""
"Like arithmetic operations, integer literals are also overloaded using "
"interfaces, meaning that we can also test the functions as follows:"
msgstr ""
"和算术运算一样，整数字面量也是使用接口重载的，这意味着我们也可以按如下方式测"
"试函数："

#: ../../source/tutorial/typesfuns.rst:160 388493f95afc4f7aa137be463c8bc4e7
msgid ""
"You may wonder, by the way, why we have unary natural numbers when our "
"computers have perfectly good integer arithmetic built in. The reason is "
"primarily that unary numbers have a very convenient structure which is easy "
"to reason about, and easy to relate to other data structures as we will see "
"later. Nevertheless, we do not want this convenience to be at the expense of "
"efficiency. Fortunately, Idris knows about the relationship between ``Nat`` "
"(and similarly structured types) and numbers. This means it can optimise the "
"representation, and functions such as ``plus`` and ``mult``."
msgstr ""
"顺便说一下，你可能会想知道，既然我们的计算机已经内置了完美的整数运算，为什么"
"我们还有一进制自然数。原因主要是一进制自然数有一个非常方便的结构，容易推理，"
"而且容易与其他数据结构联系起来，我们将在后面看到。尽管如此，我们并不希望这种"
"方便是以牺牲效率为代价的。幸运的是， Idris 知道 ``Nat`` （和类似的结构化类"
"型）和数字之间的关系。这意味着它可以优化表示，以及诸如 ``plus`` 和 ``mult`` "
"等函数。"

#: ../../source/tutorial/typesfuns.rst:171 b06d281c2e83484abf4d56d2d9088c9b
msgid "``where`` clauses"
msgstr "``where`` 从句"

#: ../../source/tutorial/typesfuns.rst:173 22a0dbd0944645e19fc8fdcd8d27b2e1
msgid ""
"Functions can also be defined *locally* using ``where`` clauses. For "
"example, to define a function which reverses a list, we can use an auxiliary "
"function which accumulates the new, reversed list, and which does not need "
"to be visible globally:"
msgstr ""
"也可以使用 ``where`` 从句在 *本地* 定义函数。例如，为了定义一个反转列表的函"
"数，我们可以使用一个辅助函数来累积新的反转后的列表，而这个函数不需要全局可"
"见："

#: ../../source/tutorial/typesfuns.rst:186 0f4accfaf6af48ad82667cc58c65272a
msgid ""
"Indentation is significant — functions in the ``where`` block must be "
"indented further than the outer function."
msgstr "缩进是很重要的 -- ``where`` 块中的函数必须比外部函数有更深的缩进层次。"

#: ../../source/tutorial/typesfuns.rst:189 69176313a1c14c33b241efbbfb304f82
msgid "Scope"
msgstr "作用域"

#: ../../source/tutorial/typesfuns.rst:191 ba6fa22c1ea24ebc932069ff305e51f2
msgid ""
"Any names which are visible in the outer scope are also visible in the "
"``where`` clause (unless they have been redefined, such as ``xs`` here). A "
"name which appears in the type will be in scope in the ``where`` clause."
msgstr ""
"任何在外层作用域中可见的名字在 ``where`` 从句中也是可见的（除非它们被重新定"
"义，例如这里的 ``xs`` ）。在类型声明中出现的名字也将在 ``where`` 从句的作用域"
"内。"

#: ../../source/tutorial/typesfuns.rst:196 817faac30e224b868853486c3f0e0ddb
msgid ""
"As well as functions, ``where`` blocks can include local data declarations, "
"such as the following where ``MyLT`` is not accessible outside the "
"definition of ``foo``:"
msgstr ""
"除了函数， ``where`` 块也可以包括本地数据类型声明，比如下面的 ``MyLT`` 在 "
"``foo`` 的定义之外不能访问："

#: ../../source/tutorial/typesfuns.rst:212 bd5bbff2377a4403b904204e744c1f97
msgid ""
"Functions defined in a ``where`` clause need a type declaration just like "
"any top level function. Here is another example of how this works in "
"practice:"
msgstr ""
"在 ``where`` 从句中定义的函数需要一个类型声明，就像任何顶层函数一样。下面是另"
"一个例子，说明这在实践中是如何工作的："

#: ../../source/tutorial/typesfuns.rst:238 f790cba5c9694329aa72a3ba5f819e66
msgid "Totality and Covering"
msgstr "完全性和覆盖性"

#: ../../source/tutorial/typesfuns.rst:240 d7635c8fb8c546b1b96db92b526cdba6
msgid ""
"By default, functions in Idris must be ``covering``. That is, there must be "
"patterns which cover all possible values of the inputs types. For example, "
"the following definition will give an error:"
msgstr ""
"默认情况下，Idris 的函数必须是 ``covering`` 。也就是说，必须有涵盖输入类型的"
"所有可能值的模式。例如，下面的定义将给出一个错误："

#: ../../source/tutorial/typesfuns.rst:249 9319ddde3f194c4caf8c2b1e756af37b
msgid ""
"This gives an error because ``fromMaybe Nothing`` is not defined. Idris "
"reports:"
msgstr ""
"这给出了一个错误，因为 ``fromMaybe Nothing`` 没有定义。Idris会输出报告："

#: ../../source/tutorial/typesfuns.rst:257 eb8e98e2c6e1412fb9b185ae56b14e64
msgid "You can override this with a ``partial`` annotation:"
msgstr "你可以用 ``partial`` 注解来忽略这一警告。"

#: ../../source/tutorial/typesfuns.rst:264 d7408089ceb2472fbd6864f5645114ed
msgid ""
"However, this is not advisable, and in general you should only do this "
"during the initial development of a function, or during debugging.  If you "
"try to evaluate ``fromMaybe Nothing`` at run time you will get a run time "
"error."
msgstr ""
"然而，这并不可取，一般来说，你只应该在函数的初始开发过程中，或者在调试过程中"
"这样做。 如果你试图在运行时对 ``fromMaybe Nothing`` 进行求值，你将得到一个运"
"行时错误。"

#: ../../source/tutorial/typesfuns.rst:269 9daa5c0d1877453da71dc9593f31221f
msgid "Holes"
msgstr "孔"

#: ../../source/tutorial/typesfuns.rst:271 dfde6615a3664969b0176b46173eb850
msgid ""
"Idris programs can contain *holes* which stand for incomplete parts of "
"programs. For example, we could leave a hole for the greeting in our \"Hello "
"world\" program:"
msgstr ""
"Idris 程序可以包含 *孔* ，代表程序的不完整部分。例如，我们可以在我们的 \n"
" \"Hello world \" 程序中为问候语留下一个洞："

#: ../../source/tutorial/typesfuns.rst:280 947dc6155feb4992aa89d594d2a6e68e
msgid ""
"The syntax ``?greeting`` introduces a hole, which stands for a part of a "
"program which is not yet written. This is a valid Idris program, and you can "
"check the type of ``greeting``:"
msgstr ""
"语法 ``?greeting`` 引入了一个孔，它代表程序中尚未编写的一部分。这是一个有效的"
"I dris 程序，你可以检查 ``greeting`` 的类型："

#: ../../source/tutorial/typesfuns.rst:290 ad37a003080441fdac3d0368a3fdb686
msgid ""
"Checking the type of a hole also shows the types of any variables in scope. "
"For example, given an incomplete definition of ``even``:"
msgstr ""
"检查一个孔的类型也会显示作用域内任何变量的类型。例如，给定一个不完整的定义 "
"``even`` ："

#: ../../source/tutorial/typesfuns.rst:299 f6b964351d194e62b5278eadbacc496d
msgid ""
"We can check the type of ``even_rhs`` and see the expected return type, and "
"the type of the variable ``k``:"
msgstr ""
"我们可以检查 ``even_rhs`` 的类型，看到预期的返回类型，以及变量 ``k`` 的类型："

#: ../../source/tutorial/typesfuns.rst:309 8238ee576bac4f3eb219b455ae46d5e9
msgid ""
"Holes are useful because they help us write functions *incrementally*. "
"Rather than writing an entire function in one go, we can leave some parts "
"unwritten and use Idris to tell us what is necessary to complete the "
"definition."
msgstr ""
"孔的用途在于可以帮助我们 *渐进的* 写函数。与其一次写完整个函数，我们可以留下"
"一些部分不写，Idris 会告诉我们完还需要完成哪些内容。"

#: ../../source/tutorial/typesfuns.rst:315 72a41350538e4a0ba60d600762fcf4d4
msgid "Dependent Types"
msgstr "依赖类型"

#: ../../source/tutorial/typesfuns.rst:320 f22a2deeb24c4c5ca8bd3e916c3bde90
msgid "First Class Types"
msgstr "一等类型"

#: ../../source/tutorial/typesfuns.rst:322 8c141ac06276419a8e0d27e573c354ca
msgid ""
"In Idris, types are first class, meaning that they can be computed and "
"manipulated (and passed to functions) just like any other language "
"construct. For example, we could write a function which computes a type:"
msgstr ""
"在 Idris 中，类型是一类公民，意味着它们可以像其他语言结构一样被计算和操作（并"
"传递给函数）。例如，我们可以写一个函数来计算一个类型："

#: ../../source/tutorial/typesfuns.rst:332 763e213763104c43bdcead06e88fde30
msgid ""
"This function calculates the appropriate type from a ``Bool`` which flags "
"whether the type should be a singleton or not. We can use this function to "
"calculate a type anywhere that a type can be used. For example, it can be "
"used to calculate a return type:"
msgstr ""
"这个函数从一个 ``Bool`` 值计算出适当的类型，这个 ``Bool`` 值表示是否是一个单"
"例。我们可以在任何可以使用类型的地方使用这个函数来计算一个类型。例如，它可以"
"被用来计算一个返回类型："

#: ../../source/tutorial/typesfuns.rst:343 9c71637b446e4591a403482a582e7eaf
msgid ""
"Or it can be used to have varying input types. The following function "
"calculates either the sum of a list of ``Nat``, or returns the given "
"``Nat``, depending on whether the singleton flag is true:"
msgstr ""
"或者它可以用在输入类型上。以下函数计算 ``Nat`` 列表的总和，或返回给定的 "
"``Nat`` ，具体取决于单例标志是否为真："

#: ../../source/tutorial/typesfuns.rst:355 c27428c4d14e4502b3cbf9fab71f63cc
msgid "Vectors"
msgstr "向量"

#: ../../source/tutorial/typesfuns.rst:357 1375a5fd289842d58904c450db283229
msgid ""
"A standard example of a dependent data type is the type of “lists with "
"length”, conventionally called vectors in the dependent type literature. "
"They are available as part of the Idris library, by importing ``Data.Vect``, "
"or we can declare them as follows:"
msgstr ""
"依赖数据类型的一个标准例子是 \"有长度的列表\" 类型，在依赖类型文献中习惯上称"
"为向量。它们作为 Idris 库的一部分，可以通过 ``Data.Vect`` 导入，或者我们可以"
"像这样声明它们："

#: ../../source/tutorial/typesfuns.rst:368 47ddcc9590424be89ea76a891ae0a1f8
msgid ""
"Note that we have used the same constructor names as for ``List``. Ad-hoc "
"name overloading such as this is accepted by Idris, provided that the names "
"are declared in different namespaces (in practice, normally in different "
"modules). Ambiguous constructor names can normally be resolved from context."
msgstr ""
"注意，我们使用了与 ``List`` 相同的构造函数名称。Idris 接受这样的临时名称重载"
"，只要这些名称是在不同的命名空间（在实践中，通常是在不同的模块中）声明的。有"
"歧义的构造函数名称通常可以通过不同的上下文来解决。"

#: ../../source/tutorial/typesfuns.rst:374 934800cf98ce4187a6523b606510fc49
msgid ""
"This declares a family of types, and so the form of the declaration is "
"rather different from the simple type declarations above. We explicitly "
"state the type of the type constructor ``Vect`` — it takes a ``Nat`` and a "
"type as an argument, where ``Type`` stands for the type of types. We say "
"that ``Vect`` is *indexed* over ``Nat`` and *parameterised* by ``Type``. "
"Each constructor targets a different part of the family of types. ``Nil`` "
"can only be used to construct vectors with zero length, and ``::`` to "
"construct vectors with non-zero length. In the type of ``::``, we state "
"explicitly that an element of type ``a`` and a tail of type ``Vect k a`` (i."
"e., a vector of length ``k``) combine to make a vector of length ``S k``."
msgstr ""
"这声明了一个类型族，因此声明的形式与上面的简单类型声明相当不同。"
"我们明确说明类型构造函数 ``Vect`` 的类型 -- 它接受一个 ``Nat`` "
"和一个类型作为参数，其中 ``Type`` 代表类型的类型。我们说 ``Vect`` 是在 "
"``Nat`` 上建立 *索引* 的 ，并且通过 ``Type`` *参数化* "
"。每个构造函数针对类型族的不同部分。 ``Nil`` 只能用来构造零长度的向量，而 "
"``::`` 用来构造非零长度的向量。在 ``::`` 的类型中，我们明确指出，一个类型为 "
"``a`` 的元素和一个类型为 ``Vect k a`` 的尾部（即一个长度为 ``k`` 的向量）"
"组合成一个长度为 ``S k`` 的向量。"

#: ../../source/tutorial/typesfuns.rst:386 3f44841af1cb4874af25fc0c36e75e3a
msgid ""
"We can define functions on dependent types such as ``Vect`` in the same way "
"as on simple types such as ``List`` and ``Nat`` above, by pattern matching. "
"The type of a function over ``Vect`` will describe what happens to the "
"lengths of the vectors involved. For example, ``++``, defined as follows, "
"appends two ``Vect``:"
msgstr ""
"我们可以通过模式匹配的方式，在 ``Vect`` 这样的依赖类型上定义函数，就像在上面 "
"``List`` 和 ``Nat`` 这样的简单类型上一样。 ``Vect`` "
"上的函数的类型将描述涉及到的向量的长度会发生什么。例如，下面定义的 ``++`` "
"用于链接两个 ``Vect`` ："

#: ../../source/tutorial/typesfuns.rst:398 781d8e93c57c49d78b8ff078510805e6
msgid ""
"The type of ``(++)`` states that the resulting vector’s length will be the "
"sum of the input lengths. If we get the definition wrong in such a way that "
"this does not hold, Idris will not accept the definition. For example:"
msgstr "``(++)`` 的类型指出，结果向量的长度将是输入长度的总和。如果我们把定义弄错了，"
"使之不成立，Idris 将不接受这个定义。例如："

#: ../../source/tutorial/typesfuns.rst:409 6c7ef4ccf70f4e44818a0a0c1465b174
msgid "When run through the Idris type checker, this results in the following:"
msgstr "当通过 Idris 类型检查器运行时，这将导致以下结果："

#: ../../source/tutorial/typesfuns.rst:423 ae11d12df29d4d79bdec4242dd274832
msgid ""
"This error message suggests that there is a length mismatch between two "
"vectors — we needed a vector of length ``k + m``, but provided a vector of "
"length ``k + k``."
msgstr ""
"这个错误信息表明，两个向量之间存在长度不匹配 -- 我们需要一个长度为 ``k + m`` "
"的向量，但提供了一个长度为 ``k + k`` 的向量。"

#: ../../source/tutorial/typesfuns.rst:428 1db6f0cf7ccd4053a6cc752b10b32837
msgid "The Finite Sets"
msgstr "有限集"

#: ../../source/tutorial/typesfuns.rst:430 e8bcf3cff7ca4b788b4a9852e841e4bd
msgid ""
"Finite sets, as the name suggests, are sets with a finite number of "
"elements. They are available as part of the Idris library, by importing "
"``Data.Fin``, or can be declared as follows:"
msgstr "有限集，顾名思义，是具有有限数量元素的集合。它作为Idris库的一部分，可以通过 "
"``Data.Fin`` 导入，或者可以按以下方式声明："

#: ../../source/tutorial/typesfuns.rst:440 cefda7c92c044dda90401765534ac840
msgid ""
"From the signature,  we can see that this is a type constructor that takes a "
"``Nat``, and produces a type. So this is not a set in the sense of a "
"collection that is a container of objects, rather it is the canonical set of "
"unnamed elements, as in \"the set of 5 elements,\" for example. Effectively, "
"it is a type that captures integers that fall into the range of zero to ``(n "
"- 1)`` where ``n`` is the argument used to instantiate the ``Fin`` type. For "
"example, ``Fin 5`` can be thought of as the type of integers between 0 and 4."
msgstr ""
"从签名中，我们可以看到这是一个类型构造函数，它接收一个 ``Nat`` ，并产生一个类"
"型。所以，这不是一个表示对象的容器的集合，相反，它是未命名元素的典型集合，例"
"如，\"5个元素的集合\"。实际上，它是一个捕捉零到 ``(n - 1)`` "
"范围内的整数的类型，其中 ``n`` 是用来实例化 ``Fin`` 类型的参数。例如， ``Fin "
"5`` 可以被认为是0到4之间的整数的类型。"

#: ../../source/tutorial/typesfuns.rst:447 13d6f4a8b5ba4e5abf2cabd9f8ad596f
msgid "Let us look at the constructors in greater detail."
msgstr "让我们更详细地看看这些构造函数。"

#: ../../source/tutorial/typesfuns.rst:449 feea9a1d7bfd4266ac82a4930318118b
msgid ""
"``FZ`` is the zeroth element of a finite set with ``S k`` elements; ``FS n`` "
"is the ``n+1``\\ th element of a finite set with ``S k`` elements. ``Fin`` "
"is indexed by a ``Nat``, which represents the number of elements in the set. "
"Since we can’t construct an element of an empty set, neither constructor "
"targets ``Fin Z``."
msgstr ""
"``FZ`` 是具有 ``S k`` 个元素的有限集的第零个元素； ``FS n`` 是具有 ``S k`` "
"元素的有限集的第 ``n+1`` 个元素。 ``Fin`` 由 ``Nat`` "
"索引，它表示集合中元素的数量。因为我们不能构造一个空集的元素，"
"因此也就无法构造出 ``Fin Z`` 。"

#: ../../source/tutorial/typesfuns.rst:455 e748f68b31894b4daf18edb2675a375e
msgid ""
"As mentioned above, a useful application of the ``Fin`` family is to "
"represent bounded natural numbers. Since the first ``n`` natural numbers "
"form a finite set of ``n`` elements, we can treat ``Fin n`` as the set of "
"integers greater than or equal to zero and less than ``n``."
msgstr ""
"如上所述， ``Fin`` 家族的一个有用的应用是表示有界自然数。由于第一个 ``n`` "
"自然数构成了一个由 ``n`` 个元素组成的有限集合，我们可以将 ``Fin n`` "
"作为大于或等于零且小于 ``n`` 的整数集合。"

#: ../../source/tutorial/typesfuns.rst:460 c136bd411f7d4d89abe61d78026642f1
msgid ""
"For example, the following function which looks up an element in a ``Vect``, "
"by a bounded index given as a ``Fin n``, is defined in the prelude:"
msgstr "例如，下面这个函数通过给定一个有界的索引 ``Fin n`` 来查找 ``Vect`` 中的元素。"
"在 prelude 中定义如下："

#: ../../source/tutorial/typesfuns.rst:470 881fd15c022d4f20bd4bc2e1021bd78c
msgid ""
"This function looks up a value at a given location in a vector. The location "
"is bounded by the length of the vector (``n`` in each case), so there is no "
"need for a run-time bounds check. The type checker guarantees that the "
"location is no larger than the length of the vector, and of course no less "
"than zero."
msgstr ""
"这个函数在一个向量的指定位置查找一个值。该位置以向量的长度为界("
"每种情况下都是 ``n``)，所以不需要进行运行时的边界检查。类型检查器保证该位置不"
"大于向量的长度，当然也不小于零。"

#: ../../source/tutorial/typesfuns.rst:476 12b69facc3844d56a438aa99fe7a9184
msgid ""
"Note also that there is no case for ``Nil`` here. This is because it is "
"impossible. Since there is no element of ``Fin Z``, and the location is a "
"``Fin n``, then ``n`` can not be ``Z``. As a result, attempting to look up "
"an element in an empty vector would give a compile time type error, since it "
"would force ``n`` to be ``Z``."
msgstr ""
"还要注意，这里没有 ``Nil`` 的情况。这是因为这是不可能的。因为没有类型为 ``"
"Fin Z`` 且位置是 ``Fin n`` 的元素，那么 ``n`` 不可能是 ``Z`` "
"。因此，试图在一个空向量中查找一个元素，会在编译时产生一个类型错误，"
"因为它将迫使 ``n`` 成为 ``Z`` 。"

#: ../../source/tutorial/typesfuns.rst:483 4e23351f9f8844b5b1f7d527dbb09ca8
msgid "Implicit Arguments"
msgstr "隐式参数"

#: ../../source/tutorial/typesfuns.rst:485 ae548052c79947c2be510074c3a00625
msgid "Let us take a closer look at the type of ``index``:"
msgstr "让我们仔细看看 ``index`` 的类型。"

#: ../../source/tutorial/typesfuns.rst:491 4a594a3643764932a4c652685b55e56e
msgid ""
"It takes two arguments, an element of the finite set of ``n`` elements, and "
"a vector with ``n`` elements of type ``a``. But there are also two names, "
"``n`` and ``a``, which are not declared explicitly. These are *implicit* "
"arguments to ``index``. We could also write the type of ``index`` as:"
msgstr ""
"它需要两个参数，一个是 ``n`` 个元素的有限集，一个是 ``n`` 个元素的向量，"
"类型是 ``a`` 。但是还有两个名字， ``n`` 和 ``a`` ，这两个名字没有被明确声明。"
" ``index`` 使用了 *隐式* 参数 。我们也可以把 ``index`` 的类型写成："

#: ../../source/tutorial/typesfuns.rst:501 fc9ce79eb8444839bf3b9cd0f43a4ced
msgid ""
"Implicit arguments, given with the ``forall`` declaration, are not given in "
"applications of ``index``; their values can be inferred from the types of "
"the ``Fin n`` and ``Vect n a`` arguments. Any name beginning with a lower "
"case letter which appears as a parameter or index in a type declaration, "
"which is not applied to any arguments, will *always* be automatically bound "
"as an implicit argument; this is why data type names cannot begin with a "
"lower case letter. Implicit arguments can still be given explicitly in "
"applications, using ``{a=value}`` and ``{n=value}``, for example:"
msgstr ""
"隐式参数是用``forall``声明的，在 ``index`` 的应用中没有给出；它们的值可以从 "
"``Fin n`` 和 ``Vect n a`` 参数的类型中推测出来。在类型声明中作为参数或索引出"
"现的任何以小写字母开头的名称，如果没有应用于任何参数， *总是* 会自动被绑定为"
"隐式参数；这就是为什么数据类型名称不能以小写字母开头。隐式参数仍然可以在应用"
"程序中明确给出，例如，使用 ``{a=value}`` 和 ``{n=value}`` 。"

#: ../../source/tutorial/typesfuns.rst:517 4e8fb1578718437fa86bcec0ac4b6187
msgid ""
"In fact, any argument, implicit or explicit, may be given a name. We could "
"have declared the type of ``index`` as:"
msgstr "事实上，任何参数，不管是隐式还是显式，都可以被赋予一个名字。我们可以将 "
"``index`` 的类型声明为："

#: ../../source/tutorial/typesfuns.rst:524 dd8a6197dbd74bcbadd0e1ba1b49aca9
msgid ""
"It is a matter of taste whether you want to do this — sometimes it can help "
"document a function by making the purpose of an argument more clear."
msgstr "你是否要这样做是一个品味问题--"
"有时它可以帮助记录一个函数，使参数的目的更加明确。"

#: ../../source/tutorial/typesfuns.rst:528 1f2a2065d25d407cb0e34d25b4cbeb43
msgid ""
"The names of implicit arguments are in scope in the body of the function, "
"although they cannot be used at run time. There is much more to say about "
"implicit arguments - we will discuss the question of what is available at "
"run time, among other things, in Section :ref:`sect-multiplicities`"
msgstr ""
"隐式参数的名字在函数的主体中是有作用域的，尽管它们在运行时不能使用。关于隐式"
"参数还有很多要说的--我们将在 :ref:`sect-multiplicities` "
"一节中讨论在运行时也可以使用的问题，以及其他事项"

#: ../../source/tutorial/typesfuns.rst:534 71e6159ac136491aac4349def4471c74
msgid "Note: Declaration Order and ``mutual`` blocks"
msgstr "注：声明顺序和 ``mutual`` 块"

#: ../../source/tutorial/typesfuns.rst:536 9d0e5d7dfa384a3ab45076b980e5e295
msgid ""
"In general, functions and data types must be defined before use, since "
"dependent types allow functions to appear as part of types, and type "
"checking can rely on how particular functions are defined (though this is "
"only true of total functions; see Section :ref:`sect-totality`). However, "
"this restriction can be relaxed by using a ``mutual`` block, which allows "
"data types and functions to be defined simultaneously:"
msgstr ""
"一般来说，函数和数据类型必须在使用前定义，因为依赖类型允许函数作为类型的一部"
"分出现，而类型检查可以依赖于特定函数的定义方式（尽管这只适用于完全函数；见 "
":ref:`sect-totality`）。然而，可以通过使用 ``mutual`` "
"块来放宽这个限制，它允许数据类型和函数同时被定义："

#: ../../source/tutorial/typesfuns.rst:554 1e50740f260e49f2ab49222ecf839c49
msgid ""
"In a ``mutual`` block, first all of the type declarations are added, then "
"the function bodies. As a result, none of the function types can depend on "
"the reduction behaviour of any of the functions in the block."
msgstr "在 ``mutual`` 块中，首先添加所有的类型声明，然后是函数体。因此，任何一个函数"
"类型都不会依赖于块中其它函数的递归行为。"

#: ../../source/tutorial/typesfuns.rst:559 04b890f801174aaa9e0961da9bb4856c
msgid ""
"Forward declarations can allow you to have more fine-grained control over "
"the order in which mutually defined concepts are declared. This can be "
"useful if you need to mention a datatype's constructor in the type of a "
"mutually defined function, or need to rely on the behaviour of a mutually "
"defined function for something to typecheck."
msgstr ""
"前向声明可以让你对相互定义的概念的声明顺序有更精细的控制。如果你需要在相互定"
"义的函数的类型中提到一个数据类型的构造函数，或者需要依靠相互定义的函数的行为"
"来进行类型检查，这就很有用。"

#: ../../source/tutorial/typesfuns.rst:602 9a6da6537c214a3c89c9a1930ea6ada1
msgid ""
"Placing signature declarations forward can suggest Idris to detect their "
"corresponding mutual definitions."
msgstr "将签名声明放在前面可以建议 Idris 检 测他们相应的相互定义。"

#: ../../source/tutorial/typesfuns.rst:606 953a639c17834b1686f9573889674ab0
msgid "I/O"
msgstr "I/O"

#: ../../source/tutorial/typesfuns.rst:608 56090831dece46eab178e8fb8804fce6
msgid ""
"Computer programs are of little use if they do not interact with the user or "
"the system in some way. The difficulty in a pure language such as Idris — "
"that is, a language where expressions do not have side-effects — is that I/O "
"is inherently side-effecting. So, Idris provides a parameterised type ``IO`` "
"which *describes* the interactions that the run-time system will perform "
"when executing a function:"
msgstr ""
"如果计算机程序不以某种方式与用户或系统互动，那么它们就没有什么用处。像 Idris "
"这样的纯语言 -- 即表达式没有副作用的语言 -- 的困难在于 I/O "
"本质上是有副作用的。因此， Idris 提供了一个参数化的类型 ``IO`` ， *描述* "
"运行时系统在执行一个函数时将执行的交互作用："

#: ../../source/tutorial/typesfuns.rst:619 bce1c9fbc69a419abc441e0c646ce49f
msgid ""
"We’ll leave the definition of ``IO`` abstract, but effectively it describes "
"what the I/O operations to be executed are, rather than how to execute them. "
"The resulting operations are executed externally, by the run-time system. "
"We’ve already seen one I/O program:"
msgstr ""
"我们先给出 ``IO`` 的抽象化定义，但实际上它描述了要执行的 I/O 操作是什么，而不"
"是如何执行它们。由此产生的操作是在外部由运行时系统执行的。我们已经看到了一个"
"I/O程序："

#: ../../source/tutorial/typesfuns.rst:629 2104b38ba729467a9948e21b0b306463
msgid ""
"The type of ``putStrLn`` explains that it takes a string, and returns an I/O "
"action which produces an element of the unit type ``()``. There is a variant "
"``putStr`` which decribes the output of a string without a newline:"
msgstr ""
"``putStrLn`` 的类型说明它接收一个字符串，并返回一个 I/O 动作，"
"产生一个单元类型的元素 ``()`` 。另外它有一个变体 ``putStr`` "
"，它描述了一个没有换行的字符串的输出："

#: ../../source/tutorial/typesfuns.rst:638 167aeaa70acb41eca9d4da707eff3f5a
msgid "We can also read strings from user input:"
msgstr "我们还可以从用户输入中读取字符串："

#: ../../source/tutorial/typesfuns.rst:644 05d47899721f42de9e4ee1af29a8df9d
msgid ""
"A number of other I/O operations are available. For example, by adding "
"``import System.File`` to your program, you get access to functions for "
"reading and writing files, including:"
msgstr "还有一些其他的 I/O 操作可用。例如，通过在你的程序中添加 ``import System."
"File`` ，你可以获得读写文件的函数，包括："

#: ../../source/tutorial/typesfuns.rst:660 e1ff4240c38344418678188d3403d271
msgid "Note that several of these return ``Either``, since they may fail."
msgstr "请注意，其中几个会返回 ``Either`` ，因为它们可能会失败。"

#: ../../source/tutorial/typesfuns.rst:665 26845935c3f34b5d840b2472cf71cbad
msgid "“``do``” notation"
msgstr "“ ``do`` ” 记法"

#: ../../source/tutorial/typesfuns.rst:667 be067a6585db4e6190b9f454d03f2540
msgid ""
"I/O programs will typically need to sequence actions, feeding the output of "
"one computation into the input of the next. ``IO`` is an abstract type, "
"however, so we can’t access the result of a computation directly. Instead, "
"we sequence operations with ``do`` notation:"
msgstr ""
"I/O "
"程序通常需要对行动进行排序，将一个计算的输出输入到下一个计算的输入中。然而， "
"``IO`` 是一个抽象类型，所以我们不能直接访问一个计算的结果。相反，我们用 "
"``do`` 记法来排列操作："

#: ../../source/tutorial/typesfuns.rst:679 e780cd06647947fca9a6a0d5bfcd2a42
msgid ""
"The syntax ``x <- iovalue`` executes the I/O operation ``iovalue``, of type "
"``IO a``, and puts the result, of type ``a`` into the variable ``x``. In "
"this case, ``getLine`` returns an ``IO String``, so ``name`` has type "
"``String``. Indentation is significant — each statement in the do block must "
"begin in the same column. The ``pure`` operation allows us to inject a value "
"directly into an IO operation:"
msgstr ""
"语法 ``x <- iovalue`` 执行I/O操作 ``iovalue`` ，类型为 ``IO a`` ，并将类型为 "
"``a`` 的结果放入变量 ``x`` 。在这种情况下， ``getLine`` 返回一个 ``IO "
"String`` ，所以 ``name`` 具有类型 ``String`` 。缩进很重要 -- do "
"块中的每个语句必须在同一列开始。 ``pure`` 操作允许我们将一个值直接注入到一个 "
"IO 操作中："

#: ../../source/tutorial/typesfuns.rst:690 ce1239b7bee44ffda8a9b64182a01540
msgid ""
"As we will see later, ``do`` notation is more general than this, and can be "
"overloaded."
msgstr "我们将在后面看到， ``do`` 符号比这里展示的更加通用，而且可以重载。"

#: ../../source/tutorial/typesfuns.rst:693 99430d8183424ffaac44b96cca37c168
msgid ""
"You can try executing ``greet`` at the Idris 2 REPL by running the command "
"``:exec greet``:"
msgstr "你可以尝试在 Idris 2 REPL 执行 ``greet`` ，运行命令 ``:exec greet`` ："

#: ../../source/tutorial/typesfuns.rst:704 acfc5853bc714e2486d52ffe1f8d3dbf
msgid "Laziness"
msgstr "惰性"

#: ../../source/tutorial/typesfuns.rst:706 f15aea90d4af444aa4c9fc5e3b6358bc
msgid ""
"Normally, arguments to functions are evaluated before the function itself "
"(that is, Idris uses *eager* evaluation). However, this is not always the "
"best approach. Consider the following function:"
msgstr "通常情况下，函数的参数在函数本身之前被求值（也就是说，Idris使用 *及早* "
"求值策略）。然而，这并不总是最好的方法。考虑一下下面的函数："

#: ../../source/tutorial/typesfuns.rst:716 3fb52069e24e4347a7fff0db1207d161
msgid ""
"This function uses one of the ``t`` or ``e`` arguments, but not both. We "
"would prefer if *only* the argument which was used was evaluated. To achieve "
"this, Idris provides a ``Lazy`` primitive, which allows evaluation to be "
"suspended. It is a primitive, but conceptually we can think of it as follows:"
msgstr ""
"这个函数会使用 ``t`` 或 ``e`` 参数中的一个，而不是两个都用。我们希望 *只有* "
"被使用的参数被求值。为了实现这一点，Idris 提供了一个 ``Lazy`` "
"原语，它允许暂缓求值。它是一个原语，但在概念上我们可以把它看成是这样："

#: ../../source/tutorial/typesfuns.rst:728 4e2d0b0c32ed4cb68641a618f879bdad
msgid ""
"A value of type ``Lazy a`` is unevaluated until it is forced by ``Force``. "
"The Idris type checker knows about the ``Lazy`` type, and inserts "
"conversions where necessary between ``Lazy a`` and ``a``, and vice versa. We "
"can therefore write ``ifThenElse`` as follows, without any explicit use of "
"``Force`` or ``Delay``:"
msgstr ""
"一个 ``Lazy a`` 类型的值是不被求值的，直到它被 ``Force`` 强迫。Idris "
"类型检查器知道 ``Lazy`` 类型，并在必要时插入 ``Lazy a`` 和 ``a`` "
"之间的转换，反之亦然。因此，我们可以这样写 ``ifThenElse`` ，而不需要明确使用 "
"``Force`` 或 ``Delay`` ："

#: ../../source/tutorial/typesfuns.rst:741 04aa9becff1c4b85a6d8acd23dcaf6f7
msgid "Infinite data Types"
msgstr "无限数据类型"

#: ../../source/tutorial/typesfuns.rst:743 ad922d31944c4268838987581a4e442e
msgid ""
"Infinite data types (codata) allow us to define infinite data structures by "
"marking recursive arguments as potentially infinite. One example of an "
"infinite type is Stream, which is defined as follows."
msgstr "我们可以通过余数据类型（codata），将递归参数标记为潜在无穷来定义无限的数据结"
"构。余数据类型的一个例子是Stream，它的定义如下。"

#: ../../source/tutorial/typesfuns.rst:752 8cff199642994bd2817412349742decc
msgid ""
"The following is an example of how the codata type ``Stream`` can be used to "
"form an infinite data structure. In this case we are creating an infinite "
"stream of ones."
msgstr "下面是一个例子，说明余数数据类型 ``Stream`` "
"可以用来形成一个无限的数据结构。在这种情况下，我们正在创建一个无限的 1 的流。"

#: ../../source/tutorial/typesfuns.rst:762 95fcb491526f4a6291cbe89212c044e6
msgid "Useful Data Types"
msgstr "有用的数据类型"

#: ../../source/tutorial/typesfuns.rst:764 d9d717ff9a7f42aaaa5b909219f311dd
msgid ""
"Idris includes a number of useful data types and library functions (see the "
"``libs/`` directory in the distribution, and the `documentation <https://www."
"idris-lang.org/pages/documentation.html>`_). This section describes a few of "
"these, and how to import them."
msgstr ""
"Idris包括一些有用的数据类型和库函数（见发行版中的 ``libs/`` 目录，以及`文档 "
"<https://www.idris-lang.org/pages/documentation.html>`_ "
"）。本节描述了其中一些，以及如何导入它们。"

#: ../../source/tutorial/typesfuns.rst:770 f941eb88370a4f879cab81d65a055ea1
msgid "``List`` and ``Vect``"
msgstr "``List`` 和 ``Vect``"

#: ../../source/tutorial/typesfuns.rst:772 6b4f156154774d08b4e6b4def62ee12e
msgid "We have already seen the ``List`` and ``Vect`` data types:"
msgstr "我们已经看到过 ``List`` 和 ``Vect`` 数据类型："

#: ../../source/tutorial/typesfuns.rst:782 8fcb81d9105e4256807c356d7cf76b5a
msgid ""
"You can get access to ``Vect`` with ``import Data.Vect``. Note that the "
"constructor names are the same for each — constructor names (in fact, names "
"in general) can be overloaded, provided that they are declared in different "
"namespaces (see Section :ref:`sect-namespaces`), and will typically be "
"resolved according to their type. As syntactic sugar, any implementation of "
"the names ``Nil`` and ``::`` can be written in list form. For example:"
msgstr ""
"你可以通过 ``import Data.Vect`` 获得对 ``Vect`` 的访问。请注意，List 和 Vect "
"每个构造函数的名字都是一样的 -- 构造函数的名字（事实上，一般的名字）可以被重"
"载，只要它们被声明在不同的命名空间（见章节 :ref:`sect-namespaces` "
"），并且通常会根据它们的类型来解析。作为语法糖，任何被命名为 ``Nil`` 和 "
"``::`` 的实现都可以写成列表形式。例如："

#: ../../source/tutorial/typesfuns.rst:790 eb69b09b95004211b338ef6671326e86
msgid "``[]`` means ``Nil``"
msgstr "``[]`` 意味着 ``Nil``"

#: ../../source/tutorial/typesfuns.rst:792 f015e033a7e24cebbdc40405d9fc5b3e
msgid "``[1,2,3]`` means ``1 :: 2 :: 3 :: Nil``"
msgstr "``[1,2,3]`` 意味着 ``1 :: 2 :: 3 :: Nil``"

#: ../../source/tutorial/typesfuns.rst:794 982881bbb15848469cd544228014c986
msgid ""
"Similarly, any implementation of the names ``Lin`` and ``:<`` can be written "
"in **snoc**-list form:"
msgstr "同样，任何名称为 ``Lin`` 和 ``:<`` 的实现都可以写成 **snoc**-list 形式："

#: ../../source/tutorial/typesfuns.rst:797 c8d0fed7baa24419bac0e19b2794cd23
msgid "``[<]`` mean ``Lin``"
msgstr "``[<]`` 意味着 ``Lin``"

#: ../../source/tutorial/typesfuns.rst:798 75b47c6b9beb45988f633a5742d3d2a5
msgid "``[< 1, 2, 3]`` means ``Lin :< 1 :< 2 :< 3``."
msgstr "``[< 1, 2, 3]`` 意味着 ``Lin :< 1 :< 2 :< 3``。"

#: ../../source/tutorial/typesfuns.rst:800 098d8b70cb7f4d4486b6ba6030a1d270
msgid "and the prelude includes a pre-defined datatype for snoc-lists:"
msgstr "prelude 包括一个预定义的 snoc-lists 的数据类型："

#: ../../source/tutorial/typesfuns.rst:807 49bf5786e5e640e78c9482799a5d6d68
msgid ""
"The library also defines a number of functions for manipulating these types. "
"``map`` is overloaded both for ``List`` and ``Vect`` (we'll see more details "
"of precisely how later when we cover interfaces in Section :ref:`sect-"
"interfaces`) and applies a function to every element of the list or vector."
msgstr ""
"该库还定义了一些用于操作这些类型的函数。 ``map`` 对 ``List`` 和 ``Vect`` "
"都是重载的（我们将在后面的 :ref:`sect-interfaces` "
"章节中讨论接口时看到更多精确的细节），并对列表或向量的每个元素应用一个函数。"

#: ../../source/tutorial/typesfuns.rst:823 bc8a8c9d31054a708b6b46cac54a8d52
msgid ""
"For example, given the following vector of integers, and a function to "
"double an integer:"
msgstr "例如，给定以下的整数向量，和一个将整数加倍的函数："

#: ../../source/tutorial/typesfuns.rst:834 f57027a4ca364d389cf8294a3eca512a
msgid ""
"the function ``map`` can be used as follows to double every element in the "
"vector:"
msgstr "函数 ``map`` 可用于将向量中的每个元素翻倍："

#: ../../source/tutorial/typesfuns.rst:842 9ea28e896f3a4868b7dd2691cdef12bf
msgid ""
"For more details of the functions available on ``List`` and ``Vect``, look "
"in the library files:"
msgstr "关于 ``List`` 和 ``Vect`` 上的函数的更多细节，请查阅库文件："

#: ../../source/tutorial/typesfuns.rst:845 7cbb428e4e7e4e498b79beab99354ed1
msgid "``libs/base/Data/List.idr``"
msgstr "``libs/base/Data/List.idr``"

#: ../../source/tutorial/typesfuns.rst:847 f673be1f92f448b2934f5313e307fb7d
msgid "``libs/base/Data/Vect.idr``"
msgstr "``libs/base/Data/Vect.idr``"

#: ../../source/tutorial/typesfuns.rst:849 c1e4503ef26d42c19d60e8bcb3099326
msgid "Functions include filtering, appending, reversing, and so on."
msgstr "函数包括过滤、追加、反转等。"

#: ../../source/tutorial/typesfuns.rst:852 9f489d65f9c745488a9d0df659914b90
msgid "Aside: Anonymous functions and operator sections"
msgstr "题外话：匿名函数和操作符段"

#: ../../source/tutorial/typesfuns.rst:854 24e99de770934f85aad67f87d872b030
msgid ""
"There are neater ways to write the above expression. One way would be to use "
"an anonymous function:"
msgstr "有更多的方法来写上述表达式。其中一种方法是使用匿名函数："

#: ../../source/tutorial/typesfuns.rst:862 7d303ad031f249b9a2f2410b1a40cb28
msgid ""
"The notation ``\\x => val`` constructs an anonymous function which takes one "
"argument, ``x`` and returns the expression ``val``. Anonymous functions may "
"take several arguments, separated by commas, e.g. ``\\x, y, z => val``. "
"Arguments may also be given explicit types, e.g. ``\\x : Int => x * 2``, and "
"can pattern match, e.g. ``\\(x, y) => x + y``. We could also use an operator "
"section:"
msgstr ""
"符号 ``\\x => val`` 构建了一个匿名函数，它接受一个参数 ``x`` 并返回表达式 "
"``val`` 。匿名函数可以接受多个参数，用逗号分隔，例如： ``\\x, y, z => val`` "
"。参数也可以被赋予明确的类型，例如： ``\\x : Int => x * 2`` "
"，并且可以模式匹配，例如： ``\\(x, y) => x + y`` "
"。另外我们也可以使用一个操作符段："

#: ../../source/tutorial/typesfuns.rst:874 d7f4ebc9ea8e4340983573571dcd8fec
msgid ""
"``(*2)`` is shorthand for a function which multiplies a number by 2. It "
"expands to ``\\x => x * 2``. Similarly, ``(2*)`` would expand to ``\\x => 2 "
"* x``."
msgstr ""
"``(*2)`` 是一个将一个数字乘以2的函数的缩写。它可以被扩展为 ``\\x => x * 2`` "
"。类似地， ``(2*)`` 将被扩展为 ``\\x => 2 * x`` 。"

#: ../../source/tutorial/typesfuns.rst:879 20efa38f81cf4e4ea0dd6c5bcbb618cf
msgid "Maybe"
msgstr "Maybe"

#: ../../source/tutorial/typesfuns.rst:881 4f0a128a65f24d6eb502e65dd3185622
msgid ""
"``Maybe``, defined in the Prelude, describes an optional value. Either there "
"is a value of the given type, or there isn’t:"
msgstr "``Maybe`` 被定义在 Prelude "
"中，描述了一个可选的值。要么有一个给定类型的值，要么没有："

#: ../../source/tutorial/typesfuns.rst:888 fed64e0ba27d419e9fc0edda14fe1bc1
msgid ""
"``Maybe`` is one way of giving a type to an operation that may fail. For "
"example, looking something up in a ``List`` (rather than a vector) may "
"result in an out of bounds error:"
msgstr "``Maybe`` 是给操作提供类型的一种方式，可能会失败。例如，在 ``List`` "
"（而不是一个向量）中查找东西可能会导致越界错误："

#: ../../source/tutorial/typesfuns.rst:899 2e0800df643541da8a5376c671638cf6
msgid ""
"The ``maybe`` function is used to process values of type ``Maybe``, either "
"by applying a function to the value, if there is one, or by providing a "
"default value:"
msgstr "``maybe`` 函数用于处理 ``Maybe`` "
"类型的值，如果有值可以对该值应用一个函数，或者提供一个默认值后再应用函数："

#: ../../source/tutorial/typesfuns.rst:907 48c7af1270ad4fcf8fb48e9e2e04c300
msgid ""
"Note that the types of the first two arguments are wrapped in ``Lazy``. "
"Since only one of the two arguments will actually be used, we mark them as "
"``Lazy`` in case they are large expressions where it would be wasteful to "
"compute and then discard them."
msgstr ""
"注意，前两个参数的类型被包裹在 ``Lazy`` "
"中。由于这两个参数中只有一个会被实际使用，我们把它们标记为 ``Lazy`` "
"，以防它们是复杂的表达式，计算后再丢弃它们会很浪费。"

#: ../../source/tutorial/typesfuns.rst:913 6d70c805747e499584cb4ea5f43fcc86
msgid "Tuples"
msgstr "元组"

#: ../../source/tutorial/typesfuns.rst:915 ecf6a07d811a4237a37aecb5bce9bbff
msgid "Values can be paired with the following built-in data type:"
msgstr "值可以用以下内置数据类型配对："

#: ../../source/tutorial/typesfuns.rst:921 ac809c323b1344c7beb774ccbfd2a232
msgid ""
"As syntactic sugar, we can write ``(a, b)`` which, according to context, "
"means either ``Pair a b`` or ``MkPair a b``. Tuples can contain an arbitrary "
"number of values, represented as nested pairs:"
msgstr ""
"作为语法糖，我们可以写 ``(a, b)`` ，根据上下文，这意味着 ``Pair a b`` 或 ``"
"MkPair a b`` 。元组可以包含任意数量的值，以嵌套对的形式表示："

#: ../../source/tutorial/typesfuns.rst:943 0fcb1040b4a74bfe8a7cada2ab105d21
msgid "Dependent Pairs"
msgstr "依赖对"

#: ../../source/tutorial/typesfuns.rst:945 0b4c7ed80bb5422a81eed99ac16d08d8
msgid ""
"Dependent pairs allow the type of the second element of a pair to depend on "
"the value of the first element:"
msgstr "依赖对允许一个对中的第二个元素的类型取决于第一个元素的值："

#: ../../source/tutorial/typesfuns.rst:953 5c63122fd5fb4027bf9eb971bb50ba87
msgid ""
"Again, there is syntactic sugar for this. ``(x : a ** p)`` is the type of a "
"pair of A and P, where the name ``x`` can occur inside ``p``. ``( x ** p )`` "
"constructs a value of this type. For example, we can pair a number with a "
"``Vect`` of a particular length:"
msgstr ""
"同样，这也有语法上的糖。 ``(x : a ** p)`` 是一对 A 和 P 的类型，其中名称 "
"``x`` 可以出现在 ``p`` 里面。 ``( x ** p )`` 构建一个该类型的值。例如，"
"我们可以将一个数字与一个特定长度的 ``Vect`` 配对："

#: ../../source/tutorial/typesfuns.rst:963 35c72bdb524e42758b6127018c9e3d16
msgid "If you like, you can write it out the long way; the two are equivalent:"
msgstr "如果你愿意，你可以用长的方式写出来；两者是等同的："

#: ../../source/tutorial/typesfuns.rst:970 4233363971c34981bb776c2b05876250
msgid ""
"The type checker could infer the value of the first element from the length "
"of the vector. We can write an underscore ``_`` in place of values which we "
"expect the type checker to fill in, so the above definition could also be "
"written as:"
msgstr "类型检查器可以从向量的长度推断出第一个元素的值。我们可以写一个下划线``_``来代"
"替我们期望类型检查器填写的值，所以上述定义也可以写成："

#: ../../source/tutorial/typesfuns.rst:980 fea3898488db4a6896d40826c8e808d2
msgid ""
"We might also prefer to omit the type of the first element of the pair, "
"since, again, it can be inferred:"
msgstr "我们也可能倾向于省略这对元素中第一个元素的类型，因为它同样可以被推断出来："

#: ../../source/tutorial/typesfuns.rst:988 9007eb7b50904e00b8d36580d0c28062
msgid ""
"One use for dependent pairs is to return values of dependent types where the "
"index is not necessarily known in advance. For example, if we filter "
"elements out of a ``Vect`` according to some predicate, we will not know in "
"advance what the length of the resulting vector will be:"
msgstr ""
"依赖对的一个用途是返回依赖类型的值，其中的索引不一定事先知道。例如，"
"如果我们根据一些谓词从 ``Vect`` "
"中过滤出元素，我们将不会事先知道所产生的向量的长度："

#: ../../source/tutorial/typesfuns.rst:998 400d194ae9db4cb8afc4a78918b77043
msgid "If the ``Vect`` is empty, the result is:"
msgstr "如果 ``Vect`` 是空的，结果就是："

#: ../../source/tutorial/typesfuns.rst:1004 85aa89279b714475874c74806028ac17
msgid ""
"In the ``::`` case, we need to inspect the result of a recursive call to "
"``filter`` to extract the length and the vector from the result. To do this, "
"we use a ``case`` expression, which allows pattern matching on intermediate "
"values:"
msgstr ""
"在 ``::`` 的情况下，我们需要检查对 ``filter`` "
"的递归调用的结果，从结果中提取长度和矢量。要做到这一点，我们使用 ``case`` "
"表达式，它允许对中间值进行模式匹配："

#: ../../source/tutorial/typesfuns.rst:1018 a496b587cce14aaab826e16dfc4575d8
msgid "Dependent pairs are sometimes referred to as “Sigma types”."
msgstr "依赖对有时被称为 \"Sigma 类型\"。"

#: ../../source/tutorial/typesfuns.rst:1021 28445edc00d643e6823bf866a729603b
msgid "Records"
msgstr "记录"

#: ../../source/tutorial/typesfuns.rst:1023 40a2362ff76345d5a1800a92f8194b17
msgid ""
"*Records* are data types which collect several values (the record's "
"*fields*) together. Idris provides syntax for defining records and "
"automatically generating field access and update functions. Unlike the "
"syntax used for data structures, records in Idris follow a different syntax "
"to that seen with Haskell. For example, we can represent a person’s name and "
"age in a record:"
msgstr ""
"*记录* 是将几个值（记录的*字段* ）收集在一起的数据类型。Idris 提供了定义记录"
"的语法，并自动生成字段访问和更新函数。与用于数据结构的语法不同，Idris "
"中的记录遵循一种与 Haskell "
"不同的语法。例如，我们可以在一个记录中表示一个人的名字和年龄："

#: ../../source/tutorial/typesfuns.rst:1039 a947b4cd326547f3ad88d8362b573eaa
msgid ""
"The constructor name is provided using the ``constructor`` keyword, and the "
"*fields* are then given which are in an indented block following the `where` "
"keyword (here, ``firstName``, ``middleName``, ``lastName``, and ``age``). "
"You can declare multiple fields on a single line, provided that they have "
"the same type. The field names can be used to access the field values:"
msgstr ""
"使用 ``constructor`` 关键字提供构造函数名称，然后给出*字段* ，这些字段在 "
"`where` 关键字之后的缩进块中（这里是 ``firstName`` ， ``middleName`` ， "
"``lastName`` ，和 ``age`` ）。你可以在一行中声明多个字段，只要它们具有相同的"
"类型。字段名可以用来访问字段的值："

#: ../../source/tutorial/typesfuns.rst:1054 68b1d9c12a394ce58e1adf5aa2f63678
msgid "We can use prefix field projections, like in Haskell:"
msgstr "我们可以使用前缀字段投影，就像在Haskell中一样："

#: ../../source/tutorial/typesfuns.rst:1065 0fce4a72adad480398e993b59840f6cc
msgid ""
"Prefix field projections can be disabled per record definition using pragma "
"``%prefix_record_projections off``, which makes all subsequently defined "
"records generate only dotted projections. This pragma has effect until the "
"end of the module or until the closest occurrence of ``"
"%prefix_record_projections on``."
msgstr ""
"可以使用pragma ``%prefix_record_projections off`` 在每条记录的定义中禁用前缀"
"字段投影，这使得所有随后定义的记录只产生点状的投影。这个 pragma "
"在模块结束前或在最近一次出现 ``%prefix_record_projections on`` "
"之前都是有效的。"

#: ../../source/tutorial/typesfuns.rst:1071 995a715813a34304997415f145164a89
msgid ""
"We can also use the field names to update a record (or, more precisely, "
"produce a copy of the record with the given fields updated):"
msgstr "我们还可以使用字段名来更新一条记录（或者更准确地说，产生一个更新了给定字段的"
"记录副本）："

#: ../../source/tutorial/typesfuns.rst:1082 ce305d2931554c7997d513c850e58f1e
msgid ""
"The syntax ``{ field := val, ... }`` generates a function which updates the "
"given fields in a record. ``:=`` assigns a new value to a field, and ``$=`` "
"applies a function to update its value."
msgstr ""
"语法 ``{ field := val, ... }`` 产生一个函数，更新记录中的给定字段。 ``:=`` "
"给一个字段分配一个新的值， ``$=`` 应用一个函数来更新它的值。"

#: ../../source/tutorial/typesfuns.rst:1086 7d31a9d2baf540ba9f6364793d667712
msgid ""
"Each record is defined in its own namespace, which means that field names "
"can be reused in multiple records."
msgstr "每条记录都被定义在自己的命名空间中，这意味着字段名可以在多条记录中重复使用。"

#: ../../source/tutorial/typesfuns.rst:1089 6924d0833a404fffac4a875198f19de8
msgid ""
"Records, and fields within records, can have dependent types. Updates are "
"allowed to change the type of a field, provided that the result is well-"
"typed."
msgstr "记录和记录中的字段可以有依赖类型。允许更新改变一个字段的类型，只要其结果是良"
"类型。"

#: ../../source/tutorial/typesfuns.rst:1100 15398f26f5004171a8ad62eaae799b54
msgid ""
"It is safe to update the ``students`` field to a vector of a different "
"length because it will not affect the type of the record:"
msgstr "将 ``students`` 字段更新为不同长度的向量是安全的，因为它不会影响记录的类型："

#: ../../source/tutorial/typesfuns.rst:1113 f48564e4b0c34ce4977035a2970d4c23
msgid "We could also use ``$=`` to define ``addStudent`` more concisely:"
msgstr "我们也可以用 ``$=`` 来更简洁地定义 ``addStudent`` ："

#: ../../source/tutorial/typesfuns.rst:1121 ec04b75a38814eb89ec6fcc84712e923
msgid "Nested record projection"
msgstr "嵌套记录投影"

#: ../../source/tutorial/typesfuns.rst:1123 4bef749c9f6843a9aa0d46cbed900e9f
msgid "Nested record fields can be accessed using the dot notation:"
msgstr "嵌套的记录字段可以使用点符号访问："

#: ../../source/tutorial/typesfuns.rst:1130 e5d54a42c57e4d69bf1f3bafb7a9f3e9
msgid ""
"For the dot notation, there must be no spaces after the dots but there may "
"be spaces before the dots. The composite projection must be parenthesised, "
"otherwise ``map .a.b.c xs`` would be understood as ``map.a.b.c xs``."
msgstr ""
"对于点符号，点后不能有空格，但是点前可以有空格。合成投影必须有括号，否则 ``"
"map .a.b.c xs`` 将被理解为 ``map.a.b.c xs`` 。"

#: ../../source/tutorial/typesfuns.rst:1134 817ef356681a4a61bf84956997e4afeb
msgid "Nested record fields can be accessed using the prefix notation, too:"
msgstr "嵌套的记录字段也可以用前缀符号访问："

#: ../../source/tutorial/typesfuns.rst:1141 3f06e1a701d4471ca504d6a69bfbd265
msgid "Dots with spaces around them stand for function composition operators."
msgstr "周围有空格的点代表函数组合运算符。"

#: ../../source/tutorial/typesfuns.rst:1144 0fd3955931304f789e1afe3963433820
msgid "Nested record update"
msgstr "嵌套记录更新"

#: ../../source/tutorial/typesfuns.rst:1146 b2f42aaeb6334a10a335a656d7f33c20
msgid ""
"Idris also provides a convenient syntax for accessing and updating nested "
"records. For example, if a field is accessible with the expression ``x.a.b."
"c``, it can be updated using the following syntax:"
msgstr ""
"Idris 还提供了一个方便的语法来访问和更新嵌套记录。例如，"
"如果一个字段可以用表达式 ``x.a.b.c`` 来访问，它可以用以下语法来更新："

#: ../../source/tutorial/typesfuns.rst:1155 9f818b412b304e74a9781b40fc2a8519
msgid ""
"This returns a new record, with the field accessed by the path ``a.b.c`` set "
"to ``val``. The syntax is first class, i.e. ``{ a.b.c := val }`` itself has "
"a function type."
msgstr ""
"这将返回一个新的记录，由路径 ``a.b.c`` 访问的字段被设置为 ``val`` "
"。语法也是一等的，即 ``{ a.b.c := val }`` 本身有一个函数类型。"

#: ../../source/tutorial/typesfuns.rst:1159 06afaf4616a343b9ab02eb9b9d5dbaf9
msgid "The ``$=`` notation is also valid for nested record updates."
msgstr "``$=`` 符号对嵌套的记录更新也有效。"

#: ../../source/tutorial/typesfuns.rst:1162 3e23ba2e75c94e539ef5b131309a5e77
msgid "Dependent Records"
msgstr "依赖记录"

#: ../../source/tutorial/typesfuns.rst:1164 21b8885897c94070b2027651d39c8fc5
msgid ""
"Records can also be dependent on values. Records have *parameters*, which "
"cannot be updated like the other fields. The parameters appear as arguments "
"to the resulting type, and are written following the record type name. For "
"example, a pair type could be defined as follows:"
msgstr ""
"记录也可以依赖于数值。记录有 *参数* ，这些参数不能像其他字段一样被更新。参数"
"作为结果类型的参数出现，并写在记录类型名称的后面。例如，一个对类型可以定义如"
"下："

#: ../../source/tutorial/typesfuns.rst:1176 e8d4293d7ced44a7b26a747a2695f1c7
msgid ""
"Using the ``Class`` record from earlier, the size of the class can be "
"restricted using a ``Vect`` and the size included in the type by "
"parameterising the record with the size.  For example:"
msgstr "使用前面的 ``Class`` 记录，可以用 ``Vect`` "
"来限制类的大小，并通过对记录的大小进行参数化，将大小纳入类型。 例如："

#: ../../source/tutorial/typesfuns.rst:1187 3c41a582cff942fd83f522e1b63dbfab
msgid ""
"In the case of ``addStudent`` earlier, we can still add a student to a "
"``SizedClass`` since the size is implicit, and will be updated when a "
"student is added:"
msgstr ""
"在前面 ``addStudent`` 的情况下，我们仍然可以在 ``SizedClass`` "
"上添加一个学生，因为大小是隐含的，当添加一个学生的时候大小会被更新："

#: ../../source/tutorial/typesfuns.rst:1196 7f6bb7f6983048ed9fa19df59ebf6981
msgid ""
"In fact, the dependent pair type we have just seen is, in practice, defined "
"as a record, with fields ``fst`` and ``snd`` which allow projecting values "
"out of the pair:"
msgstr "事实上，我们刚才看到的依赖对类型在实践中被定义为一条记录，其字段 ``fst`` 和 "
"``snd`` 允许从依赖对中投影出数值："

#: ../../source/tutorial/typesfuns.rst:1207 96664233dfc34452866e642d2182cf70
msgid ""
"It is possible to use record update syntax to update dependent fields, "
"provided that all related fields are updated at once. For example:"
msgstr "可以使用记录更新语法来更新依赖字段，前提是所有相关字段都要一次性更新。例如："

#: ../../source/tutorial/typesfuns.rst:1217 a4fabe57d83d46789eefa55a8da7e11d
msgid "Or even:"
msgstr "甚至可以更省事："

#: ../../source/tutorial/typesfuns.rst:1230 93de1bc4e2b44c48add6c81eb0a8874d
msgid "More Expressions"
msgstr "更多表达式"

#: ../../source/tutorial/typesfuns.rst:1235 a8ad953aea2d437ead4629e36d8a64c9
msgid "``let`` bindings"
msgstr "``let`` 绑定"

#: ../../source/tutorial/typesfuns.rst:1237 c9dfea52d92d4441b5124c084afb468e
msgid "Intermediate values can be calculated using ``let`` bindings:"
msgstr "计算出的中间值可以使用 ``let`` 来绑定到变量："

#: ../../source/tutorial/typesfuns.rst:1245 1310dc4f599a40dbbaf44a23735148d4
msgid ""
"We can do pattern matching in ``let`` bindings too. For example, we can "
"extract fields from a record as follows, as well as by pattern matching at "
"the top level:"
msgstr "我们也可以在 ``let`` 绑定中进行模式匹配。例如，我们可以从记录中提取字段，如下"
"所示，也可以通过在顶层进行模式匹配："

#: ../../source/tutorial/typesfuns.rst:1257 3bf8f73ce1d347528186622c946b4347
msgid "These let bindings can be annotated with a type:"
msgstr "这些 let 绑定可以使用类型注解："

#: ../../source/tutorial/typesfuns.rst:1265 626950aa096d40198f9e4f3ef5d253ad
msgid ""
"We can also use the symbol ``:=`` instead of ``=`` to, among other things, "
"avoid ambiguities with propositional equality:"
msgstr "我们还可以使用符号 ``:=`` 来代替 ``=`` ，除其他事项外，避免命题相等的歧义："

#: ../../source/tutorial/typesfuns.rst:1273 320ce9d23fe44b618f5c67837838d1a3
msgid ""
"Local definitions can also be introduced using ``let``. Just like top level "
"ones and ones defined in a ``where`` clause you need to:"
msgstr "本地定义也可以使用 ``let`` 引入。就像顶层定义和在 ``where`` "
"子句中定义的一样，你需要："

#: ../../source/tutorial/typesfuns.rst:1276 931452047f1e465783ce1c68cc845b54
msgid "declare the function and its type"
msgstr "声明函数和它的类型"

#: ../../source/tutorial/typesfuns.rst:1277 7e8e7402b8d9433b9b86bf8ebe1800dc
msgid "define the function by pattern matching"
msgstr "通过模式匹配来定义函数"

#: ../../source/tutorial/typesfuns.rst:1286 23745cd6553d4241a3fe87dd94be9414
msgid ""
"The symbol ``:=`` cannot be used in a local function definition. Which means "
"that it can be used to interleave let bindings and local definitions without "
"introducing ambiguities."
msgstr "符号 ``:=`` 不能在局部函数定义中使用。这意味着它可以用来交错使用 let "
"绑定和局部定义，而不会引入歧义。"

#: ../../source/tutorial/typesfuns.rst:1301 ecb9ee3b06434a3398737baa4b6d680d
msgid "List comprehensions"
msgstr "列表推导式"

#: ../../source/tutorial/typesfuns.rst:1303 4b8eca59e8c0479ab354bb84e71d5741
msgid ""
"Idris provides *comprehension* notation as a convenient shorthand for "
"building lists. The general form is:"
msgstr "Idris提 供了 *推导式* 符号，作为建立列表的方便速记法。其一般形式是："

#: ../../source/tutorial/typesfuns.rst:1310 01912b4d531948c4a651ba234d9c3b1e
msgid ""
"This generates the list of values produced by evaluating the ``expression``, "
"according to the conditions given by the comma separated ``qualifiers``. For "
"example, we can build a list of Pythagorean triples as follows:"
msgstr ""
"通过对 ``expression`` 进行求值，根据逗号分隔的 ``qualifiers`` 给出的条件生成"
"一个符合条件的列表。例如，我们可以建立一个毕达哥拉斯三段论的列表，如下所示："

#: ../../source/tutorial/typesfuns.rst:1321 ee8f4055a6ea4cb19080b0fa9ac0fc06
msgid ""
"The ``[a..b]`` notation is another shorthand which builds a list of numbers "
"between ``a`` and ``b``. Alternatively ``[a,b..c]`` builds a list of numbers "
"between ``a`` and ``c`` with the increment specified by the difference "
"between ``a`` and ``b``. This works for type ``Nat``, ``Int`` and "
"``Integer``, using the ``enumFromTo`` and ``enumFromThenTo`` function from "
"the prelude."
msgstr ""
"``[a..b]`` 符号是另一种速记方法，它在 ``a`` 和 ``b`` 之间建立一个数字列表。"
"或者 ``[a,b..c]`` 在 ``a`` 和 ``c`` 之间建立一个数字列表，增量由 ``a`` 和 "
"``b`` 之间的差异指定。这适用于 ``Nat``, ``Int`` 和 ``Integer`` 类型，是 "
"prelude 中的 ``enumFromTo`` 和 ``enumFromThenTo`` 函数的语法糖。"

#: ../../source/tutorial/typesfuns.rst:1329 c65bd7ee4ecf495683fac1f44f2c6893
msgid "``case`` expressions"
msgstr "``case`` 表达式"

#: ../../source/tutorial/typesfuns.rst:1331 d58b9a65a8724a4bb1388afca4b73cf0
msgid ""
"Another way of inspecting intermediate values is to use a ``case`` "
"expression. The following function, for example, splits a string into two at "
"a given character:"
msgstr "另一种检查中间值的方法是使用 ``case`` "
"表达式。例如，下面的函数在一个给定的字符处将一个字符串分成两个："

#: ../../source/tutorial/typesfuns.rst:1341 b560b76f54974170b4c885947eb6e180
msgid ""
"``break`` is a library function which breaks a string into a pair of strings "
"at the point where the given function returns true. We then deconstruct the "
"pair it returns, and remove the first character of the second string."
msgstr ""
"``break`` 是一个库函数，它在给定函数返回真值的地方将一个字符串分解成一对子字"
"符串。然后我们对它返回的一对子字符串进行解构，并删除第二个子字符串的第一个字"
"符。"

#: ../../source/tutorial/typesfuns.rst:1346 47b16651478d482dae41b64cce1b4fb8
msgid ""
"A ``case`` expression can match several cases, for example, to inspect an "
"intermediate value of type ``Maybe a``. Recall ``list_lookup`` which looks "
"up an index in a list, returning ``Nothing`` if the index is out of bounds. "
"We can use this to write ``lookup_default``, which looks up an index and "
"returns a default value if the index is out of bounds:"
msgstr ""
"一个 ``case`` 表达式可以匹配多种情况，例如，检查一个中间值的类型 ``Maybe a`` "
"。回顾 ``list_lookup`` 函数，它在一个列表中查找一个索引，如果索引出界则返回 "
"``Nothing`` 。我们可以用它来写 ``lookup_default`` "
"，它查找一个索引，如果索引出界则返回一个默认值："

#: ../../source/tutorial/typesfuns.rst:1360 49d74dbf54694b438a5e42efff7c9a64
msgid ""
"If the index is in bounds, we get the value at that index, otherwise we get "
"a default value:"
msgstr "如果索引在范围内，我们得到该索引的值，否则我们得到一个默认值："

#: ../../source/tutorial/typesfuns.rst:1371 ca3e1b4036f64f53a4fb368424cc27d3
msgid "Totality"
msgstr "完全性"

#: ../../source/tutorial/typesfuns.rst:1373 ca6a64671d7741968d6a1969349d2fee
msgid ""
"Idris distinguishes between *total* and *partial* functions. A total "
"function is a function that either:"
msgstr "Idris 区分了 *完全* 和 *部分* 函数。完全函数是一个这样的函数，它要么："

#: ../../source/tutorial/typesfuns.rst:1376 8dc3d4b9b72d47e3ae5a6f03db477920
msgid "Terminates for all possible inputs, or"
msgstr "对所有可能的输入终止，或者"

#: ../../source/tutorial/typesfuns.rst:1377 24e4f60d592b4928b93e5b3e08fb7d5a
msgid "Produces a non-empty, finite, prefix of a possibly infinite result"
msgstr "产生一个非空的、有限的、或者一个可能是无限结果的前缀"

#: ../../source/tutorial/typesfuns.rst:1379 20d0805b2961422db9a485b895444f5b
msgid ""
"If a function is total, we can consider its type a precise description of "
"what that function will do. For example, if we have a function with a return "
"type of ``String`` we know something different, depending on whether or not "
"it's total:"
msgstr ""
"如果一个函数是完全的，我们可以认为其类型是对该函数将做什么的精确描述。例如，"
"如果我们有一个返回类型为 ``String`` "
"的函数，我们知道一些不同的东西，这取决于它是否是完全的："

#: ../../source/tutorial/typesfuns.rst:1384 901b2dfeebb64ed5919f86f8872d5fdd
msgid ""
"If it's total, it will return a value of type ``String`` in finite time;"
msgstr "如果是完全的，它将在有限时间内返回一个类型为 ``String`` 的值："

#: ../../source/tutorial/typesfuns.rst:1385 2108596dfc394d14a211e36f356bf708
msgid ""
"If it's partial, then as long as it doesn't crash or enter an infinite loop, "
"it will return a ``String``."
msgstr "如果是部分的，那么只要不崩溃或进入无限循环，就会返回一个 ``String`` 。"

#: ../../source/tutorial/typesfuns.rst:1388 0e3052f7dc1248f7a3e28fa3a5238a21
msgid ""
"Idris makes this distinction so that it knows which functions are safe to "
"evaluate while type checking (as we've seen with :ref:`sect-fctypes`). After "
"all, if it tries to evaluate a function during type checking which doesn't "
"terminate, then type checking won't terminate! Therefore, only total "
"functions will be evaluated during type checking. Partial functions can "
"still be used in types, but will not be evaluated further."
msgstr ""
"Idris 做了这个区分，所以它知道哪些函数在类型检查时是安全的（正如我们在 :ref"
":`sect-fctypes` 中看到的）。毕竟，如果它试图在类型检查期间求值一个没有终止的"
"函数，那么类型检查就不会终止！因此，在类型检查期间，只有完全函数会被求值。部"
"分函数仍然可以在类型中使用，但不会被进一步求值。"
