# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 11:10+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/tutorial/theorems.rst:5 dfbd440093844b9580b1f61fd4291175
msgid "Theorem Proving"
msgstr ""

#: ../../source/tutorial/theorems.rst:8 13e16debaf6b46c48d985ebafbccd9f9
msgid "Equality"
msgstr ""

#: ../../source/tutorial/theorems.rst:10 23086036d74748cfb5084cfae98aca74
msgid ""
"Idris allows propositional equalities to be declared, allowing theorems "
"about programs to be stated and proved. An equality type is defined as "
"follows in the Prelude:"
msgstr ""

#: ../../source/tutorial/theorems.rst:19 3bc1f4f088f24be1a9c731a61e1a6389
msgid ""
"As a notational convenience, ``Equal x y`` can be written as ``x = y``. "
"Equalities can be proposed between any values of any types, but the only "
"way to construct a proof of equality is if values actually are equal. For"
" example:"
msgstr ""

#: ../../source/tutorial/theorems.rst:32 be08a1d8225e493891484792b14683f0
msgid "If we try..."
msgstr ""

#: ../../source/tutorial/theorems.rst:39 0af63f2fdb174848bb0a488bd69a2be1
msgid "...then we'll get an error:"
msgstr ""

#: ../../source/tutorial/theorems.rst:53 b5e8234c050a487a90dfef7ca84d9c0c
msgid "The Empty Type"
msgstr ""

#: ../../source/tutorial/theorems.rst:55 ce2cfc6eda5640699fdf9e457316fa79
msgid ""
"There is an empty type, ``Void``, which has no constructors. It is "
"therefore impossible to construct a canonical element of the empty type. "
"We can therefore use the empty type to prove that something is "
"impossible, for example zero is never equal to a successor:"
msgstr ""

#: ../../source/tutorial/theorems.rst:69 41c1f4051736465ab9b23483b2ef928e
msgid ""
"Don't worry if you don't get all the details of how this works just yet -"
" essentially, it applies the library function ``replace``, which uses an "
"equality proof to transform a predicate. Here we use it to transform a "
"value of a type which can exist, the empty tuple, to a value of a type "
"which can’t, by using a proof of something which can’t exist."
msgstr ""

#: ../../source/tutorial/theorems.rst:75 69a5c71210eb4f5287b2576ba3b2b8a7
msgid ""
"Once we have an element of the empty type, we can prove anything. "
"``void`` is defined in the library, to assist with proofs by "
"contradiction."
msgstr ""

#: ../../source/tutorial/theorems.rst:84 3cf4c2a5838c42d4a88c4ec848104d64
msgid "Proving Theorems"
msgstr ""

#: ../../source/tutorial/theorems.rst:86 a0f67096c9274ddb8ff061e757e11019
msgid ""
"When type checking dependent types, the type itself gets *normalised*. So"
" imagine we want to prove the following theorem about the reduction "
"behaviour of ``plus``:"
msgstr ""

#: ../../source/tutorial/theorems.rst:94 f242df1ffc8247a6b0454a2f1102c626
msgid ""
"We’ve written down the statement of the theorem as a type, in just the "
"same way as we would write the type of a program. In fact there is no "
"real distinction between proofs and programs. A proof, as far as we are "
"concerned here, is merely a program with a precise enough type to "
"guarantee a particular property of interest."
msgstr ""

#: ../../source/tutorial/theorems.rst:100 66feb8126fbc4cfaa1bc5e0383918ac4
msgid ""
"We won’t go into details here, but the Curry-Howard correspondence "
"[#Timothy]_ explains this relationship. The proof itself is immediate, "
"because ``plus Z n`` normalises to ``n`` by the definition of ``plus``:"
msgstr ""

#: ../../source/tutorial/theorems.rst:108 c431fd4d3706438b99500d890e1f570c
msgid ""
"It is slightly harder if we try the arguments the other way, because plus"
" is defined by recursion on its first argument. The proof also works by "
"recursion on the first argument to ``plus``, namely ``n``."
msgstr ""

#: ../../source/tutorial/theorems.rst:118 d370775879e64e11ba11fa0e4d19cf55
msgid ""
"``cong`` is a function defined in the library which states that equality "
"respects function application:"
msgstr ""

#: ../../source/tutorial/theorems.rst:125 390fe0f2c7d149818b89776fe0636f50
msgid ""
"To see more detail on what's going on, we can replace the recursive call "
"to ``plusReducesZ`` with a hole:"
msgstr ""

#: ../../source/tutorial/theorems.rst:132 1d4e194883c44d2bbd9c6d45563fd6d5
msgid "Then inspecting the type of the hole at the REPL shows us:"
msgstr ""

#: ../../source/tutorial/theorems.rst:141 7916ea98371641269a6490c16bd347dd
msgid "We can do the same for the reduction behaviour of plus on successors:"
msgstr ""

#: ../../source/tutorial/theorems.rst:149 1127f612dc274a48ae471d3e1108eef4
msgid ""
"Even for small theorems like these, the proofs are a little tricky to "
"construct in one go. When things get even slightly more complicated, it "
"becomes too much to think about to construct proofs in this “batch mode”."
msgstr ""

#: ../../source/tutorial/theorems.rst:154 5ab0eb3622a34a30bea717f534cb34fc
msgid ""
"Idris provides interactive editing capabilities, which can help with "
"building proofs. For more details on building proofs interactively in an "
"editor, see :ref:`proofs-index`."
msgstr ""

#: ../../source/tutorial/theorems.rst:161 f3d813ad1c7147039a489d9ab54f9adf
msgid "Theorems in Practice"
msgstr ""

#: ../../source/tutorial/theorems.rst:163 44231768b5684f5db7fe9e51a0ab6a48
msgid ""
"The need to prove theorems can arise naturally in practice. For example, "
"previously (:ref:`sec-views`) we implemented ``natToBin`` using a "
"function ``parity``:"
msgstr ""

#: ../../source/tutorial/theorems.rst:171 c06b7b9561c74f87986f1ef4ffded645
msgid ""
"We provided a definition for ``parity``, but without explanation.  We "
"might have hoped that it would look something like the following:"
msgstr ""

#: ../../source/tutorial/theorems.rst:183 50ead401269d486c9f14959ab054c7eb
msgid "Unfortunately, this fails with a type error:"
msgstr ""

#: ../../source/tutorial/theorems.rst:193 31847c174cd546fba50885cd8bf6860d
msgid ""
"The problem is that normalising ``S j + S j``, in the type of ``Even`` "
"doesn't result in what we need for the type of the right hand side of "
"``Parity``. We know that ``S (S (plus j j))`` is going to be equal to ``S"
" j + S j``, but we need to explain it to Idris with a proof. We can begin"
" by adding some *holes* (see :ref:`sect-holes`) to the definition:"
msgstr ""

#: ../../source/tutorial/theorems.rst:210 54882450ca9741eaab9247515c2b4453
msgid ""
"Checking the type of ``helpEven`` shows us what we need to prove for the "
"``Even`` case:"
msgstr ""

#: ../../source/tutorial/theorems.rst:220 01ffcc8902354003aee449821702b6f0
msgid ""
"We can therefore write a helper function to *rewrite* the type to the "
"form we need:"
msgstr ""

#: ../../source/tutorial/theorems.rst:228 b1298d3a905d49578e2bc8dff759f1ec
msgid ""
"The ``rewrite ... in`` syntax allows you to change the required type of "
"an expression by rewriting it according to an equality proof. Here, we "
"have used ``plusSuccRightSucc``, which has the following type:"
msgstr ""

#: ../../source/tutorial/theorems.rst:236 cce4c049b7f945ccbcc12800659ad2fc
msgid ""
"We can see the effect of ``rewrite`` by replacing the right hand side of "
"``helpEven`` with a hole, and working step by step. Beginning with the "
"following:"
msgstr ""

#: ../../source/tutorial/theorems.rst:244 15775396e5dd467f9139c0f1d0cb2ea8
msgid "We can look at the type of ``helpEven_rhs``:"
msgstr ""

#: ../../source/tutorial/theorems.rst:253 b823a89887064e67b5321d5e60097d52
msgid ""
"Then we can ``rewrite`` by applying ``plusSuccRightSucc j j``, which "
"gives an equation ``S (j + j) = j + S j``, thus replacing ``S (j + j)`` "
"(or, in this case, ``S (plus j j)`` since ``S (j + j)`` reduces to that) "
"in the type with ``j + S j``:"
msgstr ""

#: ../../source/tutorial/theorems.rst:263 f8981981eb1b44f5b98a62901d5b80c4
msgid ""
"Checking the type of ``helpEven_rhs`` now shows what has happened, "
"including the type of the equation we just used (as the type of "
"``_rewrite_rule``):"
msgstr ""

#: ../../source/tutorial/theorems.rst:274 828b9b0f5e2641229e49e59f1647951e
msgid ""
"Using ``rewrite`` and another helper for the ``Odd`` case, we can "
"complete ``parity`` as follows:"
msgstr ""

#: ../../source/tutorial/theorems.rst:292 021f4b79ee9d4d15be18f619cba75731
msgid ""
"Full details of ``rewrite`` are beyond the scope of this introductory "
"tutorial, but it is covered in the theorem proving tutorial (see :ref"
":`proofs-index`)."
msgstr ""

#: ../../source/tutorial/theorems.rst:298 e5d05a183f2b45e2a0353bc2f70f7166
msgid "Totality Checking"
msgstr ""

#: ../../source/tutorial/theorems.rst:300 9b52acabf1fd49b2a7769ce893645633
msgid ""
"If we really want to trust our proofs, it is important that they are "
"defined by *total* functions — that is, a function which is defined for "
"all possible inputs and is guaranteed to terminate. Otherwise we could "
"construct an element of the empty type, from which we could prove "
"anything:"
msgstr ""

#: ../../source/tutorial/theorems.rst:318 69ed2f8306144d85a217d7e364d95a76
msgid ""
"Internally, Idris checks every definition for totality, and we can check "
"at the prompt with the ``:total`` command. We see that neither of the "
"above definitions is total:"
msgstr ""

#: ../../source/tutorial/theorems.rst:329 89a942561a0e4faa8f2371bd8da703bc
msgid ""
"Note the use of the word “possibly” — a totality check can never be "
"certain due to the undecidability of the halting problem. The check is, "
"therefore, conservative. It is also possible (and indeed advisable, in "
"the case of proofs) to mark functions as total so that it will be a "
"compile time error for the totality check to fail:"
msgstr ""

#: ../../source/tutorial/theorems.rst:340 bf3dc9e15fcc4fab9927037c7deebbb5
msgid ""
"Reassuringly, our proof in Section :ref:`sect-empty` that the zero and "
"successor constructors are disjoint is total:"
msgstr ""

#: ../../source/tutorial/theorems.rst:348 4c23f67fba2c4fd685f61ab565bdfe34
msgid ""
"The totality check is, necessarily, conservative. To be recorded as "
"total, a function ``f`` must:"
msgstr ""

#: ../../source/tutorial/theorems.rst:351 8afd9228010d4febbd8b09fdc1bb3461
msgid "Cover all possible inputs"
msgstr ""

#: ../../source/tutorial/theorems.rst:353 dfa525d5ad234b3595b548da8881681b
msgid ""
"Be *well-founded* — i.e. by the time a sequence of (possibly mutually) "
"recursive calls reaches ``f`` again, it must be possible to show that one"
" of its arguments has decreased."
msgstr ""

#: ../../source/tutorial/theorems.rst:357 83720418417246a6b5a5930bb36e66a9
msgid "Not use any data types which are not *strictly positive*"
msgstr ""

#: ../../source/tutorial/theorems.rst:359 4e170fc20cef4a0e80d350b9ea3a910d
msgid "Not call any non-total functions"
msgstr ""

#: ../../source/tutorial/theorems.rst:362 b428e08470884be1912783c9c7fe92f0
msgid "Directives and Compiler Flags for Totality"
msgstr ""

#: ../../source/tutorial/theorems.rst:366 10dd6cdf3532405893f4c2731e5bb846
msgid "Not all of this is implemented yet for Idris 2"
msgstr ""

#: ../../source/tutorial/theorems.rst:368 8974bec47122455fbc1dd553cc0bd49a
msgid ""
"By default, Idris allows all well-typed definitions, whether total or "
"not. However, it is desirable for functions to be total as far as "
"possible, as this provides a guarantee that they provide a result for all"
" possible inputs, in finite time. It is possible to make total functions "
"a requirement, either:"
msgstr ""

#: ../../source/tutorial/theorems.rst:373 b54c3d54124a4fac976f636da8bdb246
msgid "By using the ``--total`` compiler flag."
msgstr ""

#: ../../source/tutorial/theorems.rst:375 c1a93ce849b24cac8bdbe71ae6442367
#, python-format
msgid ""
"By adding a ``%default total`` directive to a source file. All "
"definitions after this will be required to be total, unless explicitly "
"flagged as ``partial``."
msgstr ""

#: ../../source/tutorial/theorems.rst:379 df031d5616b84f1082373ea37ad09cba
#, python-format
msgid ""
"All functions *after* a ``%default total`` declaration are required to be"
" total. Correspondingly, after a ``%default partial`` declaration, the "
"requirement is relaxed."
msgstr ""

#: ../../source/tutorial/theorems.rst:383 b761a8247d0b4d2da6046cdc7c8f047a
msgid ""
"Finally, the compiler flag ``--warnpartial`` causes to print a warning "
"for any undeclared partial function."
msgstr ""

#: ../../source/tutorial/theorems.rst:387 466441ed69684166b98b0e4c99609b14
msgid "Totality checking issues"
msgstr ""

#: ../../source/tutorial/theorems.rst:389 7b8c0ca43cc94920905add5dbf01399b
msgid ""
"Please note that the totality checker is not perfect! Firstly, it is "
"necessarily conservative due to the undecidability of the halting "
"problem, so many programs which *are* total will not be detected as such."
" Secondly, the current implementation has had limited effort put into it "
"so far, so there may still be cases where it believes a function is total"
" which is not. Do not rely on it for your proofs yet!"
msgstr ""

#: ../../source/tutorial/theorems.rst:397 72b759212276441cae14a7fbe449c76f
msgid "Hints for totality"
msgstr ""

#: ../../source/tutorial/theorems.rst:399 584e2cf5858c43ec922b92c51706391a
msgid ""
"In cases where you believe a program is total, but Idris does not agree, "
"it is possible to give hints to the checker to give more detail for a "
"termination argument. The checker works by ensuring that all chains of "
"recursive calls eventually lead to one of the arguments decreasing "
"towards a base case, but sometimes this is hard to spot. For example, the"
" following definition cannot be checked as ``total`` because the checker "
"cannot decide that ``filter (< x) xs`` will always be smaller than ``(x "
":: xs)``:"
msgstr ""

#: ../../source/tutorial/theorems.rst:415 f93de1ba2da8409487f79f72e4a44f18
msgid ""
"The function ``assert_smaller``, defined in the prelude, is intended to "
"address this problem:"
msgstr ""

#: ../../source/tutorial/theorems.rst:423 f9122270e91c49aeb1b6d3a873e78e63
msgid ""
"It simply evaluates to its second argument, but also asserts to the "
"totality checker that ``y`` is structurally smaller than ``x``. This can "
"be used to explain the reasoning for totality if the checker cannot work "
"it out itself. The above example can now be written as:"
msgstr ""

#: ../../source/tutorial/theorems.rst:437 29e0a1fa24eb47518b6e6869e09e1373
msgid ""
"The expression ``assert_smaller (x :: xs) (filter (<= x) xs)`` asserts "
"that the result of the filter will always be smaller than the pattern "
"``(x :: xs)``."
msgstr ""

#: ../../source/tutorial/theorems.rst:441 42fa34a976e14fa3b52acd872630f0c2
msgid ""
"In more extreme cases, the function ``assert_total`` marks a "
"subexpression as always being total:"
msgstr ""

#: ../../source/tutorial/theorems.rst:449 0b871a5bd400431eb0866ae19bb8a8ed
msgid ""
"In general, this function should be avoided, but it can be very useful "
"when reasoning about primitives or externally defined functions (for "
"example from a C library) where totality can be shown by an external "
"argument."
msgstr ""

#: ../../source/tutorial/theorems.rst:455 2121c33a99a54543ab1bbc4e17470ada
msgid ""
"Timothy G. Griffin. 1989. A formulae-as-type notion of control. In "
"Proceedings of the 17th ACM SIGPLAN-SIGACT symposium on Principles of "
"programming languages (POPL '90). ACM, New York, NY, USA, 47-58. "
"DOI=10.1145/96709.96714 https://doi.acm.org/10.1145/96709.96714"
msgstr ""

