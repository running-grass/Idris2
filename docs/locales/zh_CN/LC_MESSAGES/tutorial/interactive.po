# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 11:10+0800\n"
"PO-Revision-Date: 2022-08-20 06:52+0000\n"
"Last-Translator: Anonymous <noreply@weblate.org>\n"
"Language-Team: Chinese (Simplified) <https://weblate.grass.work:30443/"
"projects/idris2/tutorialinteractive/zh_Hans/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.13.1\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/tutorial/interactive.rst:5 126a956ef1ec46a58f65787e1750906d
#, fuzzy
msgid "Interactive Editing"
msgstr "交互式编辑"

#: ../../source/tutorial/interactive.rst:7 425b8406fddc427eafdd92560479ba03
msgid ""
"By now, we have seen several examples of how Idris’ dependent type system"
" can give extra confidence in a function’s correctness by giving a more "
"precise description of its intended behaviour in its *type*. We have also"
" seen an example of how the type system can help with embedded DSL "
"development by allowing a programmer to describe the type system of an "
"object language. However, precise types give us more than verification of"
" programs — we can also use the type system to help write programs which "
"are *correct by construction*, interactively."
msgstr ""

#: ../../source/tutorial/interactive.rst:16 df7f40da81534e2095d46389fa047cd1
msgid ""
"The Idris REPL provides several commands for inspecting and modifying "
"parts of programs, based on their types, such as case splitting on a "
"pattern variable, inspecting the type of a hole, and even a basic proof "
"search mechanism. In this section, we explain how these features can be "
"exploited by a text editor, and specifically how to do so in `Vim "
"<https://github.com/edwinb/idris2-vim>`_. An interactive mode for `Emacs "
"<https://github.com/idris-hackers/idris-mode>`_ is also available, "
"updated for Idris 2 compatibility as of 23 February 2021."
msgstr ""

#: ../../source/tutorial/interactive.rst:27 9c1124e5d0e04d57ad8729ba722173a6
msgid "Editing at the REPL"
msgstr ""

#: ../../source/tutorial/interactive.rst:30 1775beddd9ed4e248feb1312b1a654ec
msgid ""
"The Idris2 repl does not support readline in the interest of keeping "
"dependencies minimal. Unfortunately this precludes some niceties such as "
"line editing, persistent history and completion. A useful work around is "
"to install `rlwrap <https://linux.die.net/man/1/rlwrap>`_, this utility "
"provides all the aforementioned features simply by invoking the Idris2 "
"repl as an argument to the utility ``rlwrap idris2``"
msgstr ""

#: ../../source/tutorial/interactive.rst:37 02d7aa1b77b34724b828e647e33bae13
msgid ""
"The REPL provides a number of commands, which we will describe shortly, "
"which generate new program fragments based on the currently loaded "
"module. These take the general form:"
msgstr ""

#: ../../source/tutorial/interactive.rst:45 14bcec8bd10940d8908bf8ab1ced2adc
msgid ""
"That is, each command acts on a specific source line, at a specific name,"
" and outputs a new program fragment. Each command has an alternative "
"form, which *updates* the source file in-place:"
msgstr ""

#: ../../source/tutorial/interactive.rst:53 3e30ed6b3aaa4995ac1a771f6b94d014
msgid ""
"It is also possible to invoke Idris in a mode which runs a REPL command, "
"displays the result, then exits, using ``idris2 --client``. For example:"
msgstr ""

#: ../../source/tutorial/interactive.rst:63 414e9b95b4e94da5b5c83e6d24e736ff
msgid ""
"A text editor can take advantage of this, along with the editing "
"commands, in order to provide interactive editing support."
msgstr ""

#: ../../source/tutorial/interactive.rst:67 6a3036fa86dd4a849c7aa5f197200fc8
msgid "Editing Commands"
msgstr ""

#: ../../source/tutorial/interactive.rst:70 68e6e99fa9f949d0ad9ef56b55a2e356
msgid ":addclause"
msgstr ""

#: ../../source/tutorial/interactive.rst:72 7763d0f3f6c7444eb7527f88bd7eba0c
msgid ""
"The ``:addclause n f`` command, abbreviated ``:ac n f``, creates a "
"template definition for the function named ``f`` declared on line ``n``. "
"For example, if the code beginning on line 94 contains:"
msgstr ""

#: ../../source/tutorial/interactive.rst:81 60edb2e06786431db8a21242f4649c8a
msgid "then ``:ac 94 vzipWith`` will give:"
msgstr ""

#: ../../source/tutorial/interactive.rst:87 9ebd3db04e524aa4a812938c67b0c3ae
msgid ""
"The names are chosen according to hints which may be given by a "
"programmer, and then made unique by the machine by adding a digit if "
"necessary. Hints can be given as follows:"
msgstr ""

#: ../../source/tutorial/interactive.rst:95 87be940d55204bfaaa17201ec1a78851
msgid ""
"This declares that any names generated for types in the ``Vect`` family "
"should be chosen in the order ``xs``, ``ys``, ``zs``, ``ws``."
msgstr ""

#: ../../source/tutorial/interactive.rst:99 339a008ac4a74b98ac9f140b414dbec1
msgid ":casesplit"
msgstr ""

#: ../../source/tutorial/interactive.rst:101 a29a8f9f8612498c9f62dca42ea009b8
msgid ""
"The ``:casesplit n x`` command, abbreviated ``:cs n x``, splits the "
"pattern variable ``x`` on line ``n`` into the various pattern forms it "
"may take, removing any cases which are impossible due to unification "
"errors. For example, if the code beginning on line 94 is:"
msgstr ""

#: ../../source/tutorial/interactive.rst:112 3d66a754bd7640c5a8108efa385be53d
msgid "then ``:cs 96 xs`` will give:"
msgstr ""

#: ../../source/tutorial/interactive.rst:119 d7a93227ffeb48cea8295864b6fc8011
msgid ""
"That is, the pattern variable ``xs`` has been split into the two possible"
" cases ``[]`` and ``x :: xs``. Again, the names are chosen according to "
"the same heuristic. If we update the file (using ``:cs!``) then case "
"split on ``ys`` on the same line, we get:"
msgstr ""

#: ../../source/tutorial/interactive.rst:128 0c52c410f8cc44c6bcb0e92486bdf9b4
msgid ""
"That is, the pattern variable ``ys`` has been split into one case ``[]``,"
" Idris having noticed that the other possible case ``y :: ys`` would lead"
" to a unification error."
msgstr ""

#: ../../source/tutorial/interactive.rst:133 2d1a5a331c8c40eeaf7e97f7c373467a
msgid ":addmissing"
msgstr ""

#: ../../source/tutorial/interactive.rst:135 bf19c014a67d4075a08f743a8fb6ff8e
msgid ""
"The ``:addmissing n f`` command, abbreviated ``:am n f``, adds the "
"clauses which are required to make the function ``f`` on line ``n`` cover"
" all inputs. For example, if the code beginning on line 94 is:"
msgstr ""

#: ../../source/tutorial/interactive.rst:145 3271643fb08846c48538ac1abc5263ef
msgid "then ``:am 96 vzipWith`` gives:"
msgstr ""

#: ../../source/tutorial/interactive.rst:151 49a35f15b20d4d54a15aa5bdabffc204
msgid ""
"That is, it notices that there are no cases for empty vectors, generates "
"the required clauses, and eliminates the clauses which would lead to "
"unification errors."
msgstr ""

#: ../../source/tutorial/interactive.rst:156 12795c043115493bb837b7207223455e
msgid ":proofsearch"
msgstr ""

#: ../../source/tutorial/interactive.rst:158 244c459e6c564ca98133f3fcef0a0181
msgid ""
"The ``:proofsearch n f`` command, abbreviated ``:ps n f``, attempts to "
"find a value for the hole ``f`` on line ``n`` by proof search, trying "
"values of local variables, recursive calls and constructors of the "
"required family. Optionally, it can take a list of *hints*, which are "
"functions it can try applying to solve the hole. For example, if the code"
" beginning on line 94 is:"
msgstr ""

#: ../../source/tutorial/interactive.rst:172 3c10b41713bf4d7dad4936e0db17f2d1
msgid "then ``:ps 96 vzipWith_rhs_1`` will give"
msgstr ""

#: ../../source/tutorial/interactive.rst:178 c4a889adb6b34fddaa35001c5ee5645f
msgid ""
"This works because it is searching for a ``Vect`` of length 0, of which "
"the empty vector is the only possibility. Similarly, and perhaps "
"surprisingly, there is only one possibility if we try to solve ``:ps 97 "
"vzipWith_rhs_2``:"
msgstr ""

#: ../../source/tutorial/interactive.rst:187 05d503c38c374046a0f581b377b8885d
msgid ""
"This works because ``vzipWith`` has a precise enough type: The resulting "
"vector has to be non-empty (a ``::``); the first element must have type "
"``c`` and the only way to get this is to apply ``f`` to ``x`` and ``y``; "
"finally, the tail of the vector can only be built recursively."
msgstr ""

#: ../../source/tutorial/interactive.rst:194 0271cbce15f54f1fbb957c6f78cfddd2
msgid ":makewith"
msgstr ""

#: ../../source/tutorial/interactive.rst:196 29bc500fdcd845939bfe1225f80553a2
msgid ""
"The ``:makewith n f`` command, abbreviated ``:mw n f``, adds a ``with`` "
"to a pattern clause. For example, recall ``parity``. If line 10 is:"
msgstr ""

#: ../../source/tutorial/interactive.rst:204 1d8db1df347d48fd8afb2fa4842af9ff
msgid "then ``:mw 10 parity`` will give:"
msgstr ""

#: ../../source/tutorial/interactive.rst:211 220107d512bb4bf186bf4f9a5c310058
msgid ""
"If we then fill in the placeholder ``_`` with ``parity k`` and case split"
" on ``with_pat`` using ``:cs 11 with_pat`` we get the following patterns:"
msgstr ""

#: ../../source/tutorial/interactive.rst:220 45af9813189e42b4aacc2905814ee5a1
msgid ""
"Note that case splitting has normalised the patterns here (giving "
"``plus`` rather than ``+``). In any case, we see that using interactive "
"editing significantly simplifies the implementation of dependent pattern "
"matching by showing a programmer exactly what the valid patterns are."
msgstr ""

#: ../../source/tutorial/interactive.rst:227 b9c3adb4b45f41758f7af5a991357cb0
msgid "Interactive Editing in Vim"
msgstr ""

#: ../../source/tutorial/interactive.rst:229 20cfbd78b866417ba9f787731a7bddb8
msgid ""
"The editor mode for Vim provides syntax highlighting, indentation and "
"interactive editing support using the commands described above. "
"Interactive editing is achieved using the following editor commands, each"
" of which update the buffer directly:"
msgstr ""

#: ../../source/tutorial/interactive.rst:235 ea19c5ba83c145d7b45d3ee36bcc923a
msgid "``\\a`` adds a template definition for the name declared on the"
msgstr ""

#: ../../source/tutorial/interactive.rst:235 9a5112dff63d40108dfcc6731385cc1f
msgid "current line (using ``:addclause``)."
msgstr ""

#: ../../source/tutorial/interactive.rst:238 76611f1facc94ad0a56a810f385a040d
msgid "``\\c`` case splits the variable at the cursor (using"
msgstr ""

#: ../../source/tutorial/interactive.rst:238 fb4684c663744db0a2c9732975d42ce0
msgid "``:casesplit``)."
msgstr ""

#: ../../source/tutorial/interactive.rst:241 ef785fe3961b420bb9a330075d33db46
msgid "``\\m`` adds the missing cases for the name at the cursor (using"
msgstr ""

#: ../../source/tutorial/interactive.rst:241 542906f963244ef790a7043ec55a4eb2
msgid "``:addmissing``)."
msgstr ""

#: ../../source/tutorial/interactive.rst:243 6d6b611d890148e48a59279725722cf5
msgid "``\\w`` adds a ``with`` clause (using ``:makewith``)."
msgstr ""

#: ../../source/tutorial/interactive.rst:246 f127ba4166604fc6a6d93f5eba2f828a
msgid "``\\s`` invokes a proof search to solve the hole under the"
msgstr ""

#: ../../source/tutorial/interactive.rst:246 01bbe6f18c5a4f8f8c03054c5b51c87b
msgid "cursor (using ``:proofsearch``)."
msgstr ""

#: ../../source/tutorial/interactive.rst:248 2a2f7777348f4cea996e8de4d0ea49a4
msgid "There are also commands to invoke the type checker and evaluator:"
msgstr ""

#: ../../source/tutorial/interactive.rst:252 54303437a18c4f6eab7f7052a33d527e
msgid "``\\t`` displays the type of the (globally visible) name under the"
msgstr ""

#: ../../source/tutorial/interactive.rst:251 0f194a3ebe884d03a1b5c4398af37d69
msgid ""
"cursor. In the case of a hole, this displays the context and the expected"
" type."
msgstr ""

#: ../../source/tutorial/interactive.rst:254 f01e92ce70314ad68ddfdc47282d1a11
msgid "``\\e`` prompts for an expression to evaluate."
msgstr ""

#: ../../source/tutorial/interactive.rst:256 153301e4f68f40c6b712ddcb34059387
msgid "``\\r`` reloads and type checks the buffer."
msgstr ""

#: ../../source/tutorial/interactive.rst:258 c8650f4dab4d4498bb0c8d4cead07a14
msgid ""
"Corresponding commands are also available in the Emacs mode. Support for "
"other editors can be added in a relatively straightforward manner by "
"using ``idris2 -–client``. More sophisticated support can be added by "
"using the IDE protocol (yet to be documented for Idris 2, but which "
"mostly extends to protocol documented for `Idris 1 <https://docs.idris-"
"lang.org/en/latest/reference/ide-protocol.html>`_."
msgstr ""
