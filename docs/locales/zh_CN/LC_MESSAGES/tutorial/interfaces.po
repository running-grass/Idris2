# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: 467195537@qq.com\n"
"POT-Creation-Date: 2022-07-12 11:10+0800\n"
"PO-Revision-Date: 2022-07-22 06:32+0000\n"
"Last-Translator: Leo Liu <leo19920823@gmail.com>\n"
"Language-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/"
"idris2/tutorialinterfaces/zh_Hans/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.14-dev\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/tutorial/interfaces.rst:5 81fbbe3ced404f2e958f4187a9ae2f95
msgid "Interfaces"
msgstr "接口"

#: ../../source/tutorial/interfaces.rst:7 566e24c6903c4ababf8db67d773da361
msgid ""
"We often want to define functions which work across several different "
"data types. For example, we would like arithmetic operators to work on "
"``Int``, ``Integer`` and ``Double`` at the very least. We would like "
"``==`` to work on the majority of data types. We would like to be able to"
" display different types in a uniform way."
msgstr ""
"我们经常希望定义的函数能在几种不同的数据类型中工作。例如，"
"我们希望算术运算符至少能在 ``Int``, ``Integer`` 和 ``Double`` 上工作。"
"我们希望 ``==`` "
"能在大多数数据类型上工作。我们希望能够以一种统一的方式显示不同的类型。"

#: ../../source/tutorial/interfaces.rst:13 906ac8e6c8ea482dbaab2d38b7e3e8d4
msgid ""
"To achieve this, we use *interfaces*, which are similar to type classes "
"in Haskell or traits in Rust. To define an interface, we provide a "
"collection of overloadable functions. A simple example is the ``Show`` "
"interface, which is defined in the prelude and provides an interface for "
"converting values to ``String``:"
msgstr ""
"为了实现这一点，我们使用 *接口* ，它类似于 Haskell 中的类型类或 Rust 中的 "
"traits 。为了定义一个接口，我们提供一个可重载函数的集合。一个简单的例子是 "
"``Show`` 接口，它被定义在 prelude 中，提供了一个将数值转换为 ``String`` "
"的接口："

#: ../../source/tutorial/interfaces.rst:24 fde6b8de03e0413783a2aee66143cb3f
msgid ""
"This generates a function of the following type (which we call a *method*"
" of the ``Show`` interface):"
msgstr "生成一个如下类型的函数（我们称之为 ``Show`` 接口的 *方法* ）："

#: ../../source/tutorial/interfaces.rst:31 cba4291529ca40e28dd73a3ffdf5931c
msgid ""
"We can read this as: “under the constraint that ``a`` has an "
"implementation of ``Show``, take an input ``a`` and return a ``String``.”"
" An implementation of an interface is defined by giving definitions of "
"the methods of the interface. For example, the ``Show`` implementation "
"for ``Nat`` could be defined as:"
msgstr ""
"我们可以把它理解为：“ 在 ``a`` 实现 ``Show`` 的约束下，该函数接受一个输入 "
"``a`` 并返回一个 ``String`` "
"”。我们可以通过为它定义接口的方法来实现该接口。例如， ``Nat`` 的 ``Show`` "
"实现可以定义为："

#: ../../source/tutorial/interfaces.rst:47 62533bca142b4e9abed6d18e26944f9b
msgid ""
"Only one implementation of an interface can be given for a type — "
"implementations may not overlap. Implementation declarations can "
"themselves have constraints. To help with resolution, the arguments of an"
" implementation must be constructors (either data or type constructors) "
"or variables (i.e. you cannot give an implementation for a function). For"
" example, to define a ``Show`` implementation for vectors, we need to "
"know that there is a ``Show`` implementation for the element type, "
"because we are going to use it to convert each element to a ``String``:"
msgstr ""
"一个类型对于同一个接口只能有一种实现——实现不得重合。实现声明本身可以有约束。"
"为了帮助解决这个问题，实现的参数必须是构造函数（数据或类型构造函数）或变量（"
"也就是说，你无法为函数赋予实现）。例如，为向量定义一个 ``Show`` 的实现，"
"我们需要知道有一个 ``Show`` 的实现用于元素类型，"
"因为我们要用它把每个元素转换为 ``String`` ："

#: ../../source/tutorial/interfaces.rst:65 a671917f2d7c4d46a6389450da4ac414
msgid ""
"Note that we need the explicit ``forall n .`` in the ``show'`` function "
"because otherwise the ``n`` is already in scope, and fixed to the value "
"of the top level ``n``."
msgstr ""
"请注意，我们需要在 ``show'`` 函数中明确 ``forall n .`` ，因为 ``n`` "
"已经在作用域内，并且固定为顶层的 ``n`` 的值。"

#: ../../source/tutorial/interfaces.rst:70 f2c909f0a12c4e65920882c48cf9286e
msgid "Default Definitions"
msgstr "默认定义"

#: ../../source/tutorial/interfaces.rst:72 221f953472f842bfb4c5b1ec62393589
msgid ""
"The Prelude defines an ``Eq`` interface which provides methods for "
"comparing values for equality or inequality, with implementations for all"
" of the built-in types:"
msgstr "Prelude 定义了一个 ``Eq`` "
"接口，它提供了比较值的相等或不相等的方法，并为所有的内置类型提供了实现："

#: ../../source/tutorial/interfaces.rst:82 f99cd84e47694bdd9061ba3f78a42dd9
msgid ""
"To declare an implementation for a type, we have to give definitions of "
"all of the methods. For example, for an implementation of ``Eq`` for "
"``Nat``:"
msgstr "要为类型实现一个接口，我们必须给出所有方法的定义。例如， ``Nat`` 类型的 "
"``Eq`` 接口实现："

#: ../../source/tutorial/interfaces.rst:95 58a43c45e21b4d71adb87f5cfeacc471
msgid ""
"It is hard to imagine many cases where the ``/=`` method will be anything"
" other than the negation of the result of applying the ``==`` method. It "
"is therefore convenient to give a default definition for each method in "
"the interface declaration, in terms of the other method:"
msgstr ""
"很难想象在很多情况下， ``/=`` 方法除了是应用 ``==`` 方法的结果的否定之外，还"
"会是什么。因此，在接口声明中为每个方法给出一个默认的定义是很方便的，默认定义"
"可以调用其它方法："

#: ../../source/tutorial/interfaces.rst:109 ce304bb0625d4388bef25f8373ccdecd
msgid ""
"A minimal complete implementation of ``Eq`` requires either ``==`` or "
"``/=`` to be defined, but does not require both. If a method definition "
"is missing, and there is a default definition for it, then the default is"
" used instead."
msgstr ""
"``Eq`` 的最小完整实现需要定义 ``==`` 或 ``/=`` ，但不需要同时定义。如果缺少一"
"个方法的定义，并且有一个默认的定义，那么就用默认的定义来代替。"

#: ../../source/tutorial/interfaces.rst:115 c46b0c29e4514f89af1e9c203d480876
msgid "Extending Interfaces"
msgstr "扩展接口"

#: ../../source/tutorial/interfaces.rst:117 12b1417231224d8ca6a3de8b93de86db
msgid ""
"Interfaces can also be extended. A logical next step from an equality "
"relation ``Eq`` is to define an ordering relation ``Ord``. We can define "
"an ``Ord`` interface which inherits methods from ``Eq`` as well as "
"defining some of its own:"
msgstr ""
"接口也可以被扩展。相等关系 ``Eq`` 的下一个逻辑步骤是定义一个排序关系 ``Ord`` "
"。我们可以定义一个 ``Ord`` 接口，它继承了 ``Eq`` "
"的方法，同时也定义了一些自己的方法："

#: ../../source/tutorial/interfaces.rst:138 3a0e24c5a63248c8ac8505d74cd56767
msgid ""
"The ``Ord`` interface allows us to compare two values and determine their"
" ordering. Only the ``compare`` method is required; every other method "
"has a default definition. Using this we can write functions such as "
"``sort``, a function which sorts a list into increasing order, provided "
"that the element type of the list is in the ``Ord`` interface. We give "
"the constraints on the type variables left of the fat arrow ``=>``, and "
"the function type to the right of the fat arrow:"
msgstr ""
"``Ord`` 接口允许我们比较两个值并确定它们的顺序。只有 ``compare`` 方法是必需的"
"；其他每个方法都有一个默认的定义。利用这一点，我们可以写一些函数，比如 "
"``sort`` ，这个函数可以将一个列表按递增顺序排序，前提是列表的元素类型在 "
"``Ord`` 接口中。我们在胖箭头 ``=>`` "
"的左边给出类型变量的约束，在胖箭头的右边给出函数类型："

#: ../../source/tutorial/interfaces.rst:150 d722f474afa449bf85af6b4514a9c712
msgid ""
"Functions, interfaces and implementations can have multiple constraints. "
"Multiple constraints are written in brackets in a comma separated list, "
"for example:"
msgstr "函数、接口和实现可以有多个约束。多个约束条件以逗号分隔的列表方式写在括号里，"
"例如："

#: ../../source/tutorial/interfaces.rst:159 e89d437d9a504e94875bbcfa43f112e5
msgid ""
"Constraints are, like types, first class objects in the language. You can"
" see this at the REPL:"
msgstr "约束和类型一样，是语言中的一等对象。你可以在 REPL 中看到这一点："

#: ../../source/tutorial/interfaces.rst:167 fad2cba11f6542229ed53bc8d23efc77
msgid ""
"So, ``(Ord a, Show a)`` is an ordinary pair of ``Types``, with two "
"constraints as the first and second element of the pair."
msgstr "所以， ``(Ord a, Show a)`` 是一对普通的 ``Types`` "
"，将两个约束作为该对的第一个和第二个元素。"

#: ../../source/tutorial/interfaces.rst:171 0cd32f24e362491ab5b3101ca157e2c9
msgid "Note: Interfaces and ``mutual`` blocks"
msgstr "注：接口和 ``mutual`` 块"

#: ../../source/tutorial/interfaces.rst:173 a087799745c7400eaab97bdbd6e3fed1
msgid ""
"Idris is strictly \"define before use\", except in ``mutual`` blocks. In "
"a ``mutual`` block, Idris elaborates in two passes: types on the first "
"pass and definitions on the second. When the mutual block contains an "
"interface declaration, it elaborates the interface header but none of the"
" method types on the first pass, and elaborates the method types and any "
"default definitions on the second pass."
msgstr ""
"Idris是严格的 \"先定义后使用\"，除了在 ``mutual`` 块中。在 ``mutual`` 块中，"
"Idris 分两遍进行扫描：第一遍是类型，第二遍是定义。当 mutual 块包含一个接口声"
"明时，它在第一遍中扫描接口头，但没有方法类型，在第二遍扫描方法类型和所有的默"
"认定义。"

#: ../../source/tutorial/interfaces.rst:181 a32915be6a044927b1d9945f195854bd
msgid "Quantities for Parameters"
msgstr "参数的量"

#: ../../source/tutorial/interfaces.rst:183 ded9ef99e3034d5abc1ed3f233d6b4ec
msgid ""
"By default parameters that are not explicitly ascribed a type in an "
"``interface`` declaration are assigned the quantity ``0``. This means "
"that the parameter is not available to use at runtime in the methods' "
"definitions."
msgstr ""
"默认情况下，在 ``interface`` 声明中没有明确赋予类型的参数被分配为数量 ``0`` "
"。这意味着该参数在运行时不能在方法的定义中使用。"

#: ../../source/tutorial/interfaces.rst:187 f19074a07efa4ca29601314ccbef3a9e
msgid ""
"For instance, ``Show a`` gives rise to a ``0``-quantified type variable "
"``a`` in the type of the ``show`` method:"
msgstr "例如， ``Show a`` 在 ``show`` 方法的类型中产生了一个数量为 ``0`` 的类型变量 "
"``a`` ："

#: ../../source/tutorial/interfaces.rst:196 ae85e4217a964e8db905f7288755cee6
msgid ""
"However some use cases require that some of the parameters are available "
"at runtime. We may for instance want to declare an interface for "
"``Storable`` types. The constraint ``Storable a size`` means that we can "
"store values of type ``a`` in a ``Buffer`` in exactly ``size`` bytes."
msgstr ""
"然而有些用例要求一些参数在运行时可用。例如，我们可能想为 ``Storable`` "
"类型声明一个接口。约束 ``Storable a size`` 意味着我们可以将 ``a`` "
"类型的值存储在一个 ``Buffer`` 中，正好是 ``size`` 字节。"

#: ../../source/tutorial/interfaces.rst:201 069ddb0da6cd4c3db5ebf897a3ab65c4
msgid ""
"If the user provides a method to read a value for such a type ``a`` at a "
"given offset, then we can read the ``k`` th element stored in the buffer "
"by computing the appropriate offset from ``k`` and ``size``. This is "
"demonstrated by providing a default implementation for the method "
"``peekElementOff`` implemented in terms of ``peekByteOff`` and the "
"parameter ``size``."
msgstr ""
"如果用户提供一个方法来在通过给定一个偏移量读取类型 ``a`` 的值，"
"那么我们可以通过计算 ``k`` 和 ``size`` 的适当偏移量来读取存储在缓冲区中的 "
"``k`` 的元素。这可以通过为 ``peekElementOff`` 方法提供一个默认的实现来证明，"
"该方法通过 ``peekByteOff`` 和参数 ``size`` 来实现。"

#: ../../source/tutorial/interfaces.rst:219 e2b0bdcfcf774c0688b57fc7e92633fd
msgid ""
"Note that ``a`` is explicitly marked as runtime irrelevant so that it is "
"erased by the compiler. Equivalently we could have written ``interface "
"Storable a (size : Nat)``. The meaning of ``| a`` is explained in "
":ref:`DeterminingParameters`."
msgstr ""
"请注意， ``a`` 被明确标记为运行时不相关，所以它被编译器删除了。"
"相当于我们可以写成 ``interface Storable a (size : Nat)`` 。 ``| a`` 的含义在 "
":ref:`DeterminingParameters` 中有解释。"

#: ../../source/tutorial/interfaces.rst:225 ebf30f75c5b54c04a97cdba5a01637e7
msgid "Functors and Applicatives"
msgstr "函子与应用子"

#: ../../source/tutorial/interfaces.rst:227 bc7fccbb6e0e458999fbec8556596edb
msgid ""
"So far, we have seen single parameter interfaces, where the parameter is "
"of type ``Type``. In general, there can be any number of parameters (even"
" zero), and the parameters can have *any* type. If the type of the "
"parameter is not ``Type``, we need to give an explicit type declaration. "
"For example, the ``Functor`` interface is defined in the prelude:"
msgstr ""
"到目前为止，我们看到的都是单参数接口，其中参数的类型是 ``Type`` "
"。一般来说，可以有任何数量的参数（甚至是零个），而且参数可以有 *任何* 类型。"
"如果参数的类型不是 ``Type`` ，我们需要给出一个明确的类型声明。例如， "
"``Functor`` 接口在 prelude 中是这样定义的："

#: ../../source/tutorial/interfaces.rst:240 181134a62ae04fc7b7c21815ea9122df
msgid ""
"A functor allows a function to be applied across a structure, for example"
" to apply a function to every element in a ``List``:"
msgstr "函子允许在结构中应用一个函数，例如，将一个函数应用于 ``List`` 中的每个元素："

#: ../../source/tutorial/interfaces.rst:254 423c2b3b3c804eef92deb0fcd907b7fa
msgid ""
"Having defined ``Functor``, we can define ``Applicative`` which abstracts"
" the notion of function application:"
msgstr "在定义了 ``Functor`` 之后，我们可以定义 ``Applicative`` "
"，它抽象了函数应用的概念："

#: ../../source/tutorial/interfaces.rst:268 307e973a6baf4a62be4d79b0846e7daf
msgid "Monads and ``do``-notation"
msgstr "单子和 ``do``- 记法"

#: ../../source/tutorial/interfaces.rst:270 ae6ef1d127834140b68d9d43985b8759
msgid ""
"The ``Monad`` interface allows us to encapsulate binding and computation,"
" and is the basis of ``do``-notation introduced in Section :ref:`sect-"
"do`. It extends ``Applicative`` as defined above, and is defined as "
"follows:"
msgstr ""
"``Monad`` 接口允许我们对绑定和计算进行封装，它是 :ref:`sect-do` 一节中 ``do``"
" 记法的基础 。它扩展了上面定义的 ``Applicative`` ，并有如下定义："

#: ../../source/tutorial/interfaces.rst:280 1399f771dbaa478fba0cbe31846bb244
msgid "There is also a non-binding sequencing operator, defined for ``Monad`` as:"
msgstr "还有一个不进行绑定操作的运算符， ``Monad`` 将其定义为："

#: ../../source/tutorial/interfaces.rst:286 e6eea63f4b3b4c7c90dd9efec2834d1d
msgid ""
"Inside a ``do`` block, the following syntactic transformations are "
"applied:"
msgstr "在 ``do`` 块内，应用以下语法转换："

#: ../../source/tutorial/interfaces.rst:289 d300beded1f14630b1b405d8c66bee01
msgid "``x <- v; e`` becomes ``v >>= (\\x => e)``"
msgstr "``x <- v; e`` 变成 ``v >>= (\\x => e)``"

#: ../../source/tutorial/interfaces.rst:291 3f8f4e38bd154b89aaa14dfe4969849e
msgid "``v; e`` becomes ``v >> e``"
msgstr "``v; e`` 变成 ``v >> e``"

#: ../../source/tutorial/interfaces.rst:293 a5afb6c9805a4bb49712cc38b37f8a2a
msgid "``let x = v; e`` becomes ``let x = v in e``"
msgstr "``let x = v; e`` 变成 ``let x = v in e``"

#: ../../source/tutorial/interfaces.rst:295 89a88ee3fa2a41858215e02d6a9542ce
msgid ""
"``IO`` has an implementation of ``Monad``, defined using primitive "
"functions. We can also define an implementation for ``Maybe``, as "
"follows:"
msgstr "``IO`` 有一个 ``Monad`` 的实现，是使用原语函数定义。我们也可以为 ``Maybe`` "
"定义一个实现，如下所示："

#: ../../source/tutorial/interfaces.rst:304 36f9312460c04e4dbf0481f3a69fca43
msgid ""
"Using this we can, for example, define a function which adds two ``Maybe "
"Int``, using the monad to encapsulate the error handling:"
msgstr "利用这一点，我们可以做更多的事情，例如，定义用于对 ``Maybe Int`` "
"进行加法操作的函数，使用单子来封装错误处理："

#: ../../source/tutorial/interfaces.rst:314 60519b1a5083484a9d634a762ae528ef
msgid ""
"This function will extract the values from ``x`` and ``y``, if they are "
"both available, or return ``Nothing`` if one or both are not (\"fail "
"fast\"). Managing the ``Nothing`` cases is achieved by the ``>>=`` "
"operator, hidden by the ``do`` notation."
msgstr ""
"如果两个值都是有值的，这个函数将从 ``x`` 和 ``y`` "
"中提取数值，或者如果一个或两个都不是（\"快速失败\"），则返回 ``Nothing`` 。"
"管理 ``Nothing`` 的情况是由 ``>>=`` 操作符实现的，被 ``do`` 符号所隐藏。"

#: ../../source/tutorial/interfaces.rst:326 7f4a5136b74540b093dc791088c09078
msgid ""
"The translation of ``do`` notation is entirely syntactic, so there is no "
"need for the ``(>>=)`` and ``(>>)`` operators to be the operator defined "
"in the ``Monad`` interface. Idris will, in general, try to disambiguate "
"which operators you mean by type, but you can explicitly choose with "
"qualified do notation, for example:"
msgstr ""
"``do`` 符号的翻译完全是句法性的，所以没有必要将 ``(>>=)`` 和 ``(>>)`` "
"操作符作为 ``Monad`` 接口中定义的操作符。一般来说，Idris "
"会尝试区分你所指的运算符的类型，但你可以用限定的 do 符号明确选择，例如："

#: ../../source/tutorial/interfaces.rst:340 10499e87429a4ba0b16ea45a305b31a3
msgid ""
"The ``Prelude.do`` means that Idris will use the ``(>>=)`` and ``(>>)`` "
"operators defined in the ``Prelude``."
msgstr "``Prelude.do`` 意味着 Idris 将使用在 ``Prelude`` 中定义的 ``(>>=)`` 和 "
"``(>>)`` 。"

#: ../../source/tutorial/interfaces.rst:344 7aee92002658430193635000c4f410a3
msgid "Pattern Matching Bind"
msgstr "模式匹配绑定"

#: ../../source/tutorial/interfaces.rst:346 025d801000d44b7eb9119c9e87b3ce4c
msgid ""
"Sometimes we want to pattern match immediately on the result of a "
"function in ``do`` notation. For example, let's say we have a function "
"``readNumber`` which reads a number from the console, returning a value "
"of the form ``Just x`` if the number is valid, or ``Nothing`` otherwise:"
msgstr ""
"在 ``do`` 记法中，有时我们想在一个函数的结果上立即进行模式匹配，例如，"
"假设我们有一个函数 ``readNumber`` 从控制台读取一个数字，如果该数字有效，"
"则返回一个形式为 ``Just x`` 的值，否则为 ``Nothing`` ："

#: ../../source/tutorial/interfaces.rst:362 6c7bc2681cc744dfbb59c3db5c2860b7
msgid ""
"If we then use it to write a function to read two numbers, returning "
"``Nothing`` if neither are valid, then we would like to pattern match on "
"the result of ``readNumber``:"
msgstr ""
"如果我们用它来写一个函数来读取两个数字，如果两个数字都无效，则返回 "
"``Nothing`` ，然后我们想对 ``readNumber`` 的结果进行模式匹配："

#: ../../source/tutorial/interfaces.rst:378 3b5ab2f4927f4e61864506487c3cc3ca
msgid ""
"If there's a lot of error handling, this could get deeply nested very "
"quickly! So instead, we can combine the bind and the pattern match in one"
" line. For example, we could try pattern matching on values of the form "
"``Just x_ok``:"
msgstr ""
"如果有大量的错误处理，这可能很快就会被深度嵌套！所以我们可以在一行中结合绑定"
"和模式匹配。例如，我们可以尝试对形式为 ``Just x_ok`` 的值进行模式匹配："

#: ../../source/tutorial/interfaces.rst:390 80a04eed40434f3ebb64bb48827d5b83
msgid ""
"There is still a problem, however, because we've now omitted the case for"
" ``Nothing`` so ``readNumbers`` is no longer total! We can add the "
"``Nothing`` case back as follows:"
msgstr ""
"然而，仍然有一个问题，因为我们现在省略了 ``Nothing`` 的情况，所以 "
"``readNumbers`` 不再是完全函数！我们可以把 ``Nothing`` "
"的情况加回来，如下所示："

#: ../../source/tutorial/interfaces.rst:404 4e35b0e17db944a5b500e27d7c024d04
msgid ""
"The effect of this version of ``readNumbers`` is identical to the first "
"(in fact, it is syntactic sugar for it and directly translated back into "
"that form). The first part of each statement (``Just x_ok <-`` and ``Just"
" y_ok <-``) gives the preferred binding - if this matches, execution will"
" continue with the rest of the ``do`` block. The second part gives the "
"alternative bindings, of which there may be more than one."
msgstr ""
"这个版本的 ``readNumbers`` 的效果与第一个版本相同（事实上，这是它的句法糖，会"
"直接翻译成第一个版本的形式）。每个语句的第一部分（ ``Just x_ok <-`` 和 ``"
"Just y_ok <-`` ）给出了首选的绑定方式--如果匹配，将继续执行 ``do`` "
"块的其余部分。第二部分给出了备选的绑定方式，其中可能有多个绑定方式。"

#: ../../source/tutorial/interfaces.rst:412 c205e892b58644a5b1e5bdea5b32d829
msgid "``!``-notation"
msgstr ""

#: ../../source/tutorial/interfaces.rst:414 bd46d0a105504a2faf90c8bc5f1816d8
msgid ""
"In many cases, using ``do``-notation can make programs unnecessarily "
"verbose, particularly in cases such as ``m_add`` above where the value "
"bound is used once, immediately. In these cases, we can use a shorthand "
"version, as follows:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:424 65bbba0f39ff4a8cb1e2b14b13efe45a
msgid ""
"The notation ``!expr`` means that the expression ``expr`` should be "
"evaluated and then implicitly bound. Conceptually, we can think of ``!`` "
"as being a prefix function with the following type:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:432 08b78155de284f53ad320f60c6ed327a
msgid ""
"Note, however, that it is not really a function, merely syntax! In "
"practice, a subexpression ``!expr`` will lift ``expr`` as high as "
"possible within its current scope, bind it to a fresh name ``x``, and "
"replace ``!expr`` with ``x``. Expressions are lifted depth first, left to"
" right. In practice, ``!``-notation allows us to program in a more direct"
" style, while still giving a notational clue as to which expressions are "
"monadic."
msgstr ""

#: ../../source/tutorial/interfaces.rst:440 c2cb7425acd443979d6141a05963d348
msgid "For example, the expression:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:446 0bfc477745244d0793c1023d4ce90899
msgid "is lifted to:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:456 cbf17c7ee1a54f37853dab45fd2587fd
msgid "Monad comprehensions"
msgstr ""

#: ../../source/tutorial/interfaces.rst:458 c8fed3127e524a75a158836517cefd3d
msgid ""
"The list comprehension notation we saw in Section :ref:`sect-more-expr` "
"is more general, and applies to anything which has an implementation of "
"both ``Monad`` and ``Alternative``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:468 80a4cd37176b40d5b61be397ba5374d0
msgid ""
"In general, a comprehension takes the form ``[ exp | qual1, qual2, …, "
"qualn ]`` where ``quali`` can be one of:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:471 e38801720f384c8a946492d0b8761513
msgid "A generator ``x <- e``"
msgstr ""

#: ../../source/tutorial/interfaces.rst:473 1752ddd62ab4444cbb475c6c0b83ad00
msgid "A *guard*, which is an expression of type ``Bool``"
msgstr ""

#: ../../source/tutorial/interfaces.rst:475 3aca342faabd47d88d89ae795dd3c7ba
msgid "A let binding ``let x = e``"
msgstr ""

#: ../../source/tutorial/interfaces.rst:477 f16893c568c2479fb186528e9c41e48f
msgid ""
"To translate a comprehension ``[exp | qual1, qual2, …, qualn]``, first "
"any qualifier ``qual`` which is a *guard* is translated to ``guard "
"qual``, using the following function:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:485 458eef3eb89d4ab8bfb122405f7473a2
msgid "Then the comprehension is converted to ``do`` notation:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:491 a4f838b9a8404e3e824feef2bc195a01
msgid ""
"Using monad comprehensions, an alternative definition for ``m_add`` would"
" be:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:500 3640d3d3d16c41419cd3d2c22cd17cbb
msgid "Interfaces and IO"
msgstr ""

#: ../../source/tutorial/interfaces.rst:502 32e5a6e0e04a456d9f5d010a4b9af39d
msgid ""
"In general, ``IO`` operations in the libraries aren't written using "
"``IO`` directly, but rather via the ``HasIO`` interface:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:510 e6d32ed7c79643f292239d5bab5b8855
msgid ""
"``HasIO`` explains, via ``liftIO``, how to convert a primitive ``IO`` "
"operation to an operation in some underlying type, as long as that type "
"has a ``Monad`` implementation.  These interface allows a programmer to "
"define some more expressive notion of interactive program, while still "
"giving direct access to ``IO`` primitives."
msgstr ""

#: ../../source/tutorial/interfaces.rst:517 71d1f6bb991641ffad850fbfe18ef0f3
msgid "Idiom brackets"
msgstr ""

#: ../../source/tutorial/interfaces.rst:519 42e699b9d169438aa39bda2eff8ee85b
msgid ""
"While ``do`` notation gives an alternative meaning to sequencing, idioms "
"give an alternative meaning to *application*. The notation and larger "
"example in this section is inspired by Conor McBride and Ross Paterson’s "
"paper “Applicative Programming with Effects” [#ConorRoss]_."
msgstr ""

#: ../../source/tutorial/interfaces.rst:524 f23ee8f7139a42878688702848cdb4bc
msgid ""
"First, let us revisit ``m_add`` above. All it is really doing is applying"
" an operator to two values extracted from ``Maybe Int``. We could "
"abstract out the application:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:534 df6c67324f794cdab45bd14fe305245c
msgid ""
"Using this, we can write an alternative ``m_add`` which uses this "
"alternative notion of function application, with explicit calls to "
"``m_app``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:543 f32f68f7f47a479797404b97b91c327a
msgid ""
"Rather than having to insert ``m_app`` everywhere there is an "
"application, we can use idiom brackets to do the job for us. To do this, "
"we can give ``Maybe`` an implementation of ``Applicative`` as follows, "
"where ``<*>`` is defined in the same way as ``m_app`` above (this is "
"defined in the Idris library):"
msgstr ""

#: ../../source/tutorial/interfaces.rst:557 70dedcf94e73405b953ba88f03fde493
msgid ""
"Using ``<*>`` we can use this implementation as follows, where a function"
" application ``[| f a1 …an |]`` is translated into ``pure f <*> a1 <*> … "
"<*> an``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:567 98c8feb8cb6d4d58ad4297549d70444e
msgid "An error-handling interpreter"
msgstr ""

#: ../../source/tutorial/interfaces.rst:569 5bfe6fce5aea4766a4ae475fe5e5cd8d
msgid ""
"Idiom notation is commonly useful when defining evaluators. McBride and "
"Paterson describe such an evaluator [#ConorRoss]_, for a language similar"
" to the following:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:579 945077148afb43fdaac6c256bc9b0124
msgid ""
"Evaluation will take place relative to a context mapping variables "
"(represented as ``String``\\s) to ``Int`` values, and can possibly fail. "
"We define a data type ``Eval`` to wrap an evaluator:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:588 43d8aa22651c4e4d89fbf57439e41eab
msgid ""
"Wrapping the evaluator in a data type means we will be able to provide "
"implementations of interfaces for it later. We begin by defining a "
"function to retrieve values from the context during evaluation:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:602 b7c058ac22064ea9a8bd2a387aba7c4f
msgid ""
"When defining an evaluator for the language, we will be applying "
"functions in the context of an ``Eval``, so it is natural to give "
"``Eval`` an implementation of ``Applicative``. Before ``Eval`` can have "
"an implementation of ``Applicative`` it is necessary for ``Eval`` to have"
" an implementation of ``Functor``:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:621 1d899f91135f4ebb992bf22c1e03e161
msgid ""
"Evaluating an expression can now make use of the idiomatic application to"
" handle errors:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:635 db05884c4fb04c7ebbd305cfd63915d7
msgid "For example:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:645 8e92b68cc29c4e1e9a0449c54f9943ce
msgid "Named Implementations"
msgstr ""

#: ../../source/tutorial/interfaces.rst:647 a47a1e3e76074607a23d04dc781e6d24
msgid ""
"It can be desirable to have multiple implementations of an interface for "
"the same type, for example to provide alternative methods for sorting or "
"printing values. To achieve this, implementations can be *named* as "
"follows:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:659 34209e8462844c2088e068fb8c1fe24d
msgid ""
"This declares an implementation as normal, but with an explicit name, "
"``myord``. The syntax ``compare @{myord}`` gives an explicit "
"implementation to ``compare``, otherwise it would use the default "
"implementation for ``Nat``. We can use this, for example, to sort a list "
"of ``Nat`` in reverse. Given the following list:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:670 09570ce79d0344049489bbb27844d96e
msgid ""
"We can sort it using the default ``Ord`` implementation, by using the "
"``sort`` function available with ``import Data.List``, then we can try "
"with the named implementation ``myord`` as follows, at the Idris prompt:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:681 49557cdb09d341b58b35f90e5df0f381
msgid ""
"Sometimes, we also need access to a named parent implementation. For "
"example, the prelude defines the following ``Semigroup`` interface:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:689 3fb53545ba9f416b84785698337e5b83
msgid ""
"Then it defines ``Monoid``, which extends ``Semigroup`` with a “neutral” "
"value:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:697 0425bcbb85684dea977abb3f8c476a37
msgid ""
"We can define two different implementations of ``Semigroup`` and "
"``Monoid`` for ``Nat``, one based on addition and one on multiplication:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:708 bf0794ee96c142a5967cd547345fe166
msgid ""
"The neutral value for addition is ``0``, but the neutral value for "
"multiplication is ``1``. It's important, therefore, that when we define "
"implementations of ``Monoid`` they extend the correct ``Semigroup`` "
"implementation. We can do this with a ``using`` clause in the "
"implementation as follows:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:721 dd69e50300124dad9dec7903d81f5475
msgid ""
"The ``using PlusNatSemi`` clause indicates that ``PlusNatMonoid`` should "
"extend ``PlusNatSemi`` specifically."
msgstr ""

#: ../../source/tutorial/interfaces.rst:727 186f671c6c5845e7bfe8795d9d22fbc7
msgid "Interface Constructors"
msgstr ""

#: ../../source/tutorial/interfaces.rst:729 f697ec2c2b394fe283c0af8e1eed83e6
msgid ""
"Interfaces, just like records, can be declared with a user-defined "
"constructor."
msgstr ""

#: ../../source/tutorial/interfaces.rst:741 ed15701e4b0d4f018578eaaa02490e76
msgid "Then ``MkB : A t => t -> B t``."
msgstr ""

#: ../../source/tutorial/interfaces.rst:746 7554788d615a40158845f6a04abe1d0b
msgid "Determining Parameters"
msgstr ""

#: ../../source/tutorial/interfaces.rst:748 e2eeeb462ec5474a892fa8d4457065e1
msgid ""
"When an interface has more than one parameter, it can help resolution if "
"the parameters used to find an implementation are restricted. For "
"example:"
msgstr ""

#: ../../source/tutorial/interfaces.rst:757 385da1a30dd44954b326326da76bbe96
msgid ""
"In this interface, only ``m`` needs to be known to find an implementation"
" of this interface, and ``s`` can then be determined from the "
"implementation. This is declared with the ``| m`` after the interface "
"declaration. We call ``m`` a *determining parameter* of the "
"``MonadState`` interface, because it is the parameter used to find an "
"implementation. This is similar to the concept of *functional "
"dependencies* `in Haskell "
"<https://wiki.haskell.org/Functional_dependencies>`_."
msgstr ""

#: ../../source/tutorial/interfaces.rst:764 80536cee5caf4ba492536a5e1c840645
msgid ""
"Conor McBride and Ross Paterson. 2008. Applicative programming with "
"effects. J. Funct. Program. 18, 1 (January 2008), 1-13. "
"DOI=10.1017/S0956796807006326 "
"https://dx.doi.org/10.1017/S0956796807006326"
msgstr ""
