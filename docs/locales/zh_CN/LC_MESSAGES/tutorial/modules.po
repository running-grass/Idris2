# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: 467195537@qq.com\n"
"POT-Creation-Date: 2022-07-12 11:10+0800\n"
"PO-Revision-Date: 2022-07-22 13:19+0000\n"
"Last-Translator: Leo Liu <leo19920823@gmail.com>\n"
"Language-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/"
"idris2/tutorialmodules/zh_Hans/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.14-dev\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/tutorial/modules.rst:5 a61b170945894f5f9fc9a2c1132792f0
msgid "Modules and Namespaces"
msgstr "模块和命名空间"

#: ../../source/tutorial/modules.rst:7 49c43a743f814d2caf06c53fae12fb48
msgid ""
"An Idris program consists of a collection of modules. Each module "
"includes an optional ``module`` declaration giving the name of the "
"module, a list of ``import`` statements giving the other modules which "
"are to be imported, and a collection of declarations and definitions of "
"types, interfaces and functions. For example, the listing below gives a "
"module which defines a binary tree type ``BTree`` (in a file "
"``BTree.idr``):"
msgstr ""
"一个 Idris 程序由一个模块的集合组成。每个模块包括一个可选的 ``module`` "
"声明，用来给出模块的名称，一个 ``import`` 声明列表，给出要导入的其他模块，以"
"及一个类型、接口和函数的声明和定义的集合。例如，"
"下面的列表给出了一个定义二叉树类型的模块 ``BTree`` （在文件 ``BTree.idr`` "
"中）："

#: ../../source/tutorial/modules.rst:39 a57a3014abc14bbfb28e6970dcd49ef0
msgid ""
"The modifiers ``export`` and ``public export`` say which names are "
"visible from other namespaces. These are explained further below."
msgstr "修饰词 ``export`` 和 ``public export`` "
"表示哪些名称对其他命名空间可见。这些将在下面进一步解释。"

#: ../../source/tutorial/modules.rst:42 577963264d014dd18a03fc55a4b14859
msgid ""
"Then, this gives a main program (in a file ``bmain.idr``) which uses the "
"``BTree`` module to sort a list:"
msgstr "然后，这就给出了一个主程序（在文件 ``bmain.idr`` 中），它使用 ``BTree`` "
"模块对一个列表进行排序："

#: ../../source/tutorial/modules.rst:55 008e21737b4241d381044da9f73bb94a
msgid ""
"The same names can be defined in multiple modules: names are *qualified* "
"with the name of the module. The names defined in the ``BTree`` module "
"are, in full:"
msgstr "相同的名字可以被定义在多个模块中：名字可以用模块的名字来 *限定* 。在 "
"``BTree`` 模块中定义的名字，全限定名如下："

#: ../../source/tutorial/modules.rst:58 8c061dda1c8b4f36914e79859da1a06e
msgid "``BTree.BTree``"
msgstr "``BTree.BTree``"

#: ../../source/tutorial/modules.rst:59 48097d8975bf436ca25b373b8e3319af
msgid "``BTree.Leaf``"
msgstr "``BTree.Leaf``"

#: ../../source/tutorial/modules.rst:60 f8438582e7cb4268a9d06d8e291d0132
msgid "``BTree.Node``"
msgstr "``BTree.Node``"

#: ../../source/tutorial/modules.rst:61 ffeffb5910bf452aada4629ffba70128
msgid "``BTree.insert``"
msgstr "``BTree.insert``"

#: ../../source/tutorial/modules.rst:62 42ea9dad6ecb45a4990d6f84f28b3a7a
msgid "``BTree.toList``"
msgstr "``BTree.toList``"

#: ../../source/tutorial/modules.rst:63 780a137448294737b7ab1574a8037eea
msgid "``BTree.toTree``"
msgstr "``BTree.toTree``"

#: ../../source/tutorial/modules.rst:65 c63cb6750b90411ba9e772a39b7f6833
msgid ""
"If names are otherwise unambiguous, there is no need to give the fully "
"qualified name. Names can be disambiguated either by giving an explicit "
"qualification, using the ``with`` keyword, or according to their type."
msgstr "如果名字没有歧义，就没有必要给出完全限定的名字。名称也可以通过使用 ``with`` "
"关键字给出一个明确的限定，或者根据它们的类型来消除歧义。"

#: ../../source/tutorial/modules.rst:69 5ac34d1576494b9fb70bbfa2ddab7cd2
msgid "The ``with`` keyword in expressions comes in two variants:"
msgstr "``with`` 表达式中的关键字有两种变体："

#: ../../source/tutorial/modules.rst:71 9dba68a523f84629b1f8a33f2f146867
msgid "``with BTree.insert (insert x empty)`` for one name"
msgstr "``with BTree.insert (insert x empty)`` 用于单个名称"

#: ../../source/tutorial/modules.rst:72 e8d0ee80151944ac9311a12e4c34c42b
msgid "``with [BTree.insert, BTree.empty] (insert x empty)`` for multiple names"
msgstr "``with [BTree.insert, BTree.empty] (insert x empty)`` 用于多个名称"

#: ../../source/tutorial/modules.rst:74 558fc24df93341638dc06259d2408ec8
msgid ""
"This is particularly useful with ``do`` notation, where it can often "
"improve error messages: ``with MyModule.(>>=) do ...``"
msgstr "这对于 ``do`` 记法特别有用，它通常可以改善错误消息： ``with MyModule.(>>=) "
"do ...``"

#: ../../source/tutorial/modules.rst:77 950a150dbd5c41998bfeefe9d92baafa
msgid ""
"There is no formal link between the module name and its filename, "
"although it is generally advisable to use the same name for each. An "
"``import`` statement refers to a filename, using dots to separate "
"directories. For example, ``import foo.bar`` would import the file "
"``foo/bar.idr``, which would conventionally have the module declaration "
"``module foo.bar``. The only requirement for module names is that the "
"main module, with the ``main`` function, must be called ``Main`` — "
"although its filename need not be ``Main.idr``."
msgstr ""
"尽管一般来说，模块名称和文件名之间没有正式的联系，模块和文件使用相同的名称是"
"明智的。 ``import`` 语句指的是文件名，使用点来分隔目录。例如， ``import foo."
"bar`` 将导入文件 ``foo/bar.idr`` ，按照惯例，该文件的模块声明是 ``module foo."
"bar`` 。对模块名称的唯一要求是，带有 ``main`` 函数的主模块必须被称为 ``Main``"
" —— 尽管其文件名不需要是 ``Main.idr`` 。"

#: ../../source/tutorial/modules.rst:87 58dde4602c0543339eace11496201932
msgid "Export Modifiers"
msgstr "导出修饰符"

#: ../../source/tutorial/modules.rst:89 70ef82d614ea4487841452d7dea1d0eb
msgid ""
"Idris allows for fine-grained control over the visibility of a "
"namespace's contents. By default, all names defined in a namespace are "
"kept private.  This aids in specification of a minimal interface and for "
"internal details to be left hidden. Idris allows for functions, types, "
"and interfaces to be marked as: ``private``, ``export``, or ``public "
"export``. Their general meaning is as follows:"
msgstr ""
"Idris 允许对命名空间内容的可见性进行精细的控制。默认情况下，所有定义在名字空"
"间的名字都是私有的。 这有助于规范一个最小的接口和隐藏内部细节。Idris "
"允许函数、类型和接口被标记为 ``private``, ``export`` 或 ``public export`` "
"。它们的一般含义如下："

#: ../../source/tutorial/modules.rst:96 150e8eb5417b427fb7cc0fd3afe07077
msgid "``private`` meaning that it is not exported at all. This is the default."
msgstr "``private`` 意味着它不会被导出。这是默认设置。"

#: ../../source/tutorial/modules.rst:98 33455184f9844b9f91bbb6d7313efbc9
msgid "``export`` meaning that its top level type is exported."
msgstr "``export`` 意味着顶层类型已被导出。"

#: ../../source/tutorial/modules.rst:100 f221ad4d2907409397f0b209964fd1a2
msgid "``public export`` meaning that the entire definition is exported."
msgstr "``public export`` 意味着整个定义被导出。"

#: ../../source/tutorial/modules.rst:102 cd2430cbb7084ea893a39f8308a4b1cc
msgid ""
"A further restriction in modifying the visibility is that definitions "
"must not refer to anything within a lower level of visibility. For "
"example, ``public export`` definitions cannot use ``private`` or "
"``export`` names, and ``export`` types cannot use ``private`` names. This"
" is to prevent private names leaking into a module's interface."
msgstr ""
"修改可见性的另一个限制是，定义不能引用更低层次的可见性中的任何东西。例如， ``"
"public export`` 定义不能使用 ``private`` 或 ``export`` 名称，而 ``export`` "
"类型不能使用 ``private`` 名称。这是为了防止私有名称泄露到模块的接口中。"

#: ../../source/tutorial/modules.rst:109 f80ecc4dceec4fdbb388b5139fac6db2
msgid "Meaning for Functions"
msgstr "用于函数时的含义"

#: ../../source/tutorial/modules.rst:111 da0f4795844c435f948d4ce255b66441
msgid "``export`` the type is exported"
msgstr "``export`` 类型被导出"

#: ../../source/tutorial/modules.rst:113 4248c482a71e4eb88e89ec61946d25f2
msgid ""
"``public export`` the type and definition are exported, and the "
"definition can be used after it is imported. In other words, the "
"definition itself is considered part of the module's interface. The long "
"name ``public export`` is intended to make you think twice about doing "
"this."
msgstr ""
"``public export`` 类型和定义被导出，定义被导入后可以使用。换句话说，定义本身"
"被认为是模块接口的一部分。 ``public export`` "
"这个长名字是为了让你在做这件事时三思而行。"

#: ../../source/tutorial/modules.rst:121 094cad4ae6ab456a86e2d1098227b1cd
msgid ""
"Type synonyms in Idris are created by writing a function. When setting "
"the visibility for a module, it is usually a good idea to ``public "
"export`` all type synonyms if they are to be used outside the module. "
"Otherwise, Idris won't know what the synonym is a synonym for."
msgstr ""
"Idris 中的类型同义词是通过编写函数创建的。设置模块的可见性时，如果要在模块外"
"使用所有类型的同义词，最好将它们设置为 ``public export`` 。否则，Idris "
"将不知道该同义词是谁的同义词。"

#: ../../source/tutorial/modules.rst:127 b7ac5458996a41eeaf72b0cf37d6b9d0
msgid ""
"Since ``public export`` means that a function's definition is exported, "
"this effectively makes the function definition part of the module's API. "
"Therefore, it's generally a good idea to avoid using ``public export`` "
"for functions unless you really mean to export the full definition."
msgstr ""
"由于 ``public export`` 意味着一个函数的定义被导出，"
"这实际上使函数定义成为模块 API "
"的一部分。因此，一般来说，除非你真的想导出完整的定义，否则最好不要对函数使用 "
"``public export`` 。"

#: ../../source/tutorial/modules.rst:133 cd522525c8c44c948bee5853d0cef988
msgid ""
"*For beginners*: If the function needs to be accessed only at runtime, "
"use ``export``. However, if it's also meant to be used at *compile* time "
"(e.g. to prove a theorem), use ``public export``. For example, consider "
"the function ``plus : Nat -> Nat -> Nat`` discussed previously, and the "
"following theorem: ``thm : plus Z m = m``. In order to prove it, the type"
" checker needs to reduce ``plus Z m`` to ``m`` (and hence obtain ``thm : "
"m = m``). To achieve this, it will need access to the *definition* of "
"``plus``, which includes the equation ``plus Z m = m``. Therefore, in "
"this case, ``plus`` has to be marked as ``public export``."
msgstr ""
"*对于初学者* 。如果函数只需要在运行时访问，使用 ``export`` 。但是，"
"如果它也要在 *编译时使用* （例如，证明一个定理），则使用 ``public export`` "
"。例如，考虑前面讨论的函数 ``plus : Nat -> Nat -> Nat`` ，以及下面的定理。 ``"
"thm : plus Z m = m`` 。为了证明它，类型检查器需要将 ``plus Z m`` 还原为 ``m``"
" （从而得到 ``thm : m = m`` ）。* 为了实现这一点，它需要访问*的定义 ``plus`` "
"，其中包括方程式 ``plus Z m = m`` 。因此，在这种情况下， ``plus`` "
"必须被标记为 ``public export`` 。"

#: ../../source/tutorial/modules.rst:146 a35aa5bd1ff44acebaa67b4aed759d76
msgid "Meaning for Data Types"
msgstr "数据类型的含义"

#: ../../source/tutorial/modules.rst:148 53a4b2b00fd14755898ee4fae8e3518f
msgid "For data types, the meanings are:"
msgstr "对于数据类型，其含义是："

#: ../../source/tutorial/modules.rst:150 ffdb6c54d0264f1d8cec73a56fb60fe8
msgid "``export`` the type constructor is exported"
msgstr "``export`` 类型构造器被导出"

#: ../../source/tutorial/modules.rst:152 5078b0a0d1474085a6312f10a7aee7da
msgid "``public export`` the type constructor and data constructors are exported"
msgstr "``public export`` 类型构造器和数据构造器会被导出"

#: ../../source/tutorial/modules.rst:156 9b7687c2c49941b3b233e249fb42e3cf
msgid "Meaning for Interfaces"
msgstr "接口上的含义"

#: ../../source/tutorial/modules.rst:158 3a3255c6482840a8ad68c0ec46d3a79b
msgid "For interfaces, the meanings are:"
msgstr "对于接口，其含义是："

#: ../../source/tutorial/modules.rst:160 4f6503fafca94db5af6cf4e8045841c1
msgid "``export`` the interface name is exported"
msgstr "``export`` 接口名称被导出"

#: ../../source/tutorial/modules.rst:162 a743b968a53b418992c5a40776ad092b
msgid ""
"``public export`` the interface name, method names and default "
"definitions are exported"
msgstr "``public export`` 接口名称、方法名称和默认定义被导出"

#: ../../source/tutorial/modules.rst:166 97e7f4f6dd5e47f2a966867b0113b470
msgid "Propagating Inner Module API's"
msgstr "传播内部模块的 API"

#: ../../source/tutorial/modules.rst:168 5295d9e60bfc4d63a659ea0e2c5d6b7a
msgid ""
"Additionally, a module can re-export a module it has imported, by using "
"the ``public`` modifier on an ``import``. For example:"
msgstr "此外，一个模块可以重新输出它所导入的模块，方法是在 ``public`` 修改器上使用 "
"``import`` 。例如："

#: ../../source/tutorial/modules.rst:178 c0a8f872fcf84816a410ffd19bbe605a
msgid ""
"The module ``A`` will export the name ``a``, as well as any public or "
"abstract names in module ``C``, but will not re-export anything from "
"module ``B``."
msgstr "模块 ``A`` 将导出名称 ``a`` 以及模块 ``C`` 中的任何公共或抽象名称，"
"但不会从模块 ``B`` 重新导出任何东西。"

#: ../../source/tutorial/modules.rst:183 d2e135a95aeb4ba88ee05070d123e678
msgid "Renaming imports"
msgstr "重命名导入"

#: ../../source/tutorial/modules.rst:185 2619ba40ad2746af8fdf82e0a76ddb1b
msgid ""
"Sometimes it is convenient to be able to access the names in another "
"module via a different namespace (typically, a shorter one). For this, "
"you can use `import...as`. For example:"
msgstr "有时，能够通过不同的命名空间（通常是较短的命名空间）访问另一个模块中的名称是"
"很方便的。为此，你可以使用 `import...as` 。例如："

#: ../../source/tutorial/modules.rst:195 9dba00e17367400e815c6f73f09d53d9
msgid ""
"This module ``A`` has access to the exported names from module "
"``Data.List``, but can also explicitly access them via the module name "
"``L``. ``import...as`` can also be combined with ``import public`` to "
"create a module which exports a larger API from other sub-modules:"
msgstr ""
"这个模块 ``A`` 可以访问从模块 ``Data.List`` 导出的名称，但也可以通过模块名称 "
"``L`` 明确地访问它们。 ``import...as`` 也可以与 ``import public`` "
"结合起来，创建一个模块，从其他子模块导出一个更大的API："

#: ../../source/tutorial/modules.rst:207 8fbcb029836c4d27b021e14f509443fc
msgid ""
"Here, any module which imports ``Books`` will have access to the exported"
" interfaces of ``Books.Hardback`` and ``Books.Comic`` both under the "
"namespace ``Books``."
msgstr ""
"在这里，任何导入 ``Books`` 的模块都可以访问 ``Books.Hardback`` 和 ``Books."
"Comic`` 的导出接口，两者都在命名空间 ``Books`` 。"

#: ../../source/tutorial/modules.rst:212 739752078d6c42caa2f2cd62328e2767
msgid "Explicit Namespaces"
msgstr "显式命名空间"

#: ../../source/tutorial/modules.rst:214 758d3a928bd84ad7ab85b6d637c5198a
msgid ""
"Defining a module also defines a namespace implicitly. However, "
"namespaces can also be given *explicitly*. This is most useful if you "
"wish to overload names within the same module:"
msgstr "定义一个模块也隐含地定义了一个命名空间。然而，命名空间也可以被 *明确* 地赋予 "
"。如果你想在同一个模块中重载名字，这会非常有用："

#: ../../source/tutorial/modules.rst:232 063f8818d3cb407c8a6cfc2fe23a0f59
msgid ""
"This (admittedly contrived) module defines two functions with fully "
"qualified names ``Foo.X.test`` and ``Foo.Y.test``, which can be "
"disambiguated by their types:"
msgstr "这个模块（公认是设计好的）定义了两个函数，其全称是 ``Foo.X.test`` 和 ``Foo.Y."
"test`` ，可以通过其类型来区分："

#: ../../source/tutorial/modules.rst:243 22b1ef81baa442169e41dfeb15a63500
msgid ""
"The export rules, ``public export`` and ``export``, are *per namespace*, "
"not *per file*, so the two ``test`` definitions above need the ``export``"
" flag to be visible outside their own namespaces."
msgstr ""
"导出规则 ``public export`` 和 ``export`` ，是 *按命名空间* ，而不是 *按文件* "
"，所以上面的两个 ``test`` 定义需要 ``export`` "
"标志才能在它们自己的命名空间之外可见。"

#: ../../source/tutorial/modules.rst:248 2918fda26abf4d9199f452446203bc6b
msgid "Parameterised blocks"
msgstr "参数化块"

#: ../../source/tutorial/modules.rst:250 cd6e4bb5f0014767986c0518aec62f8d
msgid ""
"Groups of functions can be parameterised over a number of arguments using"
" a ``parameters`` declaration, for example:"
msgstr "例如，可以使用 ``parameters`` 声明，在一些参数上对函数组进行参数化："

#: ../../source/tutorial/modules.rst:259 ff8ac0c9dff543c0bfbcc6d5d0d1c3cf
msgid ""
"The effect of a ``parameters`` block is to add the declared parameters to"
" every function, type and data constructor within the block. "
"Specifically, adding the parameters to the front of the argument list. "
"Outside the block, the parameters must be given explicitly. The "
"``addAll`` function, when called from the REPL, will thus have the "
"following type signature."
msgstr ""
"``parameters`` 块的作用是将声明的参数添加到该块内的每个函数、类型和数据构造器"
"中。具体来说，就是将参数添加到参数列表的前面。在块之外，必须明确地给出参数。 "
"``addAll`` 函数，当从 REPL 中调用时，将有以下类型签名。"

#: ../../source/tutorial/modules.rst:271 185dc391a4e74144a7eb5babf340b769
msgid "and the following definition."
msgstr "和以下定义。"

#: ../../source/tutorial/modules.rst:278 a81494a3e1064656a63c1b30fb8871bc
msgid ""
"Parameters blocks can be nested, and can also include data declarations, "
"in which case the parameters are added explicitly to all type and data "
"constructors. They may also be dependent types with implicit arguments:"
msgstr "参数块可以是嵌套的，也可以包括数据声明，在这种情况下，参数被明确地添加到所有"
"类型和数据构造器中。它们也可以是具有隐含参数的依赖类型："

#: ../../source/tutorial/modules.rst:291 0025d14812af472e9a10700cafda136d
msgid ""
"To use ``Vects`` or ``append`` outside the block, we must also give the "
"``xs`` and ``y`` arguments. Here, we can use placeholders for the values "
"which can be inferred by the type checker:"
msgstr ""
"要在块外使用 ``Vects`` 或 ``append`` ，我们还必须给出 ``xs`` 和 ``y`` "
"的参数。在这里，我们可以使用占位符来表示可以由类型检查器推断出来的值："
