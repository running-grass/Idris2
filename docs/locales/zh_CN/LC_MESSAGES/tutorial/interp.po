# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 11:10+0800\n"
"PO-Revision-Date: 2022-07-23 04:11+0000\n"
"Last-Translator: admin <467195537@qq.com>\n"
"Language-Team: Chinese (Simplified) <https://weblate.grass.work:30443/"
"projects/idris2/tutorialinterp/zh_Hans/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.13.1\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/tutorial/interp.rst:5 3ebe9d4d7cef4b9fa94850e3b7ed91c0
msgid "Example: The Well-Typed Interpreter"
msgstr "示例——良类型的解释器"

#: ../../source/tutorial/interp.rst:7 efd20f4d19634f3d8b1b49e7258ff883
msgid ""
"In this section, we’ll use the features we’ve seen so far to write a "
"larger example, an interpreter for a simple functional programming "
"language, with variables, function application, binary operators and an "
"``if...then...else`` construct. We will use the dependent type system to "
"ensure that any programs which can be represented are well-typed."
msgstr ""

#: ../../source/tutorial/interp.rst:15 7582c82d21d247c2ab314a48f4eb096c
msgid "Representing Languages"
msgstr ""

#: ../../source/tutorial/interp.rst:17 eea60e43d9ed495d915e16d7860cebce
msgid ""
"First, let us define the types in the language. We have integers, "
"booleans, and functions, represented by ``Ty``:"
msgstr ""

#: ../../source/tutorial/interp.rst:24 4da9c371c34c4198992722e95c4cebc3
msgid ""
"We can write a function to translate these representations to a concrete "
"Idris type — remember that types are first class, so can be calculated "
"just like any other value:"
msgstr ""

#: ../../source/tutorial/interp.rst:35 e9a428d9f6564747903cc8b809f72b55
msgid ""
"We're going to define a representation of our language in such a way that"
" only well-typed programs can be represented. We'll index the "
"representations of expressions by their type, **and** the types of local "
"variables (the context). The context can be represented using the "
"``Vect`` data type, so we'll need to import ``Data.Vect`` at the top of "
"our source file:"
msgstr ""

#: ../../source/tutorial/interp.rst:46 b131e4e6fdba4721835190e04ba2c543
msgid ""
"Expressions are indexed by the types of the local variables, and the type"
" of the expression itself:"
msgstr ""

#: ../../source/tutorial/interp.rst:53 bfb3b10d7e634468aec433f29ea57ef6
msgid "The full representation of expressions is:"
msgstr ""

#: ../../source/tutorial/interp.rst:72 67609ca8cf2047a683bb9ab31808cf7f
msgid ""
"The code above makes use of the ``Vect`` and ``Fin`` types from the base "
"libraries. ``Fin`` is available as part of ``Data.Vect``. Throughout, "
"``ctxt`` refers to the local variable context."
msgstr ""

#: ../../source/tutorial/interp.rst:76 21a8ca60b604481da5f15aeecd4affe8
msgid ""
"Since expressions are indexed by their type, we can read the typing rules"
" of the language from the definitions of the constructors. Let us look at"
" each constructor in turn."
msgstr ""

#: ../../source/tutorial/interp.rst:80 2450caec92a346aca8d98bf7d63c3286
msgid ""
"We use a nameless representation for variables — they are *de Bruijn "
"indexed*. Variables are represented by a proof of their membership in the"
" context, ``HasType i ctxt T``, which is a proof that variable ``i`` in "
"context ``ctxt`` has type ``T``. This is defined as follows:"
msgstr ""

#: ../../source/tutorial/interp.rst:91 c2937ebff7cc47e0b0a828f8ff3298a7
msgid ""
"We can treat *Stop* as a proof that the most recently defined variable is"
" well-typed, and *Pop n* as a proof that, if the ``n``\\ th most recently"
" defined variable is well-typed, so is the ``n+1``\\ th. In practice, "
"this means we use ``Stop`` to refer to the most recently defined "
"variable, ``Pop Stop`` to refer to the next, and so on, via the ``Var`` "
"constructor:"
msgstr ""

#: ../../source/tutorial/interp.rst:102 615ff27786e44df5a0a42876c06d17e8
msgid ""
"So, in an expression ``\\x. \\y. x y``, the variable ``x`` would have a "
"de Bruijn index of 1, represented as ``Pop Stop``, and ``y 0``, "
"represented as ``Stop``. We find these by counting the number of lambdas "
"between the definition and the use."
msgstr ""

#: ../../source/tutorial/interp.rst:107 3d09c78f5b0146e2aeb301797ceff173
msgid "A value carries a concrete representation of an integer:"
msgstr ""

#: ../../source/tutorial/interp.rst:113 c35ed0480c0c4aa5813ad391b6ad7ea7
msgid ""
"A lambda creates a function. In the scope of a function of type ``a -> "
"t``, there is a new local variable of type ``a``, which is expressed by "
"the context index:"
msgstr ""

#: ../../source/tutorial/interp.rst:121 f5f755c5983c48bca7a66f2d4a70fc26
msgid ""
"Function application produces a value of type ``t`` given a function from"
" ``a`` to ``t`` and a value of type ``a``:"
msgstr ""

#: ../../source/tutorial/interp.rst:128 b416886980da492e896e54ff98b9f802
msgid ""
"We allow arbitrary binary operators, where the type of the operator "
"informs what the types of the arguments must be:"
msgstr ""

#: ../../source/tutorial/interp.rst:136 25ef61455236417fbbc9ab7461c8c295
msgid ""
"Finally, ``If`` expressions make a choice given a boolean. Each branch "
"must have the same type, and we will evaluate the branches lazily so that"
" only the branch which is taken need be evaluated:"
msgstr ""

#: ../../source/tutorial/interp.rst:148 4139887e9e3a4dfbac192bd7fd3c0e6d
msgid "Writing the Interpreter"
msgstr ""

#: ../../source/tutorial/interp.rst:150 3e0f4f541ba14cfb8a7edd18e7a84725
msgid ""
"When we evaluate an ``Expr``, we'll need to know the values in scope, as "
"well as their types. ``Env`` is an environment, indexed over the types in"
" scope. Since an environment is just another form of list, albeit with a "
"strongly specified connection to the vector of local variable types, we "
"use the usual ``::`` and ``Nil`` constructors so that we can use the "
"usual list syntax. Given a proof that a variable is defined in the "
"context, we can then produce a value from the environment:"
msgstr ""

#: ../../source/tutorial/interp.rst:169 cb0e4f7ab6b84bd1b34383755db3a3b0
msgid ""
"Given this, an interpreter is a function which translates an ``Expr`` "
"into a concrete Idris value with respect to a specific environment:"
msgstr ""

#: ../../source/tutorial/interp.rst:177 eb097f6973434891b9e8f2de8a680e0c
msgid ""
"The complete interpreter is defined as follows, for reference. For each "
"constructor, we translate it into the corresponding Idris value:"
msgstr ""

#: ../../source/tutorial/interp.rst:190 8659e4d366534996af138b56224600f1
msgid ""
"Let us look at each case in turn. To translate a variable, we simply look"
" it up in the environment:"
msgstr ""

#: ../../source/tutorial/interp.rst:197 8adb63c4892a47d1bc43e471c7d1ccaa
msgid ""
"To translate a value, we just return the concrete representation of the "
"value:"
msgstr ""

#: ../../source/tutorial/interp.rst:204 2f0012840fc3488dafd06660f50fabb0
msgid ""
"Lambdas are more interesting. In this case, we construct a function which"
" interprets the scope of the lambda with a new value in the environment. "
"So, a function in the object language is translated to an Idris function:"
msgstr ""

#: ../../source/tutorial/interp.rst:213 fed8bf1a7b204c29a182b40c4ca204c7
msgid ""
"For an application, we interpret the function and its argument and apply "
"it directly. We know that interpreting ``f`` must produce a function, "
"because of its type:"
msgstr ""

#: ../../source/tutorial/interp.rst:221 2fa6ae31ee89427092ec3547a727e93a
msgid ""
"Operators and conditionals are, again, direct translations into the "
"equivalent Idris constructs. For operators, we apply the function to its "
"operands directly, and for ``If``, we apply the Idris "
"``if...then...else`` construct directly."
msgstr ""

#: ../../source/tutorial/interp.rst:233 e41935b305b4496f804af9c95204dcbe
msgid "Testing"
msgstr ""

#: ../../source/tutorial/interp.rst:235 11743793f0ab4a4ab331002e65348dce
msgid ""
"We can make some simple test functions. Firstly, adding two inputs ``\\x."
" \\y. y + x`` is written as follows:"
msgstr ""

#: ../../source/tutorial/interp.rst:243 e0fec2ea17084542836b0b19875927a4
msgid ""
"More interestingly, a factorial function ``fact`` (e.g. ``\\x. if (x == "
"0) then 1 else (fact (x-1) * x)``), can be written as:"
msgstr ""

#: ../../source/tutorial/interp.rst:256 3f399bcf5b87455f9e8e793332ed75de
msgid "Running"
msgstr ""

#: ../../source/tutorial/interp.rst:258 c68aab351e384304a6435144e069f6d8
msgid ""
"To finish, we write a ``main`` program which interprets the factorial "
"function on user input:"
msgstr ""

#: ../../source/tutorial/interp.rst:268 1b0b6916a08d421a81d911120af29428
msgid ""
"Here, ``cast`` is an overloaded function which converts a value from one "
"type to another if possible. Here, it converts a string to an integer, "
"giving 0 if the input is invalid. An example run of this program at the "
"Idris interactive environment is:"
msgstr ""

#: ../../source/tutorial/interp.rst:278 fe4c471ec1374316bd1ddb2693e90c8a
msgid "Aside: ``cast``"
msgstr ""

#: ../../source/tutorial/interp.rst:280 13f720bf167e4910a77084ba59c947ab
msgid ""
"The prelude defines an interface ``Cast`` which allows conversion between"
" types:"
msgstr ""

#: ../../source/tutorial/interp.rst:288 2c25062e8e424ecb98a4730f5bfc386c
msgid ""
"It is a *multi-parameter* interface, defining the source type and object "
"type of the cast. It must be possible for the type checker to infer "
"*both* parameters at the point where the cast is applied. There are casts"
" defined between all of the primitive types, as far as they make sense."
msgstr ""
