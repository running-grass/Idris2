# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: 467195537@qq.com\n"
"POT-Creation-Date: 2022-07-12 11:10+0800\n"
"PO-Revision-Date: 2022-07-21 14:13+0000\n"
"Last-Translator: Leo Liu <leo19920823@gmail.com>\n"
"Language-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/"
"idris2/tutorialmultiplicities/zh_Hans/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.14-dev\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/tutorial/multiplicities.rst:5 a3f001782e864dfd825050aa93641cd0
msgid "Multiplicities"
msgstr "多重性"

#: ../../source/tutorial/multiplicities.rst:7 1749cde5c67947758d1a8ea62ed9d130
msgid ""
"Idris 2 is based on `Quantitative Type Theory (QTT) <https://bentnib.org"
"/quantitative-type-theory.html>`_, a core language developed by Bob Atkey"
" and Conor McBride. In practice, this means that every variable in Idris "
"2 has a *quantity* associated with it. A quantity is one of:"
msgstr ""
"Idris 2 是基于 `量化类型理论（QTT） <https://bentnib.org/quantitative-type-"
"theory.html>`_ ，这是由 Bob Atkey 和 Conor McBride 开发的核心语言。在实践中，"
"Idris 2 中的每个变量都有一个 *数量* 与之相关。数量是的取值是下列其中之一："

#: ../../source/tutorial/multiplicities.rst:13 d39f359e67c54f89a2d6321ff2206540
msgid "``0``, meaning that the variable is *erased* at run time"
msgstr "``0`` ，表示变量在运行时被 *擦除*"

#: ../../source/tutorial/multiplicities.rst:14 b8ec3a8096d7450f883db7e1df0a1f25
msgid "``1``, meaning that the variable is used *exactly once* at run time"
msgstr "``1`` ，表示变量在运行时 *正好使用一次*"

#: ../../source/tutorial/multiplicities.rst:15 305156110468493b9f7029ec17168399
msgid "*Unrestricted*, which is the same behaviour as Idris 1"
msgstr "*不受限制* ，这与 Idris 1 的行为相同"

#: ../../source/tutorial/multiplicities.rst:17 0cc2ac2b04d948a09f0a9d3d0829e1ae
msgid ""
"We can see the multiplicities of variables by inspecting holes. For "
"example, if we have the following skeleton definition of ``append`` on "
"vectors..."
msgstr "我们可以通过检查孔看到变量的多重性。例如，如果我们有以下关于向量的 ``append``"
" 的骨架定义..."

#: ../../source/tutorial/multiplicities.rst:25 52a77d10680c4f71bf9e5e55e1f5b183
msgid "...we can look at the hole ``append_rhs``:"
msgstr "...我们可以看一下 ``append_rhs`` 这个孔："

#: ../../source/tutorial/multiplicities.rst:38 9f168e2f10974ca4ab852432754e9b71
msgid ""
"The ``0`` next to ``m``, ``a`` and ``n`` mean that they are in scope, but"
" there will be ``0`` occurrences at run-time. That is, it is "
"**guaranteed** that they will be erased at run-time."
msgstr ""
"``0`` 旁边的 ``m``, ``a`` 和 ``n`` 表示它们在范作用域内，但在运行时将会出现 "
"``0`` 次，也就是说，将会 *保证* 它们在运行时会被删除。"

#: ../../source/tutorial/multiplicities.rst:42 6fa7f9a0682e4db6b8f315688b0c8d7f
msgid "Multiplicities can be explicitly written in function types as follows:"
msgstr "多重性可以显式地写在函数类型中，如下所示："

#: ../../source/tutorial/multiplicities.rst:44 a7c6e390cf114e9f8965768c9ff979f1
msgid ""
"``ignoreN : (0 n : Nat) -> Vect n a -> Nat`` - this function cannot look "
"at ``n`` at run time"
msgstr "``ignoreN : (0 n : Nat) -> Vect n a -> Nat`` - 这个函数在运行时 ``n`` "
"将不可见"

#: ../../source/tutorial/multiplicities.rst:46 c70f5b5ec36b40cb8574a37c17ed2012
msgid ""
"``duplicate : (1 x : a) -> (a, a)`` - this function must use ``x`` "
"exactly once (so good luck implementing it, by the way. There is no "
"implementation because it would need to use ``x`` twice!)"
msgstr ""
"``duplicate : (1 x : a) -> (a, a)`` - 这个函数必须准确地只使用 ``x`` "
"一次（因此，顺便说一下，祝你实现它。这个例子没有实现，因为它需要使用 ``x`` "
"两次！)"

#: ../../source/tutorial/multiplicities.rst:50 326c10dda0b249b883daf75e305d74b9
msgid ""
"If there is no multiplicity annotation, the argument is unrestricted. If,"
" on the other hand, a name is implicitly bound (like ``a`` in both "
"examples above) the argument is erased. So, the above types could also be"
" written as:"
msgstr ""
"如果没有多重性注解，参数是不受限制的。另一方面，如果名字被隐式绑定（"
"比如上面两个例子中的 ``a`` "
"），那么参数就会被抹去。所以，上面的类型也可以写成："

#: ../../source/tutorial/multiplicities.rst:54 7073272ab70d4da3ac8c7c71d1c78952
msgid "``ignoreN : {0 a : _} -> (0 n : Nat) -> Vect n a -> Nat``"
msgstr "``ignoreN : {0 a : _} -> (0 n : Nat) -> Vect n a -> Nat``"

#: ../../source/tutorial/multiplicities.rst:55 038ef3c27acc4e47a1a80d7574a592db
msgid "``duplicate : {0 a : _} -> (1 x : a) -> (a, a)``"
msgstr "``duplicate : {0 a : _} -> (1 x : a) -> (a, a)``"

#: ../../source/tutorial/multiplicities.rst:57 b91e2ed5c72a40deb9c37db979711395
msgid ""
"This section describes what this means for your Idris 2 programs in "
"practice, with several examples. In particular, it describes:"
msgstr "本节描述了多重性对你的 Idris 2 程序的实际意义，并有几个例子。特别描述了："

#: ../../source/tutorial/multiplicities.rst:60 83622fe8e59a4bc397a70c5323ae5c32
msgid ""
":ref:`sect-erasure` - how to know what is relevant at run time and what "
"is erased"
msgstr ":ref:`sect-erasure` - 如何知道哪些是运行时相关的，哪些是被擦除的"

#: ../../source/tutorial/multiplicities.rst:61 5af9c8bcfd2346a09b2a36e0134886cc
msgid ""
":ref:`sect-linearity` - using the type system to encode *resource usage "
"protocols*"
msgstr ":ref:`sect-linearity` - 使用类型系统对 *资源使用协议* 进行编码"

#: ../../source/tutorial/multiplicities.rst:62 dbd6b0948f144b43b6c5ffac899142d6
msgid ":ref:`sect-pmtypes` - truly first class types"
msgstr ":ref:`sect-pmtypes` - 真正的一等类型"

#: ../../source/tutorial/multiplicities.rst:64 602c1d7127744f9a850f757d7fc8e2ed
msgid ""
"The most important of these for most programs, and the thing you'll need "
"to know about if converting Idris 1 programs to work with Idris 2, is "
"erasure_. The most interesting, however, and the thing which gives Idris "
"2 much more expressivity, is linearity_, so we'll start there."
msgstr ""
"如果将 Idris 1 程序转换到 Idris 2 ，对于大多数程序来说，"
"其中你需要了解的最重要的问题是 擦除_ 。然而，最有趣的，也是给 Idris 2 "
"带来更多表现力的，是 线性_ ，所以我们将从线性开始。"

#: ../../source/tutorial/multiplicities.rst:72 9e11a811d0214e4b83384f092577ea4f
msgid "Linearity"
msgstr "线性"

#: ../../source/tutorial/multiplicities.rst:74 868a4573bbd547c597f32c34109be382
msgid ""
"The ``1`` multiplicity expresses that a variable must be used exactly "
"once. By \"used\" we mean either:"
msgstr "``1`` 多重性表达了一个变量必须被精确的只使用一次。我们所说的 \"使用 \" "
"是指以下两种情况："

#: ../../source/tutorial/multiplicities.rst:77 c02111966a7044059836348c651d22b3
msgid ""
"if the variable is a data type or primitive value, it is pattern matched "
"against, ex. by being the subject of a *case* statement, or a function "
"argument that is pattern matched against, etc.,"
msgstr "如果变量是一个数据类型或原始值，它将被模式匹配，例如，通过成为 *case* "
"语句的主题，或成为模式匹配的函数参数等等，"

#: ../../source/tutorial/multiplicities.rst:78 3bb59b97f412411ba8a3713a5f4b5df2
msgid ""
"if the variable is a function, that function is applied (i.e. ran with an"
" argument)"
msgstr "如果该变量是一个函数，则该函数被应用（即只用一个参数运行）"

#: ../../source/tutorial/multiplicities.rst:80 0df185dc750543cb9ebcd3bb321a2099
msgid ""
"First, we'll see how this works on some small examples of functions and "
"data types, then see how it can be used to encode `resource protocols`_."
msgstr "首先，我们将看到这在一些函数和数据类型的小例子上是如何工作的，"
"然后看它如何被用来编码 `资源协议`_ 。"

#: ../../source/tutorial/multiplicities.rst:83 f88c0a0000664adea44cc4f037dabb35
msgid ""
"Above, we saw the type of ``duplicate``. Let's try to write it "
"interactively, and see what goes wrong. We'll start by giving the type "
"and a skeleton definition with a hole"
msgstr "上面，我们看到了 ``duplicate`` 的类型。让我们试着以交互的方式来写它，看看出了"
"什么问题。我们首先给出类型和一个带孔的骨架定义"

#: ../../source/tutorial/multiplicities.rst:92 f2037d7224d3477187444ab51c2a9ae9
msgid ""
"Checking the type of a hole tells us the multiplicity of each variable in"
" scope. If we check the type of ``?help`` we'll see that we can't use "
"``a`` at run time, and we have to use ``x`` exactly once::"
msgstr ""
"检查一个孔的类型可以告诉我们作用域内每个变量的多重性。如果我们检查 ``?help`` "
"的类型，我们会发现我们在运行时不能使用 ``a`` ，而且我们必须准确地只使用 ``x``"
" 一次："

#: ../../source/tutorial/multiplicities.rst:102
#: 7812c7a732154aafa97edf427c193ccb
msgid "If we use ``x`` for one part of the pair..."
msgstr "如果我们用 ``x`` 来表示对中的一部分..."

#: ../../source/tutorial/multiplicities.rst:109
#: 20527bff63b24ae3bb60422b145bab8c
msgid ""
"...then the type of the remaining hole tells us we can't use it for the "
"other::"
msgstr "...那么剩下的孔的类型告诉我们，我们不能把它用于其他地方了："

#: ../../source/tutorial/multiplicities.rst:117
#: f6b9e20601ff48be86231ab0648ce252
msgid ""
"The same happens if we try defining ``duplicate x = (?help, x)`` (try "
"it!)."
msgstr "如果我们尝试定义 ``duplicate x = (?help, x)`` "
"，也会发生同样的情况（试试吧！）。"

#: ../../source/tutorial/multiplicities.rst:119
#: 3f6989a603b14943a02c09eea04427c2
msgid ""
"In order to avoid parsing ambiguities, if you give an explicit "
"multiplicity for a variable as with the argument to ``duplicate``, you "
"need to give it a name too. But, if the name isn't used in the scope of "
"the type, you can use ``_`` instead of a name, as follows:"
msgstr ""
"为了避免解析上的歧义，如果你为一个变量给出一个明确的多重性，就像对 "
"``duplicate`` "
"的参数那样，你也需要给它一个名字。但是，如果这个名字不在类型的作用域内使用，"
"你可以用 ``_`` 来代替名字，如下所示："

#: ../../source/tutorial/multiplicities.rst:128
#: 08b6876bf77c4466b649b294de39a0f0
msgid ""
"The intution behind multiplicity ``1`` is that if we have a function with"
" a type of the following form..."
msgstr "多重性 ``1`` 背后的意图是，如果我们有一个函数，其类型为以下形式..."

#: ../../source/tutorial/multiplicities.rst:135
#: 39b5ba81865845129680fb9a714aa166
msgid ""
"...then the guarantee given by the type system is that *if* ``f x`` *is "
"used exactly once, then* ``x`` *is used exactly once*. So, if we insist "
"on trying to define ``duplicate``...::"
msgstr ""
"...那么类型系统给出的保证是： *如果* `f x`` *被精确使用一次，那么* `x` "
"*被精确使用一次* 。所以，如果我们坚持试图定义 ``duplicate`` ...:"

#: ../../source/tutorial/multiplicities.rst:141
#: cb4c104c595f4facbcf320b042694f25
msgid "...then Idris will complain::"
msgstr "...然后 Idris 会抱怨："

#: ../../source/tutorial/multiplicities.rst:146
#: 267f91621faf4371a45462bf0a98b6a6
msgid ""
"A similar intuition applies for data types. Consider the following types,"
" ``Lin`` which wraps an argument that must be used once, and ``Unr`` "
"which wraps an argument with unrestricted use"
msgstr ""
"类似的直觉也适用于数据类型。考虑以下类型， ``Lin`` "
"，它包装了一个必须使用一次的参数， ``Unr`` "
"，它包装了一个可以不受限制使用的参数"

#: ../../source/tutorial/multiplicities.rst:158
#: 821f0686461e4b9790e65c2357c4358e
msgid ""
"If ``MkLin x`` is used once, then ``x`` is used once. But if ``MkUnr x`` "
"is used once, there is no guarantee on how often ``x`` is used. We can "
"see this a bit more clearly by starting to write projection functions for"
" ``Lin`` and ``Unr`` to extract the argument"
msgstr ""
"如果 ``MkLin x`` 被使用一次，那么 ``x`` 被使用一次。但是如果 ``MkUnr x`` "
"被使用一次，就不能保证 ``x`` 被使用的频率。我们可以通过开始为 ``Lin`` 和 "
"``Unr`` 写投影函数来更清楚地看到这一点，以便提取参数"

#: ../../source/tutorial/multiplicities.rst:171
#: 88e34141cc9c42afba03359a11c181a4
msgid ""
"Checking the types of the holes shows us that, for ``getLin``, we must "
"use ``x`` exactly once (Because the ``val`` argument is used once, by "
"pattern matching on it as ``MkLin x``, and if ``MkLin x`` is used once, "
"``x`` must be used once)::"
msgstr ""
"检查孔的类型表明，对于 ``getLin`` ，我们必须准确地使用 ``x`` 一次（因为 "
"``val`` 参数被使用一次，通过对其进行模式匹配为 ``MkLin x`` ，如果 ``MkLin x``"
" 被使用一次，``x`` 必须使用一次）："

#: ../../source/tutorial/multiplicities.rst:182
#: aeeda3d0c23347b49e0f37eba5f66a1b
msgid ""
"For ``getUnr``, however, we still have to use ``val`` once, again by "
"pattern matching on it, but using ``MkUnr x`` once doesn't place any "
"restrictions on ``x``. So, ``x`` has unrestricted use in the body of "
"``getUnr``::"
msgstr ""
"然而，对于 ``getUnr`` ，我们仍然必须使用 ``val`` 一次，再次对其进行模式匹配，"
"但是使用 ``MkUnr x`` 一次并不会对 ``x`` 产生任何限制。因此， ``x`` 在 "
"``getUnr`` 的正文中可以不受限制地使用："

#: ../../source/tutorial/multiplicities.rst:192
#: f087e0272bf34e39b0c671cc48153f5b
msgid "If ``getLin`` has an unrestricted argument..."
msgstr "如果 ``getLin`` 有一个不受限制的参数..."

#: ../../source/tutorial/multiplicities.rst:199
#: 788aaedfcd1a407ba0406717dcbb046f
msgid "...then ``x`` is unrestricted in ``howmanyLin``::"
msgstr "...那么 ``x`` 在 ``howmanyLin`` 中是不受限制的："

#: ../../source/tutorial/multiplicities.rst:207
#: 511ebb166f694239b77c9aadd13076d7
msgid ""
"Remember the intuition from the type of ``MkLin`` is that if ``MkLin x`` "
"is used exactly once, ``x`` is used exactly once. But, we didn't say that"
" ``MkLin x`` would be used exactly once, so there is no restriction on "
"``x``."
msgstr ""
"记住从 ``MkLin`` 的类型中得到的直觉是，如果 ``MkLin x`` 正好使用一次， ``x`` "
"也正好使用一次。但是，我们没有说 ``MkLin x`` 会被精确使用一次，所以对 ``x`` "
"没有限制。"

#: ../../source/tutorial/multiplicities.rst:212
#: 60d6df5b7f76411bb70eee0ad458b1f0
msgid "Resource protocols"
msgstr "资源协议"

#: ../../source/tutorial/multiplicities.rst:214
#: d2c071f093894d1f9339c8bcdc721ccf
msgid ""
"One way to take advantage of being able to express linear usage of an "
"argument is in defining resource usage protocols, where we can use "
"linearity to ensure that any unique external resource has only one "
"instance, and we can use functions which are linear in their arguments to"
" represent state transitions on that resource. A door, for example, can "
"be in one of two states, ``Open`` or ``Closed``"
msgstr ""
"利用能够表达参数的线性用法的一种方法是在定义资源使用协议时，我们可以使用线性"
"来确保任何独特的外部资源只有一个实例，我们可以使用参数为线性的函数来表示该资"
"源的状态转换。例如，一扇门可以处于两种状态之一， ``Open`` 或 ``Closed``"

#: ../../source/tutorial/multiplicities.rst:228
#: 909f9053664847228624f4d6f3c4c079
msgid ""
"(Okay, we're just pretending here - imagine the ``doorId`` is a reference"
" to an external resource!)"
msgstr "(好吧，我们在这里只是假装--想象一下 ``doorId`` 是对一个外部资源的引用！)"

#: ../../source/tutorial/multiplicities.rst:231
#: eaae02d262be4b00be4c68f881dd0c4d
msgid ""
"We can define functions for opening and closing the door which explicitly"
" describe how they change the state of a door, and that they are linear "
"in the door"
msgstr "我们可以定义开门和关门的函数，明确描述它们如何改变门的状态，并且它们在门中是"
"线性的"

#: ../../source/tutorial/multiplicities.rst:240
#: dadaa1f8336a475d8bc25c605901da5a
msgid ""
"Remember, the intuition is that if ``openDoor d`` is used exactly once, "
"then ``d`` is used exactly once. So, provided that a door ``d`` has "
"multiplicity ``1`` when it's created, we *know* that once we call "
"``openDoor`` on it, we won't be able to use ``d`` again. Given that ``d``"
" is an external resource, and ``openDoor`` has changed it's state, this "
"is a good thing!"
msgstr ""
"记住，直觉是这样的，如果 ``openDoor d`` 被精确使用一次，那么 ``d`` "
"也被精确使用一次。因此，只要一扇门 ``d`` 在创建时具有多重性 ``1`` ，我们就 "
"*知道* ，一旦我们对它调用 ``openDoor`` ，我们将不能再使用 ``d`` 。鉴于 ``d`` "
"是一个外部资源，而 ``openDoor`` 已经改变了它的状态，这是一件好事！"

#: ../../source/tutorial/multiplicities.rst:247
#: b002c434e46d4d52a519d22c784631a2
msgid ""
"We can ensure that any door we create has multiplicity ``1`` by creating "
"them with a ``newDoor`` function with the following type"
msgstr "我们可以通过使用以下类型的 ``newDoor`` "
"函数来确保我们创建的任何门都具有多重性 ``1``"

#: ../../source/tutorial/multiplicities.rst:254
#: 120b7c78b2e547919fe4d1cce6b343f0
msgid ""
"That is, ``newDoor`` takes a function, which it runs exactly once. That "
"function takes a door, which is used exactly once. We'll run it in ``IO``"
" to suggest that there is some interaction with the outside world going "
"on when we create the door. Since the multiplicity ``1`` means the door "
"has to be used exactly once, we need to be able to delete the door when "
"we're finished"
msgstr ""
"也就是说， ``newDoor`` "
"需要一个函数，它正好运行一次。这个函数需要一个门，这个门被精确地使用一次。"
"我们将在 ``IO`` 中运行它，以表明当我们创建门时，与外部世界有一些互动。"
"由于多重性 ``1`` 意味着门必须被精确地使用一次，我们需要在完成后能够删除门"

#: ../../source/tutorial/multiplicities.rst:265
#: ff708f3ffcbe4229ba8827caf450c524
msgid "So an example correct door protocol usage would be"
msgstr "因此，一个正确的 门 协议的使用例子是"

#: ../../source/tutorial/multiplicities.rst:276
#: c31ebd9d9bf24aac8ca09b0038851331
msgid ""
"It's instructive to build this program interactively, with holes along "
"the way, and see how the multiplicities of ``d``, ``d'`` etc change. For "
"example"
msgstr "交互性的建立这个程序是很有启发性的，沿途会出现一些漏洞，看看 ``d`` , ``d'`` "
"等变量的多重性如何变化。比如说"

#: ../../source/tutorial/multiplicities.rst:288
#: bcdff38c3bba428aacdc3f98e369a571
msgid ""
"Checking the type of ``?whatnow`` shows that ``d`` is now spent, but we "
"still have to use ``d'`` exactly once::"
msgstr "检查 ``?whatnow`` 的类型，发现 ``d`` 现在已经用完了，但我们还必须要使用 "
"``d'`` 正好一次："

#: ../../source/tutorial/multiplicities.rst:297
#: d65b99d853254fdfa3dff8d2ec3d8487
msgid ""
"Note that the ``0`` multiplicity for ``d`` means that we can still *talk*"
" about it - in particular, we can still reason about it in types - but we"
" can't use it again in a relevant position in the rest of the program. "
"It's also fine to shadow the name ``d`` throughout"
msgstr ""
"请注意， ``d`` 的多重性 ``0`` 意味着我们仍然可以 *谈论它* - 特别是，"
"我们仍然可以在类型中推理它 - 但我们不能在程序的其余部分的相关位置再次使用它。"
"在整个程序中影射 ``d`` 这个名字也是可以的"

#: ../../source/tutorial/multiplicities.rst:311
#: 95a8d69a4dce4aaeb948371060390080
msgid ""
"If we don't follow the protocol correctly - create the door, open it, "
"close it, then delete it - then the program won't type check. For "
"example, we can try not to delete the door before finishing"
msgstr "如果我们没有正确遵循协议——创建门，打开它，关闭它，然后删除它—— "
"那么程序就不能通过类型检查。例如，我们可以尝试在完成之前不删除门"

#: ../../source/tutorial/multiplicities.rst:324
#: f1093089e9eb4299966c04241bad2be5
msgid "This gives the following error::"
msgstr "这给出了以下错误："

#: ../../source/tutorial/multiplicities.rst:329
#: 8f31c124a3fd4e60bcd417abcf79911a
msgid ""
"There's a lot more to be said about the details here! But, this shows at "
"a high level how we can use linearity to capture resource usage protocols"
" at the type level. If we have an external resource which is guaranteed "
"to be used linearly, like ``Door``, we don't need to run operations on "
"that resource in an ``IO`` monad, since we're already enforcing an "
"ordering on operations and don't have access to any out of date resource "
"states. This is similar to the way interactive programs work in `the "
"Clean programming language <https://clean.cs.ru.nl/Clean>`_, and in fact "
"is how ``IO`` is implemented internally in Idris 2, with a special "
"``%World`` type for representing the state of the outside world that is "
"always used linearly"
msgstr ""
"关于这里的细节还有很多要讲的!但是，这在很大程度上显示了我们如何在类型层面上使"
"用线性来捕获资源使用协议。如果我们有一个需要保证线性使用的外部资源，比如 "
"``Door`` ，我们就不需要在 ``IO`` 单子中对该资源进行操作，因为我们已经对操作进"
"行了排序，并且没有访问任何过时的资源状态。这类似于交互式程序在 `"
"Clean编程语言 <https://clean.cs.ru.nl/Clean>`_ 中的工作方式，事实上这也是 "
"``IO`` 在Idris 2中的内部实现方式，用一个特殊的 ``%World`` "
"类型来表示外部世界的状态，它总是被线性地使用"

#: ../../source/tutorial/multiplicities.rst:351
#: 7d960812eb6f47089256e8dbadea0230
msgid ""
"Having multiplicities in the type system raises several interesting "
"questions, such as:"
msgstr "在类型系统中拥有多重性，会引起一些有趣的问题，例如："

#: ../../source/tutorial/multiplicities.rst:354
#: 9ee0fabff47943389361e1933e89f3e5
msgid ""
"Can we use linearity information to inform memory management and, for "
"example, have type level guarantees about functions which will not need "
"to perform garbage collection?"
msgstr "我们是否可以使用线性信息来告知内存管理，例如，对不需要进行垃圾回收的函数进行"
"类型级别的保证？"

#: ../../source/tutorial/multiplicities.rst:357
#: 1f23539793ff4d63871340058bdbb989
msgid ""
"How should multiplicities be incorporated into interfaces such as "
"``Functor``, ``Applicative`` and ``Monad``?"
msgstr "应如何将多重性纳入 ``Functor``, ``Applicative`` 和 ``Monad`` 等接口？"

#: ../../source/tutorial/multiplicities.rst:359
#: 884d41ae924845beaf022b69e1acea24
msgid ""
"If we have ``0``, and ``1`` as multiplicities, why stop there? Why not "
"have ``2``, ``3`` and more (like `Granule <https://granule-"
"project.github.io/granule.html>`_)"
msgstr ""
"如果我们有 ``0`` ，和 ``1`` 作为多重性，为什么要止步于此？为什么没有 ``2`` ，"
" ``3`` 或者更多（例如 `Granule <https://granule-project.github.io/granule."
"html>`_ ）"

#: ../../source/tutorial/multiplicities.rst:362
#: fef5f20047e343249badc63b2ee4e828
msgid ""
"What about multiplicity polymorphism, as in the `Linear Haskell proposal "
"<https://arxiv.org/abs/1710.09756>`_?"
msgstr ""
"多重性多态怎么样，就像 `Linear Haskell 提案 <https://arxiv.org/abs/1710."
"09756>`_ 中那样？"

#: ../../source/tutorial/multiplicities.rst:363
#: 7a85e4d317f149c7a41ac72b58d70c32
msgid "Even without all of that, what can we do *now*?"
msgstr "即使没有这些， *现在* 我们能做什么？"

#: ../../source/tutorial/multiplicities.rst:368
#: b81d0c0cf9c74864a7aa507dbfe8f337
msgid "Erasure"
msgstr "擦除"

#: ../../source/tutorial/multiplicities.rst:370
#: f486e354874c4d19a612f92e7b212f1b
msgid ""
"The ``1`` multiplicity give us many possibilities in the kinds of "
"properties we can express. But, the ``0`` multiplicity is perhaps more "
"important in that it allows us to be precise about which values are "
"relevant at run time, and which are compile time only (that is, which are"
" erased). Using the ``0`` multiplicity means a function's type now tells "
"us exactly what it needs at run time."
msgstr ""
"``1`` 多重性在我们可以表达的属性种类方面给了我们很多可能性。但是， ``0`` 多重"
"性也许更重要，因为它允许我们精确地知道哪些值在运行时是相关的，哪些是编译时才"
"有的（也就是说，哪些是被删除的）。使用 ``0`` "
"多重性意味着一个函数的类型现在可以准确地告诉我们它在运行时需要什么。"

#: ../../source/tutorial/multiplicities.rst:377
#: 008b54ae120842b8be80d3ae5aa8f0d1
msgid "For example, in Idris 1 you could get the length of a vector as follows"
msgstr "例如，在 Idris 1 中你可以得到一个向量的长度，如下所示"

#: ../../source/tutorial/multiplicities.rst:384
#: 6b70e89c67214d739870bfc3246d87f2
msgid ""
"This is fine, since it runs in constant time, but the trade off is that "
"``n`` has to be available at run time, so at run time we always need the "
"length of the vector to be available if we ever call ``vlen``. Idris 1 "
"can infer whether the length is needed, but there's no easy way for a "
"programmer to be sure."
msgstr ""
"这很好，因为它在恒定时间内运行，但代价是 ``n`` "
"在运行时必须可用，所以在运行时我们总是需要向量的长度，如果我们曾经调用 "
"``vlen`` 。Idris 1 可以推断出是否需要长度，但是程序员没有简单的方法来确定。"

#: ../../source/tutorial/multiplicities.rst:389
#: 1a05463be1724a6db618fa6bc0f53ecb
msgid "In Idris 2, we need to state explicitly that ``n`` is needed at run time"
msgstr "在 Idris 2 中，我们需要明确指出，在运行时需要 ``n``"

#: ../../source/tutorial/multiplicities.rst:396
#: cd12e29ffca74781994bc8c92739eb91
msgid ""
"(Incidentally, also note that in Idris 2, names bound in types are also "
"available in the definition without explicitly rebinding them.)"
msgstr "(顺便说一下，还要注意在 Idris 2 "
"中，在类型中绑定的名字也可以在定义中使用，而不需要明确地重新绑定它们)"

#: ../../source/tutorial/multiplicities.rst:399
#: ac1a2598ac1442db81c71eda4d4c73df
msgid ""
"This also means that when you call ``vlen``, you need the length "
"available. For example, this will give an error"
msgstr "这也意味着，当你调用 ``vlen`` 时，你需要可用的长度。例如，这将产生一个错误"

#: ../../source/tutorial/multiplicities.rst:407
#: 9c31721b22fd496eb0eafa58710dcae1
msgid "Idris 2 reports::"
msgstr "Idris 2 会报告："

#: ../../source/tutorial/multiplicities.rst:412
#: b35fa09b5e4c43369c9f6258c684f095
msgid ""
"This means that it needs to use ``m`` as an argument to pass to ``vlen "
"xs``, where it needs to be available at run time, but ``m`` is not "
"available in ``sumLengths`` because it has multiplicity ``0``."
msgstr ""
"这意味着它需要使用 ``m`` 作为参数传递给 ``vlen xs`` "
"，在这里它需要在运行时可用，但是 ``m`` 在 ``sumLengths`` 中不可用，"
"因为它有多重性 ``0`` 。"

#: ../../source/tutorial/multiplicities.rst:416
#: edc41bab28fc448780037711975b368f
msgid ""
"We can see this more clearly by replacing the right hand side of "
"``sumLengths`` with a hole..."
msgstr "我们可以通过将 ``sumLengths`` 的右侧替换成一个孔来更清楚地看到这一点......"

#: ../../source/tutorial/multiplicities.rst:424
#: 56e6294c43ec4c2998c76674697bad5e
msgid "...then checking the hole's type at the REPL::"
msgstr "...然后在REPL检查孔的类型："

#: ../../source/tutorial/multiplicities.rst:435
#: 7616051aed5b40579e3e154cc34e5ddc
msgid ""
"Instead, we need to give bindings for ``m`` and ``n`` with unrestricted "
"multiplicity"
msgstr "相反，我们需要为 ``m`` 和 ``n`` 提供无限制多重性的绑定"

#: ../../source/tutorial/multiplicities.rst:443
#: c283b6f8173e457aa77d0063bcb48227
msgid ""
"Remember that giving no multiplicity on a binder, as with ``m`` and ``n``"
" here, means that the variable has unrestricted usage."
msgstr "请记住，在绑定器上不给出多重性，就像这里的 ``m`` 和 ``n`` "
"一样，意味着变量的使用不受限制。"

#: ../../source/tutorial/multiplicities.rst:446
#: b665d0fc243d46b9bb090aefcdf80f7e
msgid ""
"If you're converting Idris 1 programs to work with Idris 2, this is "
"probably the biggest thing you need to think about. It is important to "
"note, though, that if you have bound implicits, such as..."
msgstr ""
"如果你要将 Idris 1 程序转换到 Idris 2 中使用，这可能是你需要考虑的最大问题。"
"但需要注意的是，如果你有绑定的隐式参数，例如..."

#: ../../source/tutorial/multiplicities.rst:454
#: b555e3d861274531b65af53d80e8f8d7
msgid ""
"...then it's a good idea to make sure ``t`` really is needed, or "
"performance might suffer due to the run time building the instance of "
"``t`` unnecessarily!"
msgstr "...那么最好确保 ``t`` 真的被需要，否则由于运行时间不必要地建立 ``t`` "
"的实例，性能可能会受到影响！"

#: ../../source/tutorial/multiplicities.rst:457
#: 14edfe0c835d4219b1fba344ea37741a
msgid ""
"One final note on erasure: it is an error to try to pattern match on an "
"argument with multiplicity ``0``, unless its value is inferrable from "
"elsewhere. So, the following definition is rejected"
msgstr ""
"关于擦除的最后一点说明：试图对一个具有多重性 ``0`` 的参数进行模式匹配是一个错"
"误，，除非其值可以从其他地方推断出来。因此，下面的定义会被拒绝"

#: ../../source/tutorial/multiplicities.rst:467
#: 8d394af3fd324cafb44e95e78e908eba
msgid "This is rejected with the error::"
msgstr "这被拒绝了，错误是："

#: ../../source/tutorial/multiplicities.rst:472
#: b1aa110a3ef049efab999e78fbdc1074
msgid ""
"The following, however, is fine, because in ``sNot``, even though we "
"appear to match on the erased argument ``x``, its value is uniquely "
"inferrable from the type of the second argument"
msgstr ""
"然而，下面的情况是好的，因为在 ``sNot`` 中，尽管我们似乎在被删除的参数 ``x`` "
"上进行了匹配，但它的值是可以从第二个参数的类型中唯一推断出来的"

#: ../../source/tutorial/multiplicities.rst:486
#: c025dabff7284ec3986057d856faf37d
msgid ""
"Experience with Idris 2 so far suggests that, most of the time, as long "
"as you're using unbound implicits in your Idris 1 programs, they will "
"work without much modification in Idris 2. The Idris 2 type checker will "
"point out where you require an unbound implicit argument at run time - "
"sometimes this is both surprising and enlightening!"
msgstr ""
"到目前为止，Idris 2 的经验表明，在大多数情况下，只要你在 Idris 1 "
"程序中使用非绑定隐式参数，它们在 Idris 2 中无需过多修改即可工作。 Idris 2 "
"类型检查器将指出你在运行时需要非绑定隐式参数的地方--"
"有时这既令人惊讶又具有启发性！"

#: ../../source/tutorial/multiplicities.rst:495
#: bb25b757f663479fbbb9c8fbc7435079
msgid "Pattern Matching on Types"
msgstr "类型的模式匹配"

#: ../../source/tutorial/multiplicities.rst:497
#: 4434fa6c8fac4468a55643a8cf99aa2c
msgid ""
"One way to think about dependent types is to think of them as \"first "
"class\" objects in the language, in that they can be assigned to "
"variables, passed around and returned from functions, just like any other"
" construct. But, if they're truly first class, we should be able to "
"pattern match on them too! Idris 2 allows us to do this. For example"
msgstr ""
"思考依赖类型的一种方式是将它们视为语言中的 \"一等 \" 对象，因为它们可以像其他"
"结构体一样被分配给变量、传递和从函数中返回。但是，如果它们是真正的一等对象，"
"我们也应该能够对它们进行模式匹配。Idris 2 允许我们这样做。例如"

#: ../../source/tutorial/multiplicities.rst:510
#: 21f70368b8a241f2b4c053b698413760
msgid "We can try this as follows::"
msgstr "我们可以进行以下尝试："

#: ../../source/tutorial/multiplicities.rst:519
#: 576beffcac98491da8c0bd7dcffc7dea
msgid ""
"Pattern matching on function types is interesting, because the return "
"type may depend on the input value. For example, let's add a case to "
"``showType``"
msgstr "对函数类型进行模式匹配很有意思，因为返回类型可能取决于输入值。例如，让我们为 "
"``showType`` 添加一个案例"

#: ../../source/tutorial/multiplicities.rst:527
#: 333b43713cfc4f30a9f4dbb37662aa6a
msgid "Inspecting the type of ``help`` tells us::"
msgstr "检查 ``help`` 的类型将告诉我们："

#: ../../source/tutorial/multiplicities.rst:534
#: 5ce808b8dcba4e99aba0fe9558511c4b
msgid ""
"So, the return type ``a`` depends on the input value of type ``Nat``, and"
" we'll need to come up with a value to use ``a``, for example"
msgstr "所以，返回类型 ``a`` 取决于类型 ``Nat`` 的输入值，我们需要想出一个值来使用 "
"``a`` ，比如说"

#: ../../source/tutorial/multiplicities.rst:541
#: 77426465138348fdb389342b3a7c0781
msgid ""
"Note that multiplicities on the binders, and the ability to pattern match"
" on *non-erased* types mean that the following two types are distinct"
msgstr "请注意，绑定器上的多重性，以及在 *非擦除式* "
"类型上的模式匹配能力，意味着以下两种类型是不同的"

#: ../../source/tutorial/multiplicities.rst:549
#: 6d74a832076f423fb326d868f2c0d552
msgid ""
"In the case of ``notId``, we can match on ``a`` and get a function which "
"is certainly not the identity function"
msgstr "在 ``notId`` 的情况下，我们可以在 ``a`` "
"上进行匹配，得到的函数肯定不是同一函数"

#: ../../source/tutorial/multiplicities.rst:564
#: b011381f38f1423cb99fa7cfa097f455
msgid ""
"There is an important consequence of being able to distinguish between "
"relevant and irrelevant type arguments, which is that a function is "
"*only* parametric in ``a`` if ``a`` has multiplicity ``0``. So, in the "
"case of ``notId``, ``a`` is *not* a parameter, and so we can't draw any "
"conclusions about the way the function will behave because it is "
"polymorphic, because the type tells us it might pattern match on ``a``."
msgstr ""
"能够区分相关和不相关的类型参数有一个重要的结果，在一个函数中，如果 ``a`` "
"有多重性 ``0`` ，那么 *只有* ``a`` 是参数化的。所以，在 ``notId`` 的情况下， "
"``a`` *不是* "
"参数，所以我们不能因为它是多态的而对该函数的行为方式得出任何结论，"
"因为类型告诉我们它可能对 ``a`` 进行模式匹配。"

#: ../../source/tutorial/multiplicities.rst:571
#: 1a092d737b4c401d8afe080ae56d5bfa
msgid ""
"On the other hand, it is merely a coincidence that, in non-dependently "
"typed languages, types are *irrelevant* and get erased, and values are "
"*relevant* and remain at run time. Idris 2, being based on QTT, allows us"
" to make the distinction between relevant and irrelevant arguments "
"precise. Types can be relevant, values (such as the ``n`` index to "
"vectors) can be irrelevant."
msgstr ""
"另一方面，这只是一个巧合，在非依赖类型的语言中，类型是 *不相关的* "
"并会被抹去，而值是 *相关的* 且会在运行时保留。Idris 2 是基于 QTT "
"的，允许我们精确区分相关和不相关的参数。类型可以是相关的，值（如 ``n`` "
"向量的索引）可以是不相关的。"

#: ../../source/tutorial/multiplicities.rst:577
#: 68316e95b5584d6997cf43184a55871b
msgid ""
"For more details on multiplicities, see `Idris 2: Quantitative Type "
"Theory in Action <https://www.type-driven.org.uk/edwinb/idris-2"
"-quantitative-type-theory-in-action.html>`_."
msgstr ""
"关于多重性的更多细节，见`Idris 2: Quantitative Type Theory in Action "
"<https://www.type-driven.org.uk/edwinb/idris-2-quantitative-type-theory-in-"
"action.html>`_ 。"
