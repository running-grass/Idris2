# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 11:10+0800\n"
"PO-Revision-Date: 2022-07-24 15:14+0000\n"
"Last-Translator: admin <467195537@qq.com>\n"
"Language-Team: Chinese (Simplified) <https://weblate.grass.work:30443/"
"projects/idris2/tutorialmiscellany/zh_Hans/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.13.1\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/tutorial/miscellany.rst:5 97410e26a99b4ca6a0c84f8f871b6208
msgid "Miscellany"
msgstr "杂项"

#: ../../source/tutorial/miscellany.rst:7 73c9d82b04324fd28117f2dd95168f32
msgid "In this section we discuss a variety of additional features:"
msgstr "在本节中，我们将讨论各种附加功能："

#: ../../source/tutorial/miscellany.rst:9 687653550b4041c68ce67a7a68063603
msgid "auto, implicit, and default arguments;"
msgstr "自动、隐式和默认参数；"

#: ../../source/tutorial/miscellany.rst:10 b776e8b082074bd19e8a582168c82b1d
msgid "literate programming; and"
msgstr "文学编程；和"

#: ../../source/tutorial/miscellany.rst:11 e2e9cb35e51741a5ac3a4a3fad2cb8c6
msgid "the universe hierarchy."
msgstr "全域层级。"

#: ../../source/tutorial/miscellany.rst:14 2221c06a0d3e4fdf8aeb0f062d2049eb
msgid "Implicit arguments"
msgstr "隐式参数"

#: ../../source/tutorial/miscellany.rst:16 b65e31c8d446451ba7c87cf4f6ac0623
msgid ""
"We have already seen implicit arguments, which allows arguments to be "
"omitted when they can be inferred by the type checker [#IdrisType]_, e.g."
msgstr "我们已经看到了隐式参数，它允许在类型检查器 [#IdrisType]_ "
"在可以推断出参数时省略参数，例如。"

#: ../../source/tutorial/miscellany.rst:24 006ead52bd1c4c45a334c4179d455a55
msgid "Auto implicit arguments"
msgstr "自动隐式参数"

#: ../../source/tutorial/miscellany.rst:26 0721e78cf012492ba1d2592604dded20
msgid ""
"In other situations, it may be possible to infer arguments not by type "
"checking but by searching the context for an appropriate value, or "
"constructing a proof. For example, the following definition of ``head`` "
"which requires a proof that the list is non-empty:"
msgstr ""
"在其他情况下，可能不是通过类型检查而是通过在上下文中搜索适当的值或构造证明来"
"推断参数。例如，下面 ``head`` 的定义需要证明列表是非空的："

#: ../../source/tutorial/miscellany.rst:40 c08e27b201a3498eb95a950a352b28cb
msgid ""
"If the list is statically known to be non-empty, either because its value"
" is known or because a proof already exists in the context, the proof can"
" be constructed automatically. Auto implicit arguments allow this to "
"happen silently. We define ``head`` as follows:"
msgstr ""
"如果列表静态已知为非空，或者因为它的值是已知的，或者因为上下文中已经存在证明"
"，则可以自动构造证明。自动隐式参数允许这种情况静默发生。我们定义 ``head`` "
"如下："

#: ../../source/tutorial/miscellany.rst:50 299a8237bee84aeca44dd7ef13231e0a
msgid ""
"The ``auto`` annotation on the implicit argument means that Idris will "
"attempt to fill in the implicit argument by searching for a value of the "
"appropriate type. In fact, internally, this is exactly how interface "
"resolution works. It will try the following, in order:"
msgstr ""
"隐式参数上的 ``auto`` 注解意味着 Idris 将尝试通过搜索适当类型的值来填充隐式参"
"数。事实上，在内部，这正是接口解析的工作方式。它将按顺序尝试以下操作："

#: ../../source/tutorial/miscellany.rst:55 e98d9e71a80b44edb71bdd8579b20929
msgid ""
"Local variables, i.e. names bound in pattern matches or ``let`` bindings,"
" with exactly the right type."
msgstr "局部变量，即模式匹配或 ``let`` 绑定中的名称，具有完全正确的类型。"

#: ../../source/tutorial/miscellany.rst:57 eb2d55035f4d4dcbb72b0d4992c3ede0
msgid ""
"The constructors of the required type. If they have arguments, it will "
"search recursively up to a maximum depth of 100."
msgstr "所需类型的构造函数。如果它们有参数，它将递归搜索的最大深度为 100。"

#: ../../source/tutorial/miscellany.rst:59 82cbec32ae5a4d56bc0adcc5954fdf63
msgid ""
"Local variables with function types, searching recursively for the "
"arguments."
msgstr "具有函数类型的局部变量，递归搜索参数。"

#: ../../source/tutorial/miscellany.rst:61 1ddfdb4178bb453fbaf7589935f9da9b
#, python-format
msgid ""
"Any function with the appropriate return type which is marked with the "
"``%hint`` annotation."
msgstr "任何具有适当返回类型且标有 ``%hint`` 注解的函数。"

#: ../../source/tutorial/miscellany.rst:64 cf47d5de211a4a7fbd7187209f07a583
msgid ""
"In the case that a proof is not found, it can be provided explicitly as "
"normal:"
msgstr "在没有找到证明的情况下，可以像往常一样明确提供："

#: ../../source/tutorial/miscellany.rst:71 ed226effa3f54a889a5a45c4b370b361
msgid "Default implicit arguments"
msgstr "默认隐式参数"

#: ../../source/tutorial/miscellany.rst:73 b0a0d793015844248755819e4724ceed
msgid ""
"Besides having Idris automatically find a value of a given type, "
"sometimes we want to have an implicit argument with a specific default "
"value. In Idris, we can do this using the ``default`` annotation. While "
"this is primarily intended to assist in automatically constructing a "
"proof where auto fails, or finds an unhelpful value, it might be easier "
"to first consider a simpler case, not involving proofs."
msgstr ""
"除了让 Idris "
"自动查找给定类型的值之外，有时我们还希望有一个具有特定默认值的隐式参数。在 "
"Idris 中，我们可以使用 ``default`` 注解来做到这一点。"
"虽然这主要是为了帮助自动构建 auto "
"失败或发现无用值的证明，但首先考虑不涉及证明的更简单的情况可能更容易。"

#: ../../source/tutorial/miscellany.rst:79 ebc6603e4d0e498984830a551099e539
msgid ""
"If we want to compute the n'th fibonacci number (and defining the 0th "
"fibonacci number as 0), we could write:"
msgstr "如果我们想计算第 n 个斐波那契数（并将第 0 个斐波那契数定义为 "
"0），我们可以这样写："

#: ../../source/tutorial/miscellany.rst:88 58ea9b8039624652b83c1d7b3483b535
msgid ""
"After this definition, ``fibonacci 5`` is equivalent to ``fibonacci "
"{lag=0} {lead=1} 5``, and will return the 5th fibonacci number. Note that"
" while this works, this is not the intended use of the ``default`` "
"annotation. It is included here for illustrative purposes only. Usually, "
"``default`` is used to provide things like a custom proof search script."
msgstr ""
"在这个定义之后， ``fibonacci 5`` 等价于 ``fibonacci {lag=0} {lead=1} 5`` ，"
"并且会返回第 5 个斐波那契数。请注意，虽然这有效，但这不是 ``default`` "
"注解的预期用途。此处仅用于说明目的。通常， ``default`` "
"用于提供自定义证明搜索脚本之类的东西。"

#: ../../source/tutorial/miscellany.rst:94 fc403c0ea5764f32bfc261e0323967f1
msgid "Literate programming"
msgstr "文学编程"

#: ../../source/tutorial/miscellany.rst:96 cb9199419e8e48b2a06c684834dbdc8b
msgid ""
"Like Haskell, Idris supports *literate* programming. If a file has an "
"extension of ``.lidr`` then it is assumed to be a literate file. In "
"literate programs, everything is assumed to be a comment unless the line "
"begins with a greater than sign ``>``, for example:"
msgstr ""
"与 Haskell 一样，Idris 支持 *文学* 编程。如果一个文件的扩展名为 .lidr ，"
"那么它被认为是一个 文学(literate) "
"文件。在文学编程中，所有内容都被假定为注释，除非该行以大于号 ``>`` "
"开头，例如："

#: ../../source/tutorial/miscellany.rst:110 184d662a8fb5441fac8fc28a9623c869
msgid ""
"An additional restriction is that there must be a blank line between a "
"program line (beginning with ``>``) and a comment line (beginning with "
"any other character)."
msgstr "另一个限制是程序行（以 ``>`` "
"开头）和注释行（以任何其他字符开头）之间必须有一个空行。"

#: ../../source/tutorial/miscellany.rst:115 2e803ed5811944c5a6fb3f7086a3aa9c
msgid "Cumulativity"
msgstr "累积性"

#: ../../source/tutorial/miscellany.rst:119 589699e2301242dea74c5b58923d2073
msgid "NOT YET IN IDRIS 2"
msgstr "尚未在 IDRIS 2 中"

#: ../../source/tutorial/miscellany.rst:121 cf2ca7f7b13b4c0f94761180bdd7d113
msgid ""
"Since values can appear in types and *vice versa*, it is natural that "
"types themselves have types. For example:"
msgstr "由于值可以出现在类型中，然后 *反之亦然* "
"，因此类型本身具有类型是很自然的。例如："

#: ../../source/tutorial/miscellany.rst:131 2d4b328798dc42978c3c8138838c9948
msgid "But what about the type of ``Type``? If we ask Idris it reports:"
msgstr "但是 ``Type`` 的类型呢？如果我们问 Idris ，它会报告："

#: ../../source/tutorial/miscellany.rst:138 257da2032c5c4f9688e16b418050cf77
msgid ""
"If ``Type`` were its own type, it would lead to an inconsistency due to "
"`Girard’s paradox "
"<https://www.cs.cmu.edu/afs/cs.cmu.edu/user/kw/www/scans/girard72thesis.pdf>`_,"
" so internally there is a *hierarchy* of types (or *universes*):"
msgstr ""
"如果 ``Type`` 是它自己的类型，那么它会因为 `Girard 悖论 <https://www.cs.cmu."
"edu/afs/cs.cmu.edu/user/kw/www/scans/girard72thesis.pdf>`_ 而导致不一致性，"
"所以内部有一个 *层级* 类型（或 *全域* ）："

#: ../../source/tutorial/miscellany.rst:146 f2ba29778a874cef887d56660044449a
msgid ""
"Universes are *cumulative*, that is, if ``x : Type n`` we can also have "
"that ``x : Type m``, as long as ``n < m``. The typechecker generates such"
" universe constraints and reports an error if any inconsistencies are "
"found. Ordinarily, a programmer does not need to worry about this, but it"
" does prevent (contrived) programs such as the following:"
msgstr ""
"全域是 *累积的* ，也就是说，如果 ``x : Type n`` 我们也可以拥有 ``x : Type m``"
" ，只要 ``n < m`` 。如果发现任何不一致，类型检查器会生成这样的全域约束并报告"
"错误。通常，程序员不需要担心这一点，但它确实会防止（构造出）以下程序："

#: ../../source/tutorial/miscellany.rst:160 97989bb34b414f28892fb7dfa332ddcc
msgid ""
"The application of ``myid`` to itself leads to a cycle in the universe "
"hierarchy — ``myid``\\ ’s first argument is a ``Type``, which cannot be "
"at a lower level than required if it is applied to itself."
msgstr ""
"``myid`` 对自身的应用会导致 Universe 层次结构中的循环 - ``myid`` "
"的第一个参数是 ``Type`` ，如果应用它，那么其级别不能低于所要求的级别。"

#: ../../source/tutorial/miscellany.rst:164 0b5976f77aa94f21bda33f53f3008439
msgid "https://github.com/david-christiansen/idris-type-providers"
msgstr "https://github.com/david-christiansen/idris-type-providers"
