# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 11:10+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/tutorial/views.rst:5 8d71b0bfe211421e8a982f1f2e08deff
msgid "Views and the “``with``” rule"
msgstr ""

#: ../../source/tutorial/views.rst:9 140ba6d02eed449b88aa69a45d904b73
msgid "NOT UPDATED FOR IDRIS 2 YET"
msgstr ""

#: ../../source/tutorial/views.rst:12 5bf831f7b1eb4ff0b27c4abcf93b3e31
msgid "Dependent pattern matching"
msgstr ""

#: ../../source/tutorial/views.rst:14 bdc5f9e00656461999b53b7d6e97db23
msgid ""
"Since types can depend on values, the form of some arguments can be "
"determined by the value of others. For example, if we were to write down "
"the implicit length arguments to ``(++)``, we’d see that the form of the "
"length argument was determined by whether the vector was empty or not:"
msgstr ""

#: ../../source/tutorial/views.rst:26 8508ecd324ee413b8176eddc5a87cbeb
msgid ""
"If ``n`` was a successor in the ``[]`` case, or zero in the ``::`` case, "
"the definition would not be well typed."
msgstr ""

#: ../../source/tutorial/views.rst:32 bc541418c5434382a71473889e7a6e6d
msgid "The ``with`` rule — matching intermediate values"
msgstr ""

#: ../../source/tutorial/views.rst:34 4612912a42f14f6491d78d64adef664c
msgid ""
"Very often, we need to match on the result of an intermediate "
"computation. Idris provides a construct for this, the ``with`` rule, "
"inspired by views in ``Epigram`` [#McBridgeMcKinna]_, which takes account"
" of the fact that matching on a value in a dependently typed language can"
" affect what we know about the forms of other values. In its simplest "
"form, the ``with`` rule adds another argument to the function being "
"defined."
msgstr ""

#: ../../source/tutorial/views.rst:42 d2d98b0468e64e4fa34039a44244e422
msgid ""
"We have already seen a vector filter function. This time, we define it "
"using ``with`` as follows:"
msgstr ""

#: ../../source/tutorial/views.rst:52 a091569e098c4ecab40ed8e18dc773f7
msgid ""
"Here, the ``with`` clause allows us to deconstruct the result of ``filter"
" p xs``. The view refined argument pattern ``filter p (x :: xs)`` goes "
"beneath the ``with`` clause, followed by a vertical bar ``|``, followed "
"by the deconstructed intermediate result ``( _ ** xs' )``. If the view "
"refined argument pattern is unchanged from the original function argument"
" pattern, then the left side of ``|`` is extraneous and may be omitted "
"with an underscore ``_``:"
msgstr ""

#: ../../source/tutorial/views.rst:65 480da19e15aa4b92b84e5ced7dfeab6f
msgid "``with`` clauses can also be nested:"
msgstr ""

#: ../../source/tutorial/views.rst:76 9b6c2d2f6b2240b9afee1cb75eededb6
msgid ""
"and left hand sides that are the same as their parent's can be skipped by"
" using ``_`` to focus on the patterns for the most local ``with``. "
"Meaning that the above ``foo`` can be rewritten as follows:"
msgstr ""

#: ../../source/tutorial/views.rst:89 37c7442ff6384e9c9deb2e421dbabe94
msgid ""
"If the intermediate computation itself has a dependent type, then the "
"result can affect the forms of other arguments — we can learn the form of"
" one value by testing another. In these cases, view refined argument "
"patterns must be explicit. For example, a ``Nat`` is either even or odd. "
"If it is even it will be the sum of two equal ``Nat``. Otherwise, it is "
"the sum of two equal ``Nat`` plus one:"
msgstr ""

#: ../../source/tutorial/views.rst:102 9240fbeed1ec4facb1b2f062d44af13c
msgid ""
"We say ``Parity`` is a *view* of ``Nat``. It has a *covering function* "
"which tests whether it is even or odd and constructs the predicate "
"accordingly. Note that we're going to need access to ``n`` at run time, "
"so although it's an implicit argument, it has unrestricted multiplicity."
msgstr ""

#: ../../source/tutorial/views.rst:111 8808feb6094045f38dcbfa78d833c05a
msgid ""
"We’ll come back to the definition of ``parity`` shortly. We can use it to"
" write a function which converts a natural number to a list of binary "
"digits (least significant first) as follows, using the ``with`` rule:"
msgstr ""

#: ../../source/tutorial/views.rst:124 9fad21ed748b407198ef5a1b754d1fa2
msgid ""
"The value of ``parity k`` affects the form of ``k``, because the result "
"of ``parity k`` depends on ``k``. So, as well as the patterns for the "
"result of the intermediate computation (``Even`` and ``Odd``) right of "
"the ``|``, we also write how the results affect the other patterns left "
"of the ``|``. That is:"
msgstr ""

#: ../../source/tutorial/views.rst:130 992efffd82e144ce9bc59029eedc32be
msgid ""
"When ``parity k`` evaluates to ``Even``, we can refine the original "
"argument ``k`` to a refined pattern ``(j + j)`` according to ``Parity (n "
"+ n)`` from the ``Even`` constructor definition. So ``(j + j)`` replaces "
"``k`` on the left side of ``|``, and the ``Even`` constructor appears on "
"the right side. The natural number ``j`` in the refined pattern can be "
"used on the right side of the ``=`` sign."
msgstr ""

#: ../../source/tutorial/views.rst:138 c40205b531c54888adc131080c6455a9
msgid ""
"Otherwise, when ``parity k`` evaluates to ``Odd``, the original argument "
"``k`` is refined to ``S (j + j)`` according to ``Parity (S (n + n))`` "
"from the ``Odd`` constructor definition, and ``Odd`` now appears on the "
"right side of ``|``, again with the natural number ``j`` used on the "
"right side of the ``=`` sign."
msgstr ""

#: ../../source/tutorial/views.rst:144 41c8ecd3dc8046d7b2100cfb70d4f43e
msgid ""
"Note that there is a function in the patterns (``+``) and repeated "
"occurrences of ``j`` - this is allowed because another argument has "
"determined the form of these patterns."
msgstr ""

#: ../../source/tutorial/views.rst:149 758e3368d24649e5bcc31d22a2537bdd
msgid "Defining ``parity``"
msgstr ""

#: ../../source/tutorial/views.rst:151 7acf80386ba64cc298895e7b3ee60718
msgid ""
"The definition of ``parity`` is a little tricky, and requires some "
"knowledge of theorem proving (see Section :ref:`sect-theorems`), but for "
"completeness, here it is:"
msgstr ""

#: ../../source/tutorial/views.rst:166 4900f7e3019347b282d55e6d3e5e942d
msgid ""
"For full details on ``rewrite`` in particular, please refer to the "
"theorem proving tutorial, in Section :ref:`proofs-index`."
msgstr ""

#: ../../source/tutorial/views.rst:169 ea0cd852e03f40a8b4cfb5094051eead
msgid ""
"Conor McBride and James McKinna. 2004. The view from the left. J. Funct. "
"Program. 14, 1 (January 2004), 69-111. "
"https://doi.org/10.1017/S0956796803004829"
msgstr ""

