# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 09:10+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/tutorial/views.rst:5 a08a88bf43a9433d91a56458ffdeb1c6
msgid "Views and the “``with``” rule"
msgstr ""

#: ../../source/tutorial/views.rst:9 6ce9cc2cc17f4387865455e1bee749fc
msgid "NOT UPDATED FOR IDRIS 2 YET"
msgstr ""

#: ../../source/tutorial/views.rst:12 c60888086feb4b9c920a6f942998eaa6
msgid "Dependent pattern matching"
msgstr ""

#: ../../source/tutorial/views.rst:14 2d2686e12d2d4ced91fd7c5b1d09ea0e
msgid ""
"Since types can depend on values, the form of some arguments can be "
"determined by the value of others. For example, if we were to write down "
"the implicit length arguments to ``(++)``, we’d see that the form of the "
"length argument was determined by whether the vector was empty or not:"
msgstr ""

#: ../../source/tutorial/views.rst:26 3873b6bd2bcc40abb8ca2aab2e70b103
msgid ""
"If ``n`` was a successor in the ``[]`` case, or zero in the ``::`` case, "
"the definition would not be well typed."
msgstr ""

#: ../../source/tutorial/views.rst:32 450d1aa493cf4d4284080e058b738ad5
msgid "The ``with`` rule — matching intermediate values"
msgstr ""

#: ../../source/tutorial/views.rst:34 f4bb051bcad944838b6dabdff7b45ed3
msgid ""
"Very often, we need to match on the result of an intermediate "
"computation. Idris provides a construct for this, the ``with`` rule, "
"inspired by views in ``Epigram`` [#McBridgeMcKinna]_, which takes account"
" of the fact that matching on a value in a dependently typed language can"
" affect what we know about the forms of other values. In its simplest "
"form, the ``with`` rule adds another argument to the function being "
"defined."
msgstr ""

#: ../../source/tutorial/views.rst:42 b41650142bf745659fe96472ef5e2257
msgid ""
"We have already seen a vector filter function. This time, we define it "
"using ``with`` as follows:"
msgstr ""

#: ../../source/tutorial/views.rst:52 1e8b77af191b41758d98108297de4b6c
msgid ""
"Here, the ``with`` clause allows us to deconstruct the result of ``filter"
" p xs``. The view refined argument pattern ``filter p (x :: xs)`` goes "
"beneath the ``with`` clause, followed by a vertical bar ``|``, followed "
"by the deconstructed intermediate result ``( _ ** xs' )``. If the view "
"refined argument pattern is unchanged from the original function argument"
" pattern, then the left side of ``|`` is extraneous and may be omitted "
"with an underscore ``_``:"
msgstr ""

#: ../../source/tutorial/views.rst:65 1ae5cb44d4fe4bc19476889b2d029c30
msgid "``with`` clauses can also be nested:"
msgstr ""

#: ../../source/tutorial/views.rst:76 26ff13df3c3e435a8d6d7791deb65a11
msgid ""
"and left hand sides that are the same as their parent's can be skipped by"
" using ``_`` to focus on the patterns for the most local ``with``. "
"Meaning that the above ``foo`` can be rewritten as follows:"
msgstr ""

#: ../../source/tutorial/views.rst:89 3a693cc1396d4a66b2ad0029a8c54e20
msgid ""
"If the intermediate computation itself has a dependent type, then the "
"result can affect the forms of other arguments — we can learn the form of"
" one value by testing another. In these cases, view refined argument "
"patterns must be explicit. For example, a ``Nat`` is either even or odd. "
"If it is even it will be the sum of two equal ``Nat``. Otherwise, it is "
"the sum of two equal ``Nat`` plus one:"
msgstr ""

#: ../../source/tutorial/views.rst:102 1131ac8959644d239a5f1546b1f8938f
msgid ""
"We say ``Parity`` is a *view* of ``Nat``. It has a *covering function* "
"which tests whether it is even or odd and constructs the predicate "
"accordingly. Note that we're going to need access to ``n`` at run time, "
"so although it's an implicit argument, it has unrestricted multiplicity."
msgstr ""

#: ../../source/tutorial/views.rst:111 a3aae1743fa045dbb5764c5a2bda8bb5
msgid ""
"We’ll come back to the definition of ``parity`` shortly. We can use it to"
" write a function which converts a natural number to a list of binary "
"digits (least significant first) as follows, using the ``with`` rule:"
msgstr ""

#: ../../source/tutorial/views.rst:124 0e4337506aee4bb3a9ddf17ad19aea08
msgid ""
"The value of ``parity k`` affects the form of ``k``, because the result "
"of ``parity k`` depends on ``k``. So, as well as the patterns for the "
"result of the intermediate computation (``Even`` and ``Odd``) right of "
"the ``|``, we also write how the results affect the other patterns left "
"of the ``|``. That is:"
msgstr ""

#: ../../source/tutorial/views.rst:130 b7b5f840bf3e452699121d52d5532501
msgid ""
"When ``parity k`` evaluates to ``Even``, we can refine the original "
"argument ``k`` to a refined pattern ``(j + j)`` according to ``Parity (n "
"+ n)`` from the ``Even`` constructor definition. So ``(j + j)`` replaces "
"``k`` on the left side of ``|``, and the ``Even`` constructor appears on "
"the right side. The natural number ``j`` in the refined pattern can be "
"used on the right side of the ``=`` sign."
msgstr ""

#: ../../source/tutorial/views.rst:138 fe6e28d554d7442daa314c813bd964fb
msgid ""
"Otherwise, when ``parity k`` evaluates to ``Odd``, the original argument "
"``k`` is refined to ``S (j + j)`` according to ``Parity (S (n + n))`` "
"from the ``Odd`` constructor definition, and ``Odd`` now appears on the "
"right side of ``|``, again with the natural number ``j`` used on the "
"right side of the ``=`` sign."
msgstr ""

#: ../../source/tutorial/views.rst:144 6b6fd7355bbc4510a30c0248e3fc0eea
msgid ""
"Note that there is a function in the patterns (``+``) and repeated "
"occurrences of ``j`` - this is allowed because another argument has "
"determined the form of these patterns."
msgstr ""

#: ../../source/tutorial/views.rst:149 1e2d4a6fb52c466181c190d9031b29ab
msgid "Defining ``parity``"
msgstr ""

#: ../../source/tutorial/views.rst:151 07e38a61ce9f4bf0b61ee0acda087699
msgid ""
"The definition of ``parity`` is a little tricky, and requires some "
"knowledge of theorem proving (see Section :ref:`sect-theorems`), but for "
"completeness, here it is:"
msgstr ""

#: ../../source/tutorial/views.rst:166 4cd65c813f5f4d61becd33dd7ed46d24
msgid ""
"For full details on ``rewrite`` in particular, please refer to the "
"theorem proving tutorial, in Section :ref:`proofs-index`."
msgstr ""

#: ../../source/tutorial/views.rst:169 3cf17cea363b487ca087b44428292dcb
msgid ""
"Conor McBride and James McKinna. 2004. The view from the left. J. Funct. "
"Program. 14, 1 (January 2004), 69-111. "
"https://doi.org/10.1017/S0956796803004829"
msgstr ""

