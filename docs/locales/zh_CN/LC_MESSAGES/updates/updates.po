# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 09:10+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/updates/updates.rst:5 5266ac93e6fe46bfb60863637971b2e0
msgid "Changes since Idris 1"
msgstr ""

#: ../../source/updates/updates.rst:7 919869ae63b945119eb0090ec1299e09
msgid ""
"Idris 2 is mostly backwards compatible with Idris 1, with some minor "
"exceptions. This document describes the changes, approximately in order "
"of likelihood of encountering them in practice. New features are "
"described at the end, in Section :ref:`sect-new-features`."
msgstr ""

#: ../../source/updates/updates.rst:12 1d7728d1e34e49f8b39c62a36bb5a36c
msgid ""
"The Section :ref:`typedd-index` describes how these changes affect the "
"code in the book `Type-Driven Development with Idris "
"<https://www.manning.com/books/type-driven-development-with-idris>`_ by "
"Edwin Brady, available from `Manning <https://www.manning.com>`_."
msgstr ""

#: ../../source/updates/updates.rst:17 120605d470ce4eccbc979a4a9259f015
msgid ""
"The documentation for Idris has been published under the Creative Commons"
" CC0 License. As such to the extent possible under law, *The Idris "
"Community* has waived all copyright and related or neighboring rights to "
"Documentation for Idris."
msgstr ""

#: ../../source/updates/updates.rst:22 59587314184d49cd8480ac1dc1636c46
msgid ""
"More information concerning the CC0 can be found online at: "
"http://creativecommons.org/publicdomain/zero/1.0/"
msgstr ""

#: ../../source/updates/updates.rst:25 9f976e8ca9d644f0afbfebff7c03fc23
msgid "New Core Language: Quantities in Types"
msgstr ""

#: ../../source/updates/updates.rst:27 925be6be9c3e4033b98e9f6a72781685
msgid ""
"Idris 2 is based on `Quantitative Type Theory (QTT) <https://bentnib.org"
"/quantitative-type-theory.html>`_, a core language developed by Bob Atkey"
" and Conor McBride. In practice, this means that every variable in Idris "
"2 has a *quantity* associated with it. A quantity is one of:"
msgstr ""

#: ../../source/updates/updates.rst:32 5ddcd0d0a1794522bb66d57f0feee520
msgid "``0``, meaning that the variable is *erased* at run time"
msgstr ""

#: ../../source/updates/updates.rst:33 3c66b8d067e24286a2e5db1c6672e5d8
msgid "``1``, meaning that the variable is used *exactly once* at run time"
msgstr ""

#: ../../source/updates/updates.rst:34 e17dc7cf72844615a30f8bdbfe9a43c4
msgid "*Unrestricted*, which is the same behaviour as Idris 1"
msgstr ""

#: ../../source/updates/updates.rst:36 2e59494daa35417f9bf6ffd36f0add8f
msgid ""
"For more details on this, see Section :ref:`sect-multiplicities`. In "
"practice, this might cause some Idris 1 programs not to type check in "
"Idris 2 due to attempting to use an argument which is erased at run time."
msgstr ""

#: ../../source/updates/updates.rst:41 df664fa6d6a2437b8c907c0e563784b5
msgid "Erasure"
msgstr ""

#: ../../source/updates/updates.rst:43 34a2bd5299404818bc0dfbd94b0a8e8d
msgid ""
"In Idris, names which begin with a lower case letter are automatically "
"bound as implicit arguments in types, for example in the following "
"skeleton definition, ``n``, ``a`` and ``m`` are implicitly bound:"
msgstr ""

#: ../../source/updates/updates.rst:52 217833b74a2744b6ba7b4384c12a1517
msgid ""
"One of the difficulties in compiling a dependently typed programming "
"language is deciding which arguments are used at run time and which can "
"safely be erased. More importantly, it's one of the difficulties when "
"programming: how can a programmer *know* when an argument will be erased?"
msgstr ""

#: ../../source/updates/updates.rst:57 bccd53e89fe946dba89d87fd8ebc7543
msgid ""
"In Idris 2, a variable's quantity tells us whether it will be available "
"at run time or not. We can see the quantities of the variables in scope "
"in ``append_rhs`` by inspecting the hole at the REPL:"
msgstr ""

#: ../../source/updates/updates.rst:72 d23363d19a46477ab0b8566facb7c1b8
msgid ""
"The ``0`` next to ``m``, ``a`` and ``n`` mean that they are in scope, but"
" there will be ``0`` occurrences at run-time. That is, it is *guaranteed*"
" that they will be erased at run-time."
msgstr ""

#: ../../source/updates/updates.rst:76 5074cbb23dff4147bb484446103fd381
msgid ""
"This does lead to some potential difficulties when converting Idris 1 "
"programs, if you are using implicit arguments at run time.  For example, "
"in Idris 1 you can get the length of a vector as follows:"
msgstr ""

#: ../../source/updates/updates.rst:85 78bc5817be86474ba911563483ed3afb
msgid ""
"This might seem like a good idea, since it runs in constant time and "
"takes advantage of the type level information, but the trade off is that "
"``n`` has to be available at run time, so at run time we always need the "
"length of the vector to be available if we ever call ``vlen``. Idris 1 "
"can infer whether the length is needed, but there's no easy way for a "
"programmer to be sure."
msgstr ""

#: ../../source/updates/updates.rst:91 33a270bd6259466f8492bfcb6cbf1b19
msgid "In Idris 2, we need to state explicitly that ``n`` is needed at run time"
msgstr ""

#: ../../source/updates/updates.rst:98 d138238ffa6f41498d57ae0905217d30
msgid ""
"(Incidentally, also note that in Idris 2, names bound in types are also "
"available in the definition without explicitly rebinding them.)"
msgstr ""

#: ../../source/updates/updates.rst:101 33c6aef59bbb43898a3e813c30aa1790
msgid ""
"This also means that when you call ``vlen``, you need the length "
"available. For example, this will give an error"
msgstr ""

#: ../../source/updates/updates.rst:109 706e3cc9a8ed43e2908a97efe2d5a84b
msgid "Idris 2 reports::"
msgstr ""

#: ../../source/updates/updates.rst:114 79b70828b37d4c2b8f83d4f2260ff533
msgid ""
"This means that it needs to use ``m`` as an argument to pass to ``vlen "
"xs``, where it needs to be available at run time, but ``m`` is not "
"available in ``sumLengths`` because it has multiplicity ``0``."
msgstr ""

#: ../../source/updates/updates.rst:118 e516a05689ba4f26bda0030b48de7ab7
msgid ""
"We can see this more clearly by replacing the right hand side of "
"``sumLengths`` with a hole..."
msgstr ""

#: ../../source/updates/updates.rst:126 870bf3aa23174705bc81598c384ade1a
msgid "...then checking the hole's type at the REPL::"
msgstr ""

#: ../../source/updates/updates.rst:137 2507ca8d8e894a2dbd8a869e830455df
msgid ""
"Instead, we need to give bindings for ``m`` and ``n`` with unrestricted "
"multiplicity"
msgstr ""

#: ../../source/updates/updates.rst:145 27f87187947f40d1bb2e21b410ab25cd
msgid ""
"Remember that giving no multiplicity on a binder, as with ``m`` and ``n``"
" here, means that the variable has unrestricted usage."
msgstr ""

#: ../../source/updates/updates.rst:148 dd84ef0b11bd47a8a4b06e59c530f1f2
msgid ""
"If you're converting Idris 1 programs to work with Idris 2, this is "
"probably the biggest thing you need to think about. It is important to "
"note, though, that if you have bound implicits, such as..."
msgstr ""

#: ../../source/updates/updates.rst:156 c4bdb264f23b476886bd9e5d247af68c
msgid ""
"...then it's a good idea to make sure ``t`` really is needed, or "
"performance might suffer due to the run time building the instance of "
"``t`` unnecessarily!"
msgstr ""

#: ../../source/updates/updates.rst:159 c44fbdc8b7f54426814e60968a83f147
msgid ""
"One final note on erasure: it is an error to try to pattern match on an "
"argument with multiplicity ``0``, unless its value is inferrable from "
"elsewhere. So, the following definition is rejected"
msgstr ""

#: ../../source/updates/updates.rst:169 1915164abff1426f8f71ebc215c336b1
msgid "This is rejected with the error::"
msgstr ""

#: ../../source/updates/updates.rst:174 dab588aefe554c8d85755527851c1ff5
msgid ""
"The following, however, is fine, because in ``sNot``, even though we "
"appear to match on the erased argument ``x``, its value is uniquely "
"inferrable from the type of the second argument"
msgstr ""

#: ../../source/updates/updates.rst:188 003221b226a84c54bea56e0f1efa8298
msgid ""
"Experience with Idris 2 so far suggests that, most of the time, as long "
"as you're using unbound implicits in your Idris 1 programs, they will "
"work without much modification in Idris 2. The Idris 2 type checker will "
"point out where you require an unbound implicit argument at run time - "
"sometimes this is both surprising and enlightening!"
msgstr ""

#: ../../source/updates/updates.rst:196 7d853b0656f74b38b7a42d35c1f61f5a
msgid "Linearity"
msgstr ""

#: ../../source/updates/updates.rst:198 f5d496763c114a2face8dff02737b5b1
msgid ""
"Full details on linear arguments with multiplicity ``1`` are given in "
"Section :ref:`sect-multiplicities`. In brief, the intuition behind "
"multiplicity ``1`` is that if we have a function with a type of the "
"following form..."
msgstr ""

#: ../../source/updates/updates.rst:206 41823802d83e4828b1aa2102bc71178e
msgid ""
"...then the guarantee given by the type system is that *if* ``f x`` *is "
"used exactly once, then* ``x`` *is used exactly once* in the process."
msgstr ""

#: ../../source/updates/updates.rst:210 7494e2207efd46148cade4e0239eb96e
msgid "Prelude and ``base`` libraries"
msgstr ""

#: ../../source/updates/updates.rst:212 1005df576b6f4488a922c0ea6fde1712
msgid ""
"The Prelude in Idris 1 contained a lot of definitions, many of them "
"rarely necessary. The philosophy in Idris 2 is different. The (rather "
"vaguely specified) rule of thumb is that it should contain the basic "
"functions required by almost any non-trivial program."
msgstr ""

#: ../../source/updates/updates.rst:217 9fabd48943eb401abed94935646fdc48
msgid ""
"This is a vague specification since different programmers will consider "
"different things absolutely necessary, but the result is that it "
"contains:"
msgstr ""

#: ../../source/updates/updates.rst:220 2672cd9b5cf94d368129377674285ee9
msgid "Anything the elaborator can desugar to (e.g. tuples, ``()``, ``=``)"
msgstr ""

#: ../../source/updates/updates.rst:221 cbd877b903f648b09b36ffcaa5b595c8
msgid ""
"Basic types ``Bool``, ``Nat``, ``List``, ``Stream``, ``Dec``, ``Maybe``, "
"``Either``"
msgstr ""

#: ../../source/updates/updates.rst:223 1f850c50945e4113a1711c837919eb4e
msgid "The most important utility functions: ``id``, ``the``, composition, etc"
msgstr ""

#: ../../source/updates/updates.rst:224 d0a157fced23451799def690d33376a5
msgid ""
"Interfaces for arithmetic and implementations for the primitives and "
"basic types"
msgstr ""

#: ../../source/updates/updates.rst:226 3fc547df76cd4606a2f03f9334eb83e8
msgid "Basic ``Char`` and ``String`` manipulation"
msgstr ""

#: ../../source/updates/updates.rst:227 1b3ff3aa16ad4f978d88bfb5554af5fc
msgid ""
"``Show``, ``Eq``, ``Ord``, and implementations for all types in the "
"prelude"
msgstr ""

#: ../../source/updates/updates.rst:228 e952fd8ef469482f854f8d0e2484aca8
msgid "Interfaces and functions for basic proof (``cong``, ``Uninhabited``, etc)"
msgstr ""

#: ../../source/updates/updates.rst:229 4406465257084a55af8ce7cdeb3f6d1f
msgid "``Semigroup``, ``Monoid``"
msgstr ""

#: ../../source/updates/updates.rst:230 903c6758969d4dc78ab061e323883524
msgid "``Functor``, ``Applicative``, ``Monad`` and related functions"
msgstr ""

#: ../../source/updates/updates.rst:231 423baeb340da4aeda39c813714a053a9
msgid "``Foldable``, ``Alternative`` and ``Traversable``"
msgstr ""

#: ../../source/updates/updates.rst:232 5b7623cc54b14a89bffad0ed18b2b794
msgid "``Range``, for list range syntax"
msgstr ""

#: ../../source/updates/updates.rst:233 8c4a88738c72460dadf675a6beda50ea
msgid "Console ``IO``"
msgstr ""

#: ../../source/updates/updates.rst:235 f38e7a949bbf4a5387e021d8343b2d65
msgid ""
"Anything which doesn't fit in here has been moved to the ``base`` "
"libraries. Among other places, you can find some of the functions which "
"used to be in the prelude in:"
msgstr ""

#: ../../source/updates/updates.rst:239 b0c53ca998d14ee79c2c777d6e5b4f9d
msgid "``Data.List`` and ``Data.Nat``"
msgstr ""

#: ../../source/updates/updates.rst:240 8307e32539334196b771f51bf6c603c3
msgid "``Data.Maybe`` and ``Data.Either``"
msgstr ""

#: ../../source/updates/updates.rst:241 6efa8690631240b38a314f6b99bb475c
msgid ""
"``System.File`` and ``System.Directory``, (file management was previously"
" part of the prelude)"
msgstr ""

#: ../../source/updates/updates.rst:243 f9d1fe6774b4456cafacdc3fcd4aa765
msgid "``Decidable.Equality``"
msgstr ""

#: ../../source/updates/updates.rst:246 f3e31ad158234b2da080eb2e9c8edc95
msgid "Smaller Changes"
msgstr ""

#: ../../source/updates/updates.rst:249 2082c659f4ec4960a54fe846580b0008
msgid "Ambiguous Name Resolution"
msgstr ""

#: ../../source/updates/updates.rst:251 21c7162b656a45dbaf26c131e82e54a6
msgid ""
"Idris 1 worked very hard to resolve ambiguous names, by type, even if "
"this involved some complicated interaction with interface resolution. "
"This could sometimes be the cause of long type checking times. Idris 2 "
"simplifies this, at the cost of sometimes requiring more programmer "
"annotations on ambiguous names."
msgstr ""

#: ../../source/updates/updates.rst:257 e30df0eea16946ad8d6fe9f131981a94
msgid ""
"As a general rule, Idris 2 will be able to disambiguate between names "
"which have different concrete return types (such as data constructors), "
"or which have different concrete argument types (such as record "
"projections). It may struggle to resolve ambiguities if one name requires"
" an interface to be resolved. It will postpone resolution if a name can't"
" be resolved immediately, but unlike Idris 1, it won't attempt "
"significant backtracking. If you have deeply nested ambiguous names "
"(beyond a small threshold, default 3) Idris 2 will report an error.  You "
"can change this threshold with a directive, for example:"
msgstr ""

#: ../../source/updates/updates.rst:270 bdaab4aba94843859a248d210057c547
msgid ""
"However, in such circumstances it is almost certainly a better idea to "
"disambiguate explicitly."
msgstr ""

#: ../../source/updates/updates.rst:273 fa2f927e19444dabb3e63146537f175f
msgid ""
"Indeed in general, if you get an ambiguous name error, the best approach "
"is to give the namespace explicitly. You can also rebind names locally:"
msgstr ""

#: ../../source/updates/updates.rst:281 c6ff9bb4f6044306899cd828a7b26e2c
msgid ""
"One difficulty which remains is resolving ambiguous names where one "
"possibility is an interface method, and another is a concrete top level "
"function. For example, we may have:"
msgstr ""

#: ../../source/updates/updates.rst:290 506c40a498944454a9af7081ef9a8ddb
msgid ""
"As a pragmatic choice, if type checking in a context where the more "
"concrete name is valid (``LinearIO.(>>=)`` here, so if type checking an "
"expression known to have type ``IO t`` for some ``t``), the more concrete"
" name will be chosen."
msgstr ""

#: ../../source/updates/updates.rst:294 1d8f2570f11b469eab8a4b1d29e5a436
msgid "This is somehow unsatisfying, so we may revisit this in future!"
msgstr ""

#: ../../source/updates/updates.rst:297 2574556d9360445abb0dbb64a1f50baf
msgid "Modules, namespaces and export"
msgstr ""

#: ../../source/updates/updates.rst:299 aff19b40ac444a91b6a10422cd5a6baf
msgid ""
"The visibility rules, as controlled by the ``private``, ``export`` and "
"``public export`` modifiers, now refer to the visibility of names from "
"other *namespaces*, rather than other *files*."
msgstr ""

#: ../../source/updates/updates.rst:303 dcb7b63a05994b93aa7a23ed938c7754
msgid "So if you have the following, all in the same file..."
msgstr ""

#: ../../source/updates/updates.rst:321 2e0ed593e32a4cd8a2ee78b6ad0d0463
msgid "...then ``bVisible`` can access ``aVisible``, but not ``aHidden``."
msgstr ""

#: ../../source/updates/updates.rst:323 782c362b3e174b799a63d3107af56500
msgid ""
"Records are, as before, defined in their own namespace, but fields are "
"always visible from the parent namespace."
msgstr ""

#: ../../source/updates/updates.rst:326 a72b0b537dfb41568933f0d8e77c1859
msgid ""
"Also, module names must now match the filename in which they're defined, "
"with the exception of the module ``Main``, which can be defined in a file"
" with any name."
msgstr ""

#: ../../source/updates/updates.rst:331 a4770cde5f094af98ef48f83aa160a6a
msgid "``%language`` pragmas"
msgstr ""

#: ../../source/updates/updates.rst:333 fea275f366f447ec9dc67befc9d3b765
msgid ""
"There are several ``%language`` pragmas in Idris 1, which define various "
"experimental extensions. None of these are available in Idris 2, although"
" extensions may be defined in the future."
msgstr ""

#: ../../source/updates/updates.rst:337 8c85667bd6424503a7429184537d036a
msgid ""
"Also removed was the ``%access`` pragma for default visibility, use "
"visibility modifiers on each declaration instead."
msgstr ""

#: ../../source/updates/updates.rst:341 6261fc85a549465695bcbeecb1bc432a
msgid "``let`` bindings"
msgstr ""

#: ../../source/updates/updates.rst:343 a88d0c3d311f48008079bfffebc95b65
msgid ""
"``let`` bindings, i.e. expressions of the form ``let x = val in e`` have "
"slightly different behaviour. Previously, you could rely on the "
"computational behaviour of ``x`` in the scope of ``e``, so type checking "
"could take into account that ``x`` reduces to ``val``. Unfortunately, "
"this leads to complications with ``case`` and ``with`` clauses: if we "
"want to preserve the computational behaviour, we would need to make "
"significant changes to the way ``case`` and ``with`` are elaborated."
msgstr ""

#: ../../source/updates/updates.rst:351 a455f5d7c17440d2a2e7197f4dd40c81
msgid ""
"So, for simplicity and consistency (and, realistically, because I don't "
"have enough time to resolve the problem for ``case`` and ``with``) the "
"above expression ``let x = val in e`` is equivalent to ``(\\x => e) "
"val``."
msgstr ""

#: ../../source/updates/updates.rst:355 695fd2d2cfe54841a98426aff4d75d68
msgid ""
"So, ``let`` now effectively generalises a complex subexpression. If you "
"do need the computational behaviour of a definition, it is now possible "
"using local function definitions instead - see Section :ref:`sect-local-"
"defs` below."
msgstr ""

#: ../../source/updates/updates.rst:360 e49edb06a0c642039b957e27b46d923d
msgid ""
"Also, an alternative syntax ``let x := val in e`` is available. See "
"Section :ref:`sect-let-bindings` for more info."
msgstr ""

#: ../../source/updates/updates.rst:364 7e82550c31a740f9bb1c7cf0da641638
msgid "``auto``-implicits and Interfaces"
msgstr ""

#: ../../source/updates/updates.rst:366 8934de69b0094f3ebdb04eae03012923
msgid ""
"Interfaces and ``auto``-implicit arguments are similar, in that they "
"invoke an expression search mechanism to find the value of an argument. "
"In Idris 1, they were implemented separately, but in Idris 2, they use "
"the same mechanism. Consider the following *total* definition of "
"``fromMaybe``:"
msgstr ""

#: ../../source/updates/updates.rst:379 ac7a822ab6774ea1b0551a6c96cdafb9
msgid ""
"Since interface resolution and ``auto``-implicits are now the same thing,"
" the type of ``fromMaybe`` can be written as:"
msgstr ""

#: ../../source/updates/updates.rst:386 2422bf67677b43afbbca2addc9b4777b
msgid ""
"So now, the constraint arrow ``=>`` means that the argument will be found"
" by ``auto``-implicit search."
msgstr ""

#: ../../source/updates/updates.rst:389 6e22a8ceadd942f5b3bcdbc7fc6354a1
msgid ""
"When defining a ``data`` type, there are ways to control how "
"``auto``-implicit search will proceed, by giving options to the data "
"type. For example:"
msgstr ""

#: ../../source/updates/updates.rst:399 fe6d5bfba9074d1794141390363e932b
msgid ""
"The ``search x`` option means that ``auto``-implicit search for a value "
"of type ``Elem t ts`` will start as soon as the type checker has resolved"
" the value ``t``, even if ``ts`` is still unknown."
msgstr ""

#: ../../source/updates/updates.rst:403 18abfc7e25c24e92a0ad75a44f5a5797
msgid ""
"By default, ``auto``-implicit search uses the constructors of a data type"
" as search hints. The ``noHints`` option on a data type turns this "
"behaviour off."
msgstr ""

#: ../../source/updates/updates.rst:407 be7604da52ed49b1a79942e2fea6b925
#, python-format
msgid ""
"You can add your own search hints with the ``%hint`` option on a "
"function. For example:"
msgstr ""

#: ../../source/updates/updates.rst:423 2f773d40ec344e8babfacdf189b1856c
msgid ""
"In this case, searching for ``MyShow Bool`` will find ``showBool``, as we"
" can see if we try evaluating ``myShow True`` at the REPL:"
msgstr ""

#: ../../source/updates/updates.rst:431 3e8370aa858c4d349588c8129aece147
#, python-format
msgid ""
"In fact, this is how interfaces are elaborated. However, ``%hint`` should"
" be used with care. Too many hints can lead to a large search space!"
msgstr ""

#: ../../source/updates/updates.rst:435 839fdf79749247c5a5bf65ea9a2ad1cf
msgid "Record fields"
msgstr ""

#: ../../source/updates/updates.rst:437 49778934de404e329858789ca9a46786
msgid "Record fields can now be accessed via a ``.``. For example, if you have:"
msgstr ""

#: ../../source/updates/updates.rst:446 686b62c6e37148bc9b0087e87285668c
msgid ""
"and you have a record ``fred : Person``, then you can use "
"``fred.firstName`` to access the ``firstName`` field."
msgstr ""

#: ../../source/updates/updates.rst:450 5f7a3753d6c249b98a4b6ad5f1f726e3
msgid "Totality and Coverage"
msgstr ""

#: ../../source/updates/updates.rst:452 a3791dff386d4b72aff6c991498290d3
#, python-format
msgid ""
"``%default covering`` is now the default status, so all functions must "
"cover all their inputs unless stated otherwise with a ``partial`` "
"annotation, or switching to ``%default partial`` (which is not "
"recommended - use a ``partial`` annotation instead to have the smallest "
"possible place where functions are partial)."
msgstr ""

#: ../../source/updates/updates.rst:461 e8803e3cec7b4370ae68c95d76cf3278
msgid "Build artefacts"
msgstr ""

#: ../../source/updates/updates.rst:463 2c6bb48034de4672a48911bac4149f93
msgid ""
"This is not really a language change, but a change in the way Idris saves"
" checked files, and still useful to know. All checked modules are now "
"saved in a directory ``build/ttc``, in the root of the source tree, with "
"the directory structure following the directory structure of the source."
"  Executables are placed in ``build/exec``."
msgstr ""

#: ../../source/updates/updates.rst:470 65b1dad60be6471799119d155558c976
msgid "Packages"
msgstr ""

#: ../../source/updates/updates.rst:472 54537af43de44f5da0526ede24579f90
msgid ""
"Dependencies on other packages are now indicated with the ``depends`` "
"field, the ``pkgs`` field is no longer recognized. Also, fields with URLS"
" or other string data (other than module or package names), must be "
"enclosed in double quotes. For example:"
msgstr ""

#: ../../source/updates/updates.rst:500 80e290e41d36486aa55c1558a91147e8
msgid "New features"
msgstr ""

#: ../../source/updates/updates.rst:502 a14e7dee973045bf95165a722b7630ca
msgid ""
"As well as the change to the core language to use quantitative type "
"theory, described above, there are several other new features."
msgstr ""

#: ../../source/updates/updates.rst:508 381ff27d902a4f15ac329c5ee39ab190
msgid "Local function definitions"
msgstr ""

#: ../../source/updates/updates.rst:510 1e76608343804cc98fe6e401041d96e8
msgid ""
"Functions can now be defined locally, using a ``let`` block. For example,"
" ``greet`` in the following example, which is defined in the scope of a "
"local variable ``x``:"
msgstr ""

#: ../../source/updates/updates.rst:525 1c83a7ebf52c49fa87ca62cd17cabe13
msgid ""
"These ``let`` blocks can be used anywhere (in the middle of ``do`` blocks"
" as above, but also in any function, or in type declarations). ``where`` "
"blocks are now elaborated by translation into a local ``let``."
msgstr ""

#: ../../source/updates/updates.rst:529 cb6344a3a58245e78288b77daa271955
msgid ""
"However, Idris no longer attempts to infer types for functions defined in"
" ``where`` blocks, because this was fragile. This may be reinstated, if "
"we can come up with a good, predictable approach."
msgstr ""

#: ../../source/updates/updates.rst:534 6e5a17359cab496fb4da98c1677a6233
msgid "Scope of implicit arguments"
msgstr ""

#: ../../source/updates/updates.rst:536 96dbcb91e8474ad7b2fcf7d2c2df7347
msgid ""
"Implicit arguments in a type are now in scope in the body of a "
"definition. We've already seen this above, where ``n`` is in scope "
"automatically in the body of ``vlen``:"
msgstr ""

#: ../../source/updates/updates.rst:545 2cdc548f1d834ea6a805a64b77051975
msgid ""
"This is important to remember when using ``where`` blocks, or local "
"definitions, since the names in scope will also be in scope when "
"declaring the *type* of the local definition. For example, the following "
"definition, where we attempt to define our own version of ``Show`` for "
"``Vect``, will fail to type check:"
msgstr ""

#: ../../source/updates/updates.rst:560 12b5aea5a8964cfc9227fc6f0acbe620
msgid ""
"This fails because ``n`` is in scope already, from the type of "
"``showVect``, in the type declaration for ``showBody``, and so the first "
"clause ``showBody []`` will fail to type check because ``[]`` has length "
"``Z``, not ``n``. We can fix this by locally binding ``n``:"
msgstr ""

#: ../../source/updates/updates.rst:573 88d4e27c783647a78209967541062883
msgid "Or, alternatively, using a new name:"
msgstr ""

#: ../../source/updates/updates.rst:583 4e3123dcd783487ea51fca061ce425ac
msgid ""
"Idris 1 took a different approach here: names which were parameters to "
"data types were in scope, other names were not. The Idris 2 approach is, "
"we hope, more consistent and easier to understand."
msgstr ""

#: ../../source/updates/updates.rst:590 d4f735d27f8546cc9eec41fe735e4784
msgid "Function application syntax additions"
msgstr ""

#: ../../source/updates/updates.rst:592 9f39098ad947466cbd4ed60cfadc1721
msgid "From now on you can utilise the new syntax of function applications:"
msgstr ""

#: ../../source/updates/updates.rst:598 d7a90ba830f4467caf54e17caef30a37
msgid "There are three additions here:"
msgstr ""

#: ../../source/updates/updates.rst:600 c6958878848f4795bc93db4941220ea2
msgid "More than one argument can be written in braces, separated with commas:"
msgstr ""

#: ../../source/updates/updates.rst:624 5afed7eef8744e9987dcb4935390db1f
msgid ""
"Arguments in braces can now correspond to explicit, implicit and auto "
"implicit dependent function types (``Pi`` types), provided the domain "
"type is named:"
msgstr ""

#: ../../source/updates/updates.rst:635 7f7c999c6f7f4a8e8bb5530e2c675078
msgid ""
"Order of the arguments doesn't matter as long as they are in braces and "
"the names are distinct. It is better to stick named arguments in braces "
"at the end of your argument list, because regular unnamed explicit "
"arguments are processed first and take priority:"
msgstr ""

#: ../../source/updates/updates.rst:647 f785072c2cb34d34b5d62d15fb1218c1
msgid ""
"This snippet won't type check, because \"b\" in ``badCall`` is passed "
"first, although logically we want it to be second. Idris will tell you "
"that it couldn't find a spot for ``a = \"a\"`` (because \"b\" took its "
"place), so the application is ill-formed."
msgstr ""

#: ../../source/updates/updates.rst:652 e7b47fd8955d478380914b665776cef1
msgid ""
"Thus if you want to use the new syntax, it is worth naming your ``Pi`` "
"types."
msgstr ""

#: ../../source/updates/updates.rst:654 9a6adeec4e8649138fbdd509b8c13859
msgid ""
"Multiple explicit arguments can be \"skipped\" more easily with the "
"following syntax:"
msgstr ""

#: ../../source/updates/updates.rst:660 1b0c5a3b3f144aa0bc4c2356995be7b9
msgid "or"
msgstr ""

#: ../../source/updates/updates.rst:666 5a4822de5ba1453fb7b0fc8aa3c5b62a
msgid "in case none of the named arguments are wanted."
msgstr ""

#: ../../source/updates/updates.rst:668 06853b8fc2ab43c78f68933aca9b5656
msgid "Examples:"
msgstr ""

#: ../../source/updates/updates.rst:689 88303d7b787340508232408e934e66e4
msgid ""
"Last rule worth noting is the case of named applications with repeated "
"argument names, e.g:"
msgstr ""

#: ../../source/updates/updates.rst:703 9db4f1ea95a041fa97d75df2e718642d
msgid ""
"In this example the name ``x`` is given repeatedly to the ``Pi`` types of"
" the data constructor ``MkWeirdPair``. In order to deconstruct the "
"``WeirdPair a b`` in ``weirdSnd``, while writing the left-hand side of "
"the pattern-matching clause in a named manner (via the new syntax), we "
"have to rename the first occurrence of ``x`` to any fresh name or the "
"``_`` as we did. Then the definition type checks normally."
msgstr ""

#: ../../source/updates/updates.rst:708 aeae2131e8144d2ab03266ee1bf21b0a
msgid ""
"In general, duplicate names are bound sequentially on the left-hand side "
"and must be renamed for the pattern expression to be valid."
msgstr ""

#: ../../source/updates/updates.rst:710 523883e8d9354c6090c5b534965de7ac
msgid ""
"The situation is similar on the right-hand side of pattern-matching "
"clauses:"
msgstr ""

#: ../../source/updates/updates.rst:727 18b5152d912e494b853cd81c90e88086
msgid ""
"Named arguments should be passed sequentially in the order they were "
"defined in the ``Pi`` types, regardless of their (imp)explicitness."
msgstr ""

#: ../../source/updates/updates.rst:731 ccb227e7f1b04127873ff05436a1a418
msgid "Better inference"
msgstr ""

#: ../../source/updates/updates.rst:733 51bf3cb4567f4b90a9405e04fe0be870
msgid ""
"In Idris 1, holes (that is, unification variables arising from implicit "
"arguments) were local to an expression, and if they were not resolved "
"while checking the expression, they would not be resolved at all. In "
"Idris 2, they are global, so inference works better. For example, we can "
"now say:"
msgstr ""

#: ../../source/updates/updates.rst:746 13fa521c679e437aa127af3ecff66a43
msgid ""
"The ``?``, incidentally, differs from ``_`` in that ``_`` will be bound "
"as an implicit argument if unresolved after checking the type of "
"``test``, but ``?`` will be left as a hole to be resolved later. "
"Otherwise, they can be used interchangeably."
msgstr ""

#: ../../source/updates/updates.rst:752 e64032b5ad6f40389528bd189a1e2c7c
msgid "Dependent case"
msgstr ""

#: ../../source/updates/updates.rst:754 1cec118386b34d2686bcf7d82cfd2497
msgid ""
"``case`` blocks were available in Idris 1, but with some restrictions. "
"Having better inference means that ``case`` blocks work more effectively "
"in Idris 2, and dependent case analysis is supported."
msgstr ""

#: ../../source/updates/updates.rst:766 7ed299659e404f3b8676dd74e2f119b1
msgid ""
"The implicit arguments and original values are still available in the "
"body of the ``case``. Somewhat contrived, but the following is valid:"
msgstr ""

#: ../../source/updates/updates.rst:779 d2ec64f1b3564f0b9d23f845ac25163e
msgid "Record updates"
msgstr ""

#: ../../source/updates/updates.rst:781 db5c3de9a82c4773b94a81220c1d5cac
msgid ""
"Dependent record updates work, provided that all relevant fields are "
"updated at the same time. Dependent record update is implemented via "
"dependent ``case`` blocks rather than by generating a specific update "
"function for each field as in Idris 1, so you will no longer get "
"mystifying errors when trying to update dependent records!"
msgstr ""

#: ../../source/updates/updates.rst:787 b9c1009ce4604e659d1bad2d601a3365
msgid ""
"For example, we can wrap a vector in a record, with an explicit length "
"field:"
msgstr ""

#: ../../source/updates/updates.rst:798 a99e10fa2e304f8586d1b20f70641eb9
msgid ""
"Then, we can safely update the ``content``, provided we update the "
"``length`` correspondingly:"
msgstr ""

#: ../../source/updates/updates.rst:807 ea62b10d5ee9483cb203ebd06777f0e6
msgid "Another novelty - new update syntax (previous one still functional):"
msgstr ""

#: ../../source/updates/updates.rst:821 8e21d8a9608f4c4dae26d2ba2e733899
msgid ""
"The ``record`` keyword has been discarded for brevity, symbol ``:=`` "
"replaces ``=`` in order to not introduce any ambiguity."
msgstr ""

#: ../../source/updates/updates.rst:825 9afd942b47b04c978c965754bc58b1c3
msgid "Generate definition"
msgstr ""

#: ../../source/updates/updates.rst:827 a0e9b276e9cc4cb5a37e00d3a29fb6c5
msgid ""
"A new feature of the IDE protocol supports generating complete "
"definitions from a type signature. You can try this at the REPL, for "
"example, given our favourite introductory example..."
msgstr ""

#: ../../source/updates/updates.rst:835 552a84f36d74403eb2bc18ffe4c5a42a
msgid ""
"...assuming this is defined on line 3, you can use the ``:gd`` command as"
" follows:"
msgstr ""

#: ../../source/updates/updates.rst:844 27a01bf731244575bed7f049c4ea0dc7
msgid ""
"This works by a fairly simple brute force search, which tries searching "
"for a valid right hand side, and case splitting on the left if that "
"fails, but is remarkably effective in a lot of situations. Some other "
"examples which work:"
msgstr ""

#: ../../source/updates/updates.rst:857 bddd56f8d8274dceb8d0a28f1fa1e226
msgid "This is available in the IDE protocol via the ``generate-def`` command."
msgstr ""

#: ../../source/updates/updates.rst:860 28057330062d42eb863af0207c29f466
msgid "Chez Scheme target"
msgstr ""

#: ../../source/updates/updates.rst:862 c84614e7ac5e4c74b4422007d98c63df
msgid ""
"The default code generator is, for the moment, `Chez Scheme "
"<https://www.scheme.com/>`_. Racket and Gambit code generators are also "
"available.  Like Idris 1, Idris 2 `supports plug-in code generation "
"<https://idris2.readthedocs.io/en/latest/backends/custom.html>`_ to allow"
" you to write a back end for the platform of your choice. To change the "
"code generator, you can use the ``:set cg`` command:"
msgstr ""

#: ../../source/updates/updates.rst:873 0bb85f8452fa4346a411d1b1f2eed951
msgid ""
"Early experience shows that both are much faster than the Idris 1 C code "
"generator, in both compile time and execution time (but we haven't done "
"any formal study on this yet, so it's just anecdotal evidence)."
msgstr ""

