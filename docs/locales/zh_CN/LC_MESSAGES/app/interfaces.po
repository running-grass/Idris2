# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 09:10+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/app/interfaces.rst:2 86a028ab2e1e4f60a6efe7482e413e0d
msgid "Defining Interfaces"
msgstr ""

#: ../../source/app/interfaces.rst:4 dd534837e3504fada0d248e1d7f9eeff
msgid ""
"The only way provided by ``Control.App`` to run an ``App`` is via the "
"``run`` function, which takes a concrete list of errors ``Init``. All "
"concrete extensions to this list of errors are via either ``handle``, to "
"introduce a new exception, or ``new``, to introduce a new state. In order"
" to compose ``App`` programs effectively, rather than introducing "
"concrete exceptions and state in general, we define interfaces for "
"collections of operations which work in a specific list of errors."
msgstr ""

#: ../../source/app/interfaces.rst:14 17425284b33541bda4b17b13b4cee92b
msgid "Example: Console I/O"
msgstr ""

#: ../../source/app/interfaces.rst:16 1deb44314b104705b03afa84e3101932
msgid ""
"We have seen an initial example using the ``Console`` interface, which is"
" declared as follows, in ``Control.App.Console``:"
msgstr ""

#: ../../source/app/interfaces.rst:27 9f57b467974e49a0aea76d80fe391fb5
msgid ""
"It provides primitives for writing to and reading from the console, and "
"generalising the path parameter to ``l`` means that neither can throw an "
"exception, because they have to work in both the ``NoThrow`` and "
"``MayThrow`` contexts."
msgstr ""

#: ../../source/app/interfaces.rst:32 fcf9ce9c6d764f8386530dc804f2ed1f
msgid ""
"To implement this for use in a top level ``IO`` program, we need access "
"to primitive ``IO`` operations. The ``Control.App`` library defines a "
"primitive interface for this:"
msgstr ""

#: ../../source/app/interfaces.rst:42 89d96960f8f7477696b2d7951e472dea
msgid ""
"We use ``primIO`` to invoke an ``IO`` function. We also have a ``fork`` "
"primitive, which starts a new thread in a new list of errors supporting "
"``PrimIO``.  Note that ``fork`` starts a new list of errors ``e'`` so "
"that states are only available in a single thread."
msgstr ""

#: ../../source/app/interfaces.rst:47 600eb9b0c9f244feaa59e0b986ba3532
msgid ""
"There is an implementation of ``PrimIO`` for a list of errors which can "
"throw the empty type as an exception. This means that if ``PrimIO`` is "
"the only interface available, we cannot throw an exception, which is "
"consistent with the definition of ``IO``. This also allows us to use "
"``PrimIO`` in the initial list of errors ``Init``."
msgstr ""

#: ../../source/app/interfaces.rst:57 f3f40198c4df46dc9541e92f41225822
msgid ""
"Given this, we can implement ``Console`` and run our ``hello`` program in"
" ``IO``. It is implemented as follows in ``Control.App.Console``:"
msgstr ""

#: ../../source/app/interfaces.rst:69 d8a5de24dde6410182d4d082b8a48aa5
msgid "Example: File I/O"
msgstr ""

#: ../../source/app/interfaces.rst:71 109e5eace8f049ff8ad338c618a094e8
msgid ""
"Console I/O can be implemented directly, but most I/O operations can "
"fail. For example, opening a file can fail for several reasons: the file "
"does not exist; the user has the wrong permissions, etc. In Idris, the "
"``IO`` primitive reflects this in its type:"
msgstr ""

#: ../../source/app/interfaces.rst:80 db43c826e1214f5e97a638a34101a303
msgid ""
"While precise, this becomes unwieldy when there are long sequences of "
"``IO`` operations. Using ``App``, we can provide an interface which "
"throws an exception when an operation fails, and guarantee that any "
"exceptions are handled at the top level using ``handle``. We begin by "
"defining the ``FileIO`` interface, in ``Control.App.FileIO``:"
msgstr ""

#: ../../source/app/interfaces.rst:101 b60cd358088d46bba0a5cc6e1450d19c
msgid ""
"We use resource bracketing - passing a function to ``withFile`` for "
"working with the opened file - rather than an explicit ``open`` "
"operation, to open a file, to ensure that the file handle is cleaned up "
"on completion."
msgstr ""

#: ../../source/app/interfaces.rst:106 3fed6dc42a7a4764877ad3e2d03632be
msgid ""
"One could also imagine an interface using a linear resource for the file,"
" which might be appropriate in some safety critical contexts, but for "
"most programming tasks, exceptions should suffice. All of the operations "
"can fail, and the interface makes this explicit by saying we can only "
"implement ``FileIO`` if the list of errors supports throwing and catching"
" the ``IOError`` exception. ``IOError`` is defined in ``Control.App``."
msgstr ""

#: ../../source/app/interfaces.rst:114 47aeacf5e95543ee952ca67aa45bb47e
msgid ""
"For example, we can use this interface to implement ``readFile``, "
"throwing an exception if opening the file fails in ``withFile``:"
msgstr ""

#: ../../source/app/interfaces.rst:130 4010ca998f9e461e863c2284aef811eb
msgid "Again, this is defined in ``Control.App.FileIO``."
msgstr ""

#: ../../source/app/interfaces.rst:132 c57a99355e8a49a69e046f3586703d16
msgid ""
"To implement ``FileIO``, we need access to the primitive operations via "
"``PrimIO``, and the ability to throw exceptions if any of the operations "
"fail. With this, we can implement ``withFile`` as follows, for example:"
msgstr ""

#: ../../source/app/interfaces.rst:148 625874455987401592c92df30123ff49
msgid ""
"Given this implementation of ``FileIO``, we can run ``readFile``, "
"provided that we wrap it in a top level ``handle`` function to deal with "
"any errors thrown by ``readFile``:"
msgstr ""

