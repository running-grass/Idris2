# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 11:10+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/app/linear.rst:2 413b52abaeea46e3a7ee3be7976228b6
msgid "Linear Resources"
msgstr ""

#: ../../source/app/linear.rst:4 189fbdd3e5e04497908a4e2857f4a899
msgid ""
"We have introduced ``App`` for writing interactive programs, using "
"interfaces to constrain which operations are permitted, but have not yet "
"seen the ``Path`` parameter in action. Its purpose is to constrain when "
"programs can throw exceptions, to know where linear resource usage is "
"allowed. The bind operator for ``App`` is defined as follows (not via "
"``Monad``):"
msgstr ""

#: ../../source/app/linear.rst:20 d4243b56d70245b0b36d28c00a812d3a
msgid ""
"The intuition behind this type is that, when sequencing two ``App`` "
"programs:"
msgstr ""

#: ../../source/app/linear.rst:23 44ca10062447476a88c0f7b6416f9148
msgid ""
"if the first action might throw an exception, then the whole program "
"might throw."
msgstr ""

#: ../../source/app/linear.rst:25 35ab734649344ef1a6ad178a32aafc51
msgid ""
"if the first action cannot throw an exception, the second action can "
"still throw, and the program as a whole can throw."
msgstr ""

#: ../../source/app/linear.rst:27 f4d274a2dc9f486da2bd1ac4a5a9fa11
msgid ""
"if neither action can throw an exception, the program as a whole cannot "
"throw."
msgstr ""

#: ../../source/app/linear.rst:30 bcc3d149d7294f13ac1a2ee91f00f312
msgid ""
"The reason for the detail in the type is that it is useful to be able to "
"sequence programs with a different ``Path``, but in doing so, we must "
"calculate the resulting ``Path`` accurately. Then, if we want to sequence"
" subprograms with linear variables, we can use an alternative bind "
"operator which guarantees to run the continuation exactly once:"
msgstr ""

#: ../../source/app/linear.rst:42 2c17a3392890423f8aa0219ccb047fcf
msgid ""
"To illustrate the need for ``bindL``, we can try writing a program which "
"tracks the state of a secure data store, which requires logging in before"
" reading the data."
msgstr ""

#: ../../source/app/linear.rst:47 db9f789a9fe94bb8b05b12107ea4340e
msgid "Example: a data store requiring a login"
msgstr ""

#: ../../source/app/linear.rst:49 07888957084b4bd8b87336b62f817979
msgid ""
"Many software components rely on some form of state, and there may be "
"operations which are only valid in specific states. For example, consider"
" a secure data store in which a user must log in before getting access to"
" some secret data. This system can be in one of two states:"
msgstr ""

#: ../../source/app/linear.rst:54 83bb864bcd0e42008316fdba9141f6e3
msgid "``LoggedIn``, in which the user is allowed to read the secret"
msgstr ""

#: ../../source/app/linear.rst:55 7a8d80382d084743aa4c0512cc111732
msgid "``LoggedOut``, in which the user has no access to the secret"
msgstr ""

#: ../../source/app/linear.rst:57 b0353d63df224090b1f24542624aea3f
msgid ""
"We can provide commands to log in, log out, and read the data, as "
"illustrated in the following diagram:"
msgstr ""

#: ../../source/app/linear.rst:60 4329f0519a9e4c568e191ef664299cc3
msgid "|login|"
msgstr ""

#: ../../source/app/linear.rst:126 17df46e2ff664fe48873c103bbbd2831
#: 7bc51b74c4984cc88768c17f78e9a7e5
msgid "login"
msgstr ""

#: ../../source/app/linear.rst:62 bedca97c879d46ab8ace3a16677bb116
msgid ""
"The ``login`` command, if it succeeds, moves the overall system state "
"from ``LoggedOut`` to ``LoggedIn``. The ``logout`` command moves the "
"state from ``LoggedIn`` to ``LoggedOut``. Most importantly, the "
"``readSecret`` command is only valid when the system is in the "
"``LoggedIn`` state."
msgstr ""

#: ../../source/app/linear.rst:67 930f839bc34645ff8439259c60569856
msgid ""
"We can represent the state transitions using functions with linear types."
" To begin, we define an interface for connecting to and disconnecting "
"from a store:"
msgstr ""

#: ../../source/app/linear.rst:78 5c35c56ea54040bbbad567c209023d74
msgid ""
"Neither ``connect`` nor ``disconnect`` throw, as shown by generalising "
"over ``l``. Once we have a connection, we can use the following functions"
" to access the resource directly:"
msgstr ""

#: ../../source/app/linear.rst:94 1464bd038a5743dd8d2f961a5275f24e
msgid ""
"``Res`` is defined in the Prelude, since it is commonly useful.  It is a "
"dependent pair type, which associates a value with a linear resource. "
"We'll leave the other definitions abstract, for the purposes of this "
"introductory example."
msgstr ""

#: ../../source/app/linear.rst:99 341317a4179a40dda101d505e0303885
msgid ""
"The following listing shows a complete program accessing the store, which"
" reads a password, accesses the store if the password is correct and "
"prints the secret data. It uses ``let (>>=) = bindL`` to redefine "
"``do``-notation locally."
msgstr ""

#: ../../source/app/linear.rst:119 862eaba8738d4ecfa2754f036cee4883
msgid ""
"If we omit the ``let (>>=) = bindL``, it will use the default ``(>>=)`` "
"operator, which allows the continuation to be run multiple times, which "
"would mean that ``s`` is not guaranteed to be accessed linearly, and "
"``storeProg`` would not type check. We can safely use ``getStr`` and "
"``putStr`` because they are guaranteed not to throw by the ``Path`` "
"parameter in their types."
msgstr ""

#: ../../source/app/linear.rst:130 9e7e924a2e1740db9e5dd5a39ce5fede
msgid "App1: Linear Interfaces"
msgstr ""

#: ../../source/app/linear.rst:132 7d19ae8f02314a0d9745c5466e604647
msgid ""
"Adding the ``bindL`` function to allow locally rebinding the ``(>>=)`` "
"operator allows us to combine existing linear resource programs with "
"operations in ``App`` - at least, those that don't throw. It would "
"nevertheless be nice to interoperate more directly with ``App``. One "
"advantage of defining interfaces is that we can provide multiple "
"implementations for different contexts, but our implementation of the "
"data store uses primitive functions (which we left undefined in any case)"
" to access the store."
msgstr ""

#: ../../source/app/linear.rst:141 b7448496a2ca4d5eb500d26a30355540
msgid ""
"To allow control over linear resources, ``Control.App`` provides an "
"alternative parameterised type ``App1``:"
msgstr ""

#: ../../source/app/linear.rst:149 efcfde41e760494eb0223683b14705a3
msgid ""
"There is no need for a ``Path`` argument, since linear programs can never"
" throw. The ``Usage`` argument states whether the value returned is to be"
" used once, or has unrestricted usage, with the default in ``App1`` being"
" to use once:"
msgstr ""

#: ../../source/app/linear.rst:158 8e7c75c947e3480884b909d760e9edfb
msgid ""
"The main difference from ``App`` is the ``(>>=)`` operator, which has a "
"different multiplicity for the variable bound by the continuation "
"depending on the usage of the first action:"
msgstr ""

#: ../../source/app/linear.rst:171 107973750b144b6fbb6872fdde8ae578
msgid ""
"``Cont1Type`` returns a continuation which uses the argument linearly, if"
" the first ``App1`` program has usage ``One``, otherwise it returns a "
"continuation where argument usage is unrestricted. Either way, because "
"there may be linear resources in scope, the continuation is run exactly "
"once and there can be no exceptions thrown."
msgstr ""

#: ../../source/app/linear.rst:177 f9a8b284cf0c45e3bc558bda9e50994b
msgid ""
"Using ``App1``, we can define all of the data store operations in a "
"single interface, as shown in the following listing. Each operation other"
" than ``disconnect`` returns a `linear` resource."
msgstr ""

#: ../../source/app/linear.rst:193 fd2023a52f5641bca3cb349d985139d4
msgid "We can explicitly move between ``App`` and ``App1``:"
msgstr ""

#: ../../source/app/linear.rst:200 68a1bd3ebd3b41bb9af77b63a3c8986b
msgid ""
"We can run an ``App`` program using ``app``, inside ``App1``, provided "
"that it is guaranteed not to throw. Similarly, we can run an ``App1`` "
"program using ``app1``, inside ``App``, provided that the value it "
"returns has unrestricted usage. So, for example, we can write:"
msgstr ""

#: ../../source/app/linear.rst:214 67342912fb674ddaade1081e83cbb329
msgid ""
"This uses ``app1`` to state that the body of the program is linear, then "
"``app`` to state that the ``putStr`` operation is in ``App``. We can see "
"that ``connect`` returns a linear resource by inspecting the hole "
"``what_next``, which also shows that we are running inside ``App1``:"
msgstr ""

#: ../../source/app/linear.rst:227 fbaa13d95e0d44a9a56218e52aa4851e
msgid ""
"For completeness, one way to implement the interface is as follows, with "
"hard coded password and internal data:"
msgstr ""

#: ../../source/app/linear.rst:247 9f65588ae62942b8b9c8bbe116c008dd
msgid "Then we can run it in ``main``:"
msgstr ""

