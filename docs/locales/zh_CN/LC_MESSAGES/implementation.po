# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 09:08+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/implementation/ide-protocol.rst:3
msgid "The IDE Protocol"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:5
msgid ""
"The Idris REPL has two modes of interaction: a human-readable syntax "
"designed for direct use in a terminal, and a machine-readable syntax "
"designed for using Idris as a backend for external tools."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:7
msgid ""
"The IDE-Protocol is versioned separately from the Idris compiler. The "
"first version of Idris (written in Haskell and is at v1.3.3) implements "
"version one of the IDE Protocol, and Idris2 (self-hosting and is at "
"v.0.3.0) implements version two of the IDE Protocol."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:10
msgid ""
"The protocol and its serialisation/deserialisation routines are part of "
"the `Protocol` submodule hierarchy and are packaged in the "
"`idris2protocols.ipkg` package."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:14
msgid "Protocol Overview"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:16
msgid ""
"The communication protocol is of asynchronous request-reply style: a "
"single request from the client is handled by Idris at a time. Idris waits"
" for a request on its standard input stream, and outputs the answer or "
"answers to standard output. The result of a request can be either "
"success, failure, or intermediate output; and furthermore, before the "
"result is delivered, there might be additional meta-messages."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:21
msgid ""
"A reply can consist of multiple messages: any number of messages to "
"inform the user about the progress of the request or other informational "
"output, and finally a result, either ``ok`` or ``error``."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:23
msgid ""
"The wire format is the length of the message in characters, encoded in 6 "
"characters hexadecimal, followed by the message encoded as S-expression "
"(sexp). Additionally, each request includes a unique integer (counting "
"upwards), which is repeated in all messages corresponding to that "
"request."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:26
msgid ""
"An example interaction from loading the file ``/home/hannes/empty.idr`` "
"looks as follows on the wire:::"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:34
msgid ""
"The first message is the request from idris-mode to load the specific "
"file, which length is hex 2a, decimal 42 (including the newline at the "
"end). The request identifier is set to 1. The first message from Idris is"
" to write the string ``Type checking /home/hannes/empty.idr``, another is"
" to set the prompt to ``*/home/hannes/empty``. The answer, starting with "
"``:return`` is ``ok``, and additional information is that the file was "
"loaded."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:39
msgid ""
"There are three atoms in the wire language: numbers, strings, and "
"symbols. The only compound object is a list, which is surrounded by "
"parenthesis. The syntax is::"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:46
msgid ""
"where ``NUM`` is either 0 or a positive integer, ``ALPHA`` is an "
"alphabetical character, and ``STR`` is the contents of a string, with "
"``\"`` escaped by a backslash. The atom ``nil`` is accepted instead of "
"``()`` for compatibility with some regexp pretty-printing routines."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:49
msgid ""
"The state of the Idris process is mainly the active file, which needs to "
"be kept synchronised between the editor and Idris. This is achieved by "
"the already seen ``:load-file`` command."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:53
msgid "Protocol Versioning"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:55
msgid ""
"When interacting with Idris through the IDE Protocol the initial message "
"sent by the running Idris Process is the version (major and minor) of the"
" IDE Protocol being used."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:57
msgid "The expected message has the following format:"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:59
msgid "``(:protocol-version MAJOR MINOR)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:61
msgid "IDE Clients can use this to help support multiple Idris versions."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:64
msgid "Commands"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:66
msgid ""
"The available commands are listed below. They are compatible with Version"
" 1 and 2.0 of the protocol unless otherwise stated."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:71
msgid "``(:load-file FILENAME [LINE])``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:70
msgid ""
"Load the named file.  If a ``LINE`` number is provided, the file is only "
"loaded up to that line.  Otherwise, the entire file is loaded. Version 2 "
"of the IDE Protocol requires that the file name be a quoted string, as in"
" ``(:load-file \"MyFile.idr\")`` and not ``(:load-file MyFile.idr)``."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:75
msgid "``(:cd FILEPATH)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:74
msgid ""
"Change the working direction to the given ``FILEPATH``. Version 2 of the "
"IDE Protocol requires that the path is quoted, as in ``(:cd \"a/b/c\")`` "
"and not ``(:cd a/b/c)``."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:78
msgid "``(:interpret STRING)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:78
msgid "Interpret ``STRING`` at the Idris REPL, returning a highlighted result."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:82
msgid "``(:type-of STRING)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:81
msgid ""
"Return the type of the name, written with Idris syntax in the ``STRING``."
" The reply may contain highlighting information."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:86
msgid "``(:case-split LINE NAME)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:85
msgid ""
"Generate a case-split for the pattern variable ``NAME`` on program line "
"``LINE``. The pattern-match cases to be substituted are returned as a "
"string with no highlighting."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:90
msgid "``(:add-clause LINE NAME)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:89
msgid ""
"Generate an initial pattern-match clause for the function declared as "
"``NAME`` on program line ``LINE``. The initial clause is returned as a "
"string with no highlighting."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:93
msgid "``(:add-proof-clause LINE NAME)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:93
msgid "Add a clause driven by the ``<==`` syntax."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:97
msgid "``(:add-missing LINE NAME)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:96
msgid ""
"Add the missing cases discovered by totality checking the function "
"declared as ``NAME`` on program line ``LINE``. The missing clauses are "
"returned as a string with no highlighting."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:101
msgid "``(:make-with LINE NAME)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:100
msgid ""
"Create a with-rule pattern match template for the clause of function "
"``NAME`` on line ``LINE``. The new code is returned with no highlighting."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:105
msgid "``(:make-case LINE NAME)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:104
msgid ""
"Create a case pattern match template for the clause of function ``NAME`` "
"on line ``LINE``. The new code is returned with no highlighting."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:108
msgid "``(:make-lemma LINE NAME)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:108
msgid ""
"Create a top level function with a type which solves the hole named "
"``NAME`` on line ``LINE``."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:113
msgid "``(:proof-search LINE NAME HINTS)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:111
msgid ""
"Attempt to fill out the hole on ``LINE`` named ``NAME`` by proof search. "
"``HINTS`` is a possibly-empty list of additional things to try while "
"searching. This operation is also called ``ExprSearch`` in the Idris 2 "
"API."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:116
msgid "``(:refine LINE NAME TM)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:116
msgid "Refine the hole on ``LINE`` named ``NAME`` by using the term ``TM``."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:121
msgid "``(:docs-for NAME [MODE])``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:119
msgid ""
"Look up the documentation for ``NAME``, and return it as a highlighted "
"string. If ``MODE`` is ``:overview``, only the first paragraph of "
"documentation is provided for ``NAME``. If ``MODE`` is ``:full``, or "
"omitted, the full documentation is returned for ``NAME``."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:124
msgid "``(:apropos STRING)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:124
msgid ""
"Search the documentation for mentions of ``STRING``, and return any found"
" as a list of highlighted strings."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:127
msgid "``(:metavariables WIDTH)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:127
msgid ""
"List the currently-active holes, with their types pretty-printed in "
"``WIDTH`` columns."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:130
msgid "``(:who-calls NAME)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:130
msgid "Get a list of callers of ``NAME``."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:133
msgid "``(:calls-who NAME)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:133
msgid "Get a list of callees of ``NAME``."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:136
msgid "``(:browse-namespace NAMESPACE)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:136
msgid ""
"Return the contents of ``NAMESPACE``, like ``:browse`` at the command-"
"line REPL."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:139
msgid "``(:normalise-term TM)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:139
msgid ""
"Return a highlighted string consisting of the results of normalising the "
"serialised term ``TM`` (which would previously have been sent as the "
"``tt-term`` property of a string)."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:143
msgid "``(:show-term-implicits TM)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:142
msgid ""
"Return a highlighted string, consisting of the results of making all "
"arguments in serialised term ``TM`` explicit. The arguments in ``TM`` "
"would previously have been sent as the ``tt-term`` property of a string."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:147
msgid "``(:hide-term-implicits TM)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:146
msgid ""
"Return a highlighted string, consisting of the results of making all "
"arguments in serialised term ``TM`` follow their usual implicitness "
"setting. The arguments in ``TM`` would previously have been sent as the "
"``tt-term`` property of a string."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:151
msgid "``(:elaborate-term TM)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:150
msgid ""
"Return a highlighted string, consisting of the core language term "
"corresponding to serialised term ``TM``. The arguments in ``TM`` would "
"previously have been sent as the ``tt-term`` property of a string."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:154
msgid "``(:print-definition NAME)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:154
msgid "Return the definition of ``NAME`` as a highlighted string."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:157
msgid "``(:repl-completions NAME)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:157
msgid ""
"Search names, types and documentations which contain ``NAME``. Return the"
" result of tab-completing ``NAME`` as a REPL command."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:160
msgid "``:version``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:160
msgid "Return the version information of the Idris compiler."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:163
msgid "New For Version 2"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:165
msgid "New in Version 2 of the protocol are:"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:168
msgid "``(:generate-def LINE NAME)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:168
msgid "Attempt to generate a complete definition from a type."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:171
msgid "``(:generate-def-next)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:171
msgid ""
"Replace the previous generated definition with the next generated "
"definition."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:174
msgid "``(:proof-search-next)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:174
msgid ""
"Replace the previous proof search result with the next proof search "
"result."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:178
msgid "``(:intro LINE NAME)``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:177
msgid ""
"Returns the non-empty list of valid saturated constructors that can be "
"used in the hole at line ``LINE`` named ``NAME``."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:181
msgid "Possible Replies"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:183
msgid "Possible replies include a normal final reply:::"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:188
msgid "A normal intermediate reply:::"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:193
msgid "Informational and/or abnormal replies:::"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:200
msgid "Warnings include compiler errors that don't cause the compiler to stop."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:203
msgid "Output Highlighting"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:205
msgid ""
"Idris mode supports highlighting the output from Idris. In reality, this "
"highlighting is controlled by the Idris compiler. Some of the return "
"forms from Idris support an optional extra parameter: a list mapping "
"spans of text to metadata about that text. Clients can then use this list"
" both to highlight the displayed output and to enable richer interaction "
"by having more metadata present. For example, the Emacs mode allows "
"right-clicking identifiers to get a menu with access to documentation and"
" type signatures."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:212
msgid ""
"A particular semantic span is a three element list. The first element of "
"the list is the index at which the span begins, the second element is the"
" number of characters included in the span, and the third is the semantic"
" data itself. The semantic data is a list of lists. The head of each list"
" is a key that denotes what kind of metadata is in the list, and the tail"
" is the metadata itself."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:260
msgid "The following keys are available:"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:218
msgid "``name``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:219
msgid "gives a reference to the fully-qualified Idris name"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:220
msgid "``implicit``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:221
msgid ""
"provides a Boolean value that is True if the region is the name of an "
"implicit argument"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:233
msgid "``decor``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:223
msgid "describes the category of a token, which can be:"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:225
msgid "``type``: type constructors"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:227
msgid "``function``: defined functions"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:229
msgid "``data``: data constructors"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:231
msgid "``bound``: bound variables, or"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:233
msgid "``keyword``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:245
msgid "``source-loc``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:236
msgid ""
"states that the region refers to a source code location. Its body is a "
"collection of key-value pairs, with the following possibilities:"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:239
msgid "``filename``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:239
msgid "provides the filename"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:242
msgid "``start``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:242
msgid ""
"provides the line and column that the source location starts at as a two-"
"element tail"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:245
msgid "``end``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:245
msgid ""
"provides the line and column that the source location ends at as a two-"
"element tail"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:248
msgid "``text-formatting``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:248
msgid ""
"provides an attribute of formatted text. This is for use with natural-"
"language text, not code, and is presently emitted only from inline "
"documentation. The potential values are ``bold``, ``italic``, and "
"``underline``."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:251
msgid "``link-href``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:251
msgid "provides a URL that the corresponding text is a link to."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:254
msgid "``quasiquotation``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:254
msgid "states that the region is quasiquoted."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:257
msgid "``antiquotation``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:257
msgid "states that the region is antiquoted."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:260
msgid "``tt-term``"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:260
msgid ""
"A serialised representation of the Idris core term corresponding to the "
"region of text."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:263
msgid "Source Code Highlighting"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:265
msgid ""
"Idris supports instructing editors how to colour their code. When "
"elaborating source code or REPL input, Idris will locate regions of the "
"source code corresponding to names, and emit information about these "
"names using the same metadata as output highlighting."
msgstr ""

#: ../../source/implementation/ide-protocol.rst:268
msgid ""
"These messages will arrive as replies to the command that caused "
"elaboration to occur, such as ``:load-file`` or ``:interpret``. They have"
" the format:::"
msgstr ""

#: ../../source/implementation/ide-protocol.rst:273
msgid ""
"where ``POSNS`` is a list of positions to highlight. Each of these is a "
"two-element list whose first element is a position (encoded as for the "
"``source-loc`` property above) and whose second element is highlighting "
"metadata in the same format used for output."
msgstr ""

#: ../../source/implementation/index.rst:5
msgid "Implementation Notes"
msgstr ""

#: ../../source/implementation/index.rst:9
msgid ""
"The documentation for Idris has been published under the Creative Commons"
" CC0 License. As such to the extent possible under law, *The Idris "
"Community* has waived all copyright and related or neighboring rights to "
"Documentation for Idris."
msgstr ""

#: ../../source/implementation/index.rst:14
msgid ""
"More information concerning the CC0 can be found online at: "
"http://creativecommons.org/publicdomain/zero/1.0/"
msgstr ""

#: ../../source/implementation/index.rst:16
msgid ""
"This section contains (or will contain, hopefully) a variety of notes on "
"aspects of the implementation of Idris 2, in the hope that they help with"
" debugging and future contributions."
msgstr ""

#: ../../source/implementation/overview.rst:3
msgid "Implementation Overview"
msgstr ""

#: ../../source/implementation/overview.rst:5
msgid ""
"These are some unsorted notes on aspects of the implementation. Sketchy, "
"and not always completely up to date, but hopefully give some hints as to"
" what's going on and some ideas where to look in the code to see how "
"certain features work."
msgstr ""

#: ../../source/implementation/overview.rst:11
msgid "Introduction"
msgstr ""

#: ../../source/implementation/overview.rst:13
msgid ""
"Core language TT (defined in ``Core.TT``), based on quantitative type "
"theory (see https://bentnib.org/quantitative-type-theory.html). Binders "
"have \"multiplicities\" which are either *0*, *1* or *unlimited*."
msgstr ""

#: ../../source/implementation/overview.rst:17
msgid ""
"Terms are indexed over the names in scope so that we know terms are "
"always well scoped. Values (i.e. normal forms) are defined in "
"``Core.Value`` as ``NF``; constructors do not evaluate their arguments "
"until explicitly requested."
msgstr ""

#: ../../source/implementation/overview.rst:21
msgid ""
"Elaborate to *TT* from a higher level language *TTImp* (defined in "
"``TTImp.TTImp``), which is TT with implicit arguments, local function "
"definitions, case blocks, as patterns, qualified names with automatic "
"type-directed disambiguation, and proof search."
msgstr ""

#: ../../source/implementation/overview.rst:26
msgid ""
"Elaboration relies on unification (in ``Core.Unify``), which allows "
"postponing of unification problems. Essentially works the same way as "
"Agda as described in Ulf Norell's thesis."
msgstr ""

#: ../../source/implementation/overview.rst:30
msgid ""
"General idea is that high level languages will provide a translation to "
"TT. In the ``Idris/`` namespace we define the high level syntax for "
"Idris, which translates to TTImp by desugaring operators, do notation, "
"etc."
msgstr ""

#: ../../source/implementation/overview.rst:34
msgid ""
"There is a separate linearity check after elaboration, which updates "
"types of holes (and is aware of case blocks). This is implemented in "
"``Core.LinearCheck``. During this check, we also recalculate the "
"multiplicities in hole applications so that they are displayed "
"appropriately (e.g. if a linear variable is unused elsewhere, it will "
"always appear with multiplicity 1 in holes)."
msgstr ""

#: ../../source/implementation/overview.rst:42
msgid "Where to find things:"
msgstr ""

#: ../../source/implementation/overview.rst:44
msgid "``Core/`` -- anything related to the core TT, typechecking and unification"
msgstr ""

#: ../../source/implementation/overview.rst:45
msgid "``TTImp/`` -- anything related to the implicit TT and its elaboration"
msgstr ""

#: ../../source/implementation/overview.rst:47
msgid "``TTImp/Elab/`` -- Elaboration state and elaboration of terms"
msgstr ""

#: ../../source/implementation/overview.rst:48
msgid "``TTImp/Interactive/`` -- Interactive editing infrastructure"
msgstr ""

#: ../../source/implementation/overview.rst:50
msgid ""
"``Parser/`` -- various utilities for parsing and lexing TT and TTImp (and"
" other things)"
msgstr ""

#: ../../source/implementation/overview.rst:51
msgid "``Utils/`` -- some generally useful utilities"
msgstr ""

#: ../../source/implementation/overview.rst:52
msgid ""
"``Idris/`` -- anything relating to the high level language, translating "
"to TTImp"
msgstr ""

#: ../../source/implementation/overview.rst:54
msgid ""
"``Idris/Elab/`` -- High level construct elaboration machinery (e.g. "
"interfaces)"
msgstr ""

#: ../../source/implementation/overview.rst:56
msgid "``Compiler/`` -- back ends"
msgstr ""

#: ../../source/implementation/overview.rst:59
msgid "The Core Type, and Ref"
msgstr ""

#: ../../source/implementation/overview.rst:61
msgid ""
"``Core`` is a \"monad\" (not really, for efficiency reasons, at the "
"moment...) supporting ``Error``'s and ``IO`` (I did originally plan to "
"allow restricting this to some specific IO operations, but haven't yet)."
"  The raw syntax is defined by a type ``RawImp`` which has a source "
"location at each node, and any errors in elaboration note the location at"
" the point where the error occurred, as a file context ``FC``."
msgstr ""

#: ../../source/implementation/overview.rst:68
msgid ""
"``Ref`` is essentially an ``IORef``. Typically we pass them implicitly "
"and use labels to disambiguate which one we mean. See ``Core.Core`` for "
"their definition. Again, ``IORef`` is for efficiency - even if it would "
"be neater to use a state monad this turned out to be about 2-3 times "
"faster, so I'm going with the \"ugly\" choice..."
msgstr ""

#: ../../source/implementation/overview.rst:75
msgid "Term representation"
msgstr ""

#: ../../source/implementation/overview.rst:77
msgid ""
"Terms in the core language are indexed by a list of the names in scope, "
"most recently defined first:"
msgstr ""

#: ../../source/implementation/overview.rst:84
msgid ""
"This means that terms are always well scoped, and we can use the type "
"system to keep us right when manipulating names. For example, we have:"
msgstr ""

#: ../../source/implementation/overview.rst:92
msgid ""
"So local variables are represented by an index into the local context (a "
"de Bruijn index, ``idx``), and a proof, erased at run time, that the "
"index is valid. So everything is de Bruijn indexed, but the type checker "
"still keeps track of the indices so that we don't have to think too hard!"
msgstr ""

#: ../../source/implementation/overview.rst:97
msgid ""
"``Core.TT`` contains various handy tools for manipulating terms with "
"their indices, such as:"
msgstr ""

#: ../../source/implementation/overview.rst:108
msgid ""
"Note that the types are explicit about when the ``vars`` needs to be "
"passed at run time, and when it isn't. Mostly where it's needed it's to "
"help with displaying names, or name generation, rather than any "
"fundamental reason in the core. In general, this isn't expensive at run "
"time."
msgstr ""

#: ../../source/implementation/overview.rst:113
msgid "Environments, defined in ``Core.Env``, map local variables to binders:"
msgstr ""

#: ../../source/implementation/overview.rst:119
msgid ""
"A binders is typically a *lambda*, a *pi*, or a *let* (with a value), but"
" can also be a *pattern variable*. See the definition of ``TT`` for more "
"details. Where we have a term, we usually also need an ``Env``."
msgstr ""

#: ../../source/implementation/overview.rst:123
msgid ""
"We also have values, which are in head normal form, and defined in "
"``Core.Value``:"
msgstr ""

#: ../../source/implementation/overview.rst:130
msgid "We can convert a term to a value by normalising..."
msgstr ""

#: ../../source/implementation/overview.rst:137
msgid "...and back again, by quoting:"
msgstr ""

#: ../../source/implementation/overview.rst:144
msgid ""
"Both ``nf`` and ``quote`` are defined in ``Core.Normalise``. We don't "
"always know whether we'll need to work with ``NF`` or ``Term``, so we "
"also have a \"glued\" representation, ``Glued vars``, again defined in "
"``Core.Normalise``, which lazily computes either a ``NF`` or ``Term`` as "
"required. Elaborating a term returns the type as a ``Glued vars``."
msgstr ""

#: ../../source/implementation/overview.rst:150
msgid ""
"``Term`` separates ``Ref`` (global user defined names) from ``Meta``, "
"which are globally defined metavariables. For efficiency, metavariables "
"are only substituted into terms if they have non-0 multiplicity, to "
"preserve sharing as much as possible."
msgstr ""

#: ../../source/implementation/overview.rst:156
msgid "Unification"
msgstr ""

#: ../../source/implementation/overview.rst:157
msgid ""
"Unification is probably the most important part of the elaboration "
"process, and infers values for implicit arguments. That is, it finds "
"values for the things which are referred to by ``Meta`` in ``Term``. It "
"is defined in ``Core.Unify``, as the top level unification function has "
"the following type:"
msgstr ""

#: ../../source/implementation/overview.rst:174
msgid ""
"The ``Unify`` interface is there because it is convenient to be able to "
"define unification on ``Term`` and ``NF``, as well as ``Closure`` (which "
"is part of ``NF`` to represent unevaluated arguments to constructors)."
msgstr ""

#: ../../source/implementation/overview.rst:178
msgid ""
"This is one place where indexing over ``vars`` is extremely valuable: we "
"have to keep the environment consistent, so unification won't "
"accidentally introduce any scoping bugs!"
msgstr ""

#: ../../source/implementation/overview.rst:182
msgid ""
"Idris 2 implements pattern unification - see Adam Gundry's thesis for an "
"accessible introduction."
msgstr ""

#: ../../source/implementation/overview.rst:186
msgid "Context"
msgstr ""

#: ../../source/implementation/overview.rst:188
msgid ""
"``Core.Context`` defines all the things needed for TT. Most importantly: "
"``Def`` gives definitions of names (case trees, builtins, constructors "
"and holes, mostly); ``GlobalDef`` is a definition with all the other "
"information about it (type, visibility, totality, etc); ``Context`` is a "
"context mapping names to ``GlobalDef``, and ``Defs`` is the core data "
"structure with everything needed to typecheck more definitions."
msgstr ""

#: ../../source/implementation/overview.rst:195
msgid ""
"The main Context type stores definitions in an array, indexed by a "
"\"resolved name id\", an integer, for fast look up. This means that it "
"also needs to be able to convert between resolved names and full names. "
"The ``HasNames`` interface defines methods for going back and forth "
"between structures with human readable names, and structures with "
"resolved integer names."
msgstr ""

#: ../../source/implementation/overview.rst:201
msgid ""
"Since we store names in an array, all the lookup functions need to be in "
"the ``Core`` monad. This also turns out to help with loading checked "
"files (see below)."
msgstr ""

#: ../../source/implementation/overview.rst:206
msgid "Elaboration Overview"
msgstr ""

#: ../../source/implementation/overview.rst:208
msgid ""
"Elaboration of ``RawImp`` to ``TT`` is driven by ``TTImp.Elab``, with the"
" top level function for elaborating terms defined in ``TTImp.Elab.Term``,"
" support functions defined in ``TTImp.Elab.Check``, and elaborators for "
"the various TTImp constructs defined in separate files under "
"``TTImp.Elab.*``."
msgstr ""

#: ../../source/implementation/overview.rst:214
msgid "Laziness"
msgstr ""

#: ../../source/implementation/overview.rst:216
msgid ""
"Like Idris 1, laziness is marked in types using ``Lazy``, ``Delay`` and "
"``Force``, or ``Inf`` (instead of ``Lazy``) for codata. Unlike Idris 1, "
"these are language primitives rather than special purpose names."
msgstr ""

#: ../../source/implementation/overview.rst:220
msgid ""
"Implicit laziness resolution is handled during unification (in "
"``Core.Unify``). When unification is invoked (by ``convert`` in "
"``TTImp.Elab.Check``) with the ``withLazy`` flag set, it checks whether "
"it is converting a lazy type with a non-lazy type. If so, it continues "
"with unification, but returning that either a ``Force`` or ``Delay`` "
"needs inserting as appropriate."
msgstr ""

#: ../../source/implementation/overview.rst:227
msgid "TTC format"
msgstr ""

#: ../../source/implementation/overview.rst:229
msgid ""
"We can save things to binary if we have an implementation of the TTC "
"interface for it. See ``Utils.Binary`` to see how this is done. It uses a"
" global reference ``Ref Bin Binary`` which uses ``Data.Buffer`` "
"underneath."
msgstr ""

#: ../../source/implementation/overview.rst:233
msgid ""
"When we load checked TTC files, we don't process the definitions "
"immediately, but rather store them as a ``ContextEntry``, which is either"
" a ``Binary`` blob, or a processed definition. We only process the "
"definitions the first time they are looked up, since converting Binary to"
" the definition is fairly costly (due to having to construct a lot of AST"
" nodes), and often definitions in an imported file are never used."
msgstr ""

#: ../../source/implementation/overview.rst:241
msgid "Bound Implicits"
msgstr ""

#: ../../source/implementation/overview.rst:243
msgid ""
"The ``RawImp`` type has a constructor ``IBindVar``. The first time we "
"encounter an ``IBindVar``, we record the name as one which will be "
"implicitly bound. At the end of elaboration, we decide which holes should"
" turn into bound variables (Pi bound in types, Pattern bound on a LHS, "
"still holes on the RHS) by looking at the list of names bound as "
"``IBindVar``, the things they depend on, and sorting them so that they "
"are bound in dependency order. This happens in "
"``TTImp.Implicit.getToBind``."
msgstr ""

#: ../../source/implementation/overview.rst:251
msgid ""
"Once we know what the bound implicits need to be, we bind them in "
"``bindImplicits``. Any application of a hole which stands for a bound "
"implicit gets turned into a local binding (either Pi or Pat as "
"appropriate, or PLet for @-patterns)."
msgstr ""

#: ../../source/implementation/overview.rst:257
msgid "Unbound Implicits"
msgstr ""

#: ../../source/implementation/overview.rst:259
msgid ""
"Any name beginning with a lower case letter is considered an unbound "
"implicit. They are elaborated as holes, which may depend on the initial "
"environment of the elaboration, and after elaboration they are converted "
"to an implicit pi binding, with multiplicity 0. So, for example:"
msgstr ""

#: ../../source/implementation/overview.rst:268
msgid "becomes:"
msgstr ""

#: ../../source/implementation/overview.rst:274
msgid ""
"Bindings are ordered according to dependency. It'll infer any additional "
"names, e.g. in:"
msgstr ""

#: ../../source/implementation/overview.rst:281
msgid ""
"... where ``xs`` is a ``Vect n a``, it infers bindings for ``n`` and "
"``a``."
msgstr ""

#: ../../source/implementation/overview.rst:283
#, python-format
msgid ""
"The ``%unbound_implicits`` directive means that it will no longer "
"automatically bind names (that is, ``a`` and ``b`` in ``map`` above) but "
"it will still infer the types for any additional names, e.g. if you "
"write:"
msgstr ""

#: ../../source/implementation/overview.rst:291
msgid ""
"... it will still infer a type for ``xs`` and infer bindings for ``n`` "
"and ``a``."
msgstr ""

#: ../../source/implementation/overview.rst:295
msgid "Implicit arguments"
msgstr ""

#: ../../source/implementation/overview.rst:297
msgid ""
"When we encounter an implicit argument (``_`` in the raw syntax, or added"
" when we elaborate an application and see that there is an implicit "
"needed) we make a new hole which is a fresh name applied to the current "
"environment, and return that as the elaborated term. This happens in "
"``TTImp.Elab.Check``, with the function ``metaVar``.  If there's enough "
"information elsewhere we'll find the definition of the hole by "
"unification."
msgstr ""

#: ../../source/implementation/overview.rst:304
msgid ""
"We never substitute holes in a term during elaboration and rely on "
"normalisation if we need to look inside it. If there are holes remaining "
"after elaboration of a definition, report an error (it's okay for a hole "
"in a type as long as it's resolved by the time the definition is done)."
msgstr ""

#: ../../source/implementation/overview.rst:309
msgid ""
"See ``Elab.App.makeImplicit``, ``Elab.App.makeAutoImplicit`` to see where"
" we add holes for the implicit arguments in applications."
msgstr ""

#: ../../source/implementation/overview.rst:312
msgid ""
"``Elab.App`` does quite a lot of tricky stuff! In an attempt to help with"
" resolving ambiguous names and record updates, it will sometimes delay "
"elaboration of an argument (see ``App.checkRestApp``) so that it can get "
"more information about its type first."
msgstr ""

#: ../../source/implementation/overview.rst:317
msgid ""
"``Core.Unify.solveConstraints`` revisits all of the currently unsolved "
"holes and constrained definitions, and tries again to unify any "
"constraints which they require. It also tries to resolve anything defined"
" by proof search. The current state of unification is defined in "
"``Core.UnifyState``, and unification constraints record which "
"metavariables are blocking them. This improves performance, since we'll "
"only retry a constraint if one of the blocking metavariables has been "
"resolved."
msgstr ""

#: ../../source/implementation/overview.rst:326
msgid "Additional type inference"
msgstr ""

#: ../../source/implementation/overview.rst:328
msgid ""
"A ``?`` in a type means \"infer this part of the type\".  This is "
"distinct from ``_`` in types, which means \"I don't care what this is\". "
"The distinction is in what happens when inference fails.  If inference "
"fails for ``_``, we implicitly bind a new name (just like pattern "
"matching on the lhs - i.e. it means match anything). If inference fails "
"for ``?``, we leave it as a hole and try to fill it in later. As a "
"result, we can say:"
msgstr ""

#: ../../source/implementation/overview.rst:340
msgid "... and the ``?`` will be inferred to be 4. But if we say:"
msgstr ""

#: ../../source/implementation/overview.rst:347
msgid ""
"... we'll get an error, because the ``_`` has been bound as a new name. "
"Both ``?`` and ``_`` are represented in ``RawImp`` by the ``Implicit`` "
"constructor, which has a boolean flag meaning \"bind if unresolved\"."
msgstr ""

#: ../../source/implementation/overview.rst:351
msgid ""
"So the meaning of ``_`` is now consistent on the lhs and in types (i.e. "
"it means infer a value and bind a variable on failure to infer anything)."
" In practice, using ``_`` will get you the old Idris behaviour, but ``?``"
" might get you a bit more type inference."
msgstr ""

#: ../../source/implementation/overview.rst:357
msgid "Auto Implicits"
msgstr ""

#: ../../source/implementation/overview.rst:359
msgid ""
"Auto implicits are resolved by proof search, and can be given explicit "
"arguments in the same way as ordinary implicits: i.e. ``{x = exp}`` to "
"give ``exp`` as the value for auto implicit ``x``. Interfaces are "
"syntactic sugar for auto implicits (it is the same resolution mechanism -"
" interfaces translate into records, and implementations translate into "
"hints for the search)."
msgstr ""

#: ../../source/implementation/overview.rst:365
msgid ""
"The argument syntax ``@{exp}`` means that the value of the next auto "
"implicit in the application should be ``exp`` - this is the same as the "
"syntax for invoking named implementations in Idris 1, but interfaces and "
"auto implicits have been combined now."
msgstr ""

#: ../../source/implementation/overview.rst:370
msgid ""
"Implicit search is defined in ``Core.AutoSearch``. It will only begin a "
"search if all the *determining arguments* of the goal are defined, "
"meaning that they don't contain *any* holes. This avoids committing too "
"early to the solution of a hole by resolving it by search, rather than "
"unification, unless a programmer has explicitly said (via a ``search`` "
"option on a data type) that that's what they want."
msgstr ""

#: ../../source/implementation/overview.rst:378
msgid "Dot Patterns"
msgstr ""

#: ../../source/implementation/overview.rst:380
msgid ""
"``IMustUnify`` is a constructor of ``RawImp``. When we elaborate this, we"
" generate a hole, then elaborate the term, and add a constraint that the "
"generated hole must unify with the term which was explicitly given (in "
"``UnifyState.addDot``), without resolving any holes. This is finally "
"checked in ``UnifyState.checkDots``."
msgstr ""

#: ../../source/implementation/overview.rst:386
msgid "Proof Search"
msgstr ""

#: ../../source/implementation/overview.rst:388
msgid ""
"A definition constructed with ``Core.Context.BySearch`` is a hole which "
"will be resolved by searching for something which fits the type. This "
"happens in ``Core.AutoSearch``. It checks all possible hints for a term, "
"to ensure that only one is possible."
msgstr ""

#: ../../source/implementation/overview.rst:394
msgid "@-Patterns"
msgstr ""

#: ../../source/implementation/overview.rst:396
msgid ""
"Names which are bound in types are also bound as @-patterns, meaning that"
" functions have access to them. For example, we can say:"
msgstr ""

#: ../../source/implementation/overview.rst:405
msgid ""
"As patterns are implemented as a constructor of ``TT``, which makes a lot"
" of things more convenient (especially case tree compilation)."
msgstr ""

#: ../../source/implementation/overview.rst:409
msgid "Linear Types"
msgstr ""

#: ../../source/implementation/overview.rst:411
msgid ""
"Following Conor McBride and Bob Atkey's work, all binders have a "
"multiplicity annotation (``RigCount``). After elaboration in "
"``TTImp.Elab``, we do a separate linearity check which: a) makes sure "
"that linear variables are used exactly once; b) updates hole types to "
"properly reflect usage information."
msgstr ""

#: ../../source/implementation/overview.rst:417
msgid "Local definitions"
msgstr ""

#: ../../source/implementation/overview.rst:419
msgid ""
"We elaborate relative to an environment, meaning that we can elaborate "
"local function definitions. We keep track of the names being defined in a"
" nested block of declarations, and ensure that they are lifted to top "
"level definitions in TT by applying them to every name in scope."
msgstr ""

#: ../../source/implementation/overview.rst:424
msgid ""
"Since we don't know how many times a local definition will be applied, in"
" general, anything bound with multiplicity 1 is passed to the local "
"definition with multiplicity 0, so if you want to use it in a local "
"definition, you need to pass it explicitly."
msgstr ""

#: ../../source/implementation/overview.rst:430
msgid "Case blocks"
msgstr ""

#: ../../source/implementation/overview.rst:432
msgid ""
"Similar to local definitions, these are lifted to top level definitions "
"which represent the case block, which is immediately applied to the "
"scrutinee of the case. We don't attempt to calculate the multiplicities "
"of arguments when elaborating the case block, since we'll probably get it"
" wrong - instead, these are checked during linearity checking, which "
"knows about case functions."
msgstr ""

#: ../../source/implementation/overview.rst:438
msgid ""
"Case blocks in the scope of local definitions are tricky, because the "
"names need to match up, and the types might be refined, but we also still"
" need to apply the local names to the scope in which they were defined. "
"This is a bit fiddly, and dealt with by the ``ICaseLocal`` constructor of"
" ``RawImp``."
msgstr ""

#: ../../source/implementation/overview.rst:443
msgid ""
"Various parts of the system treat case blocks specially, even though they"
" aren't strictly part of the core. In particular, these are linearity "
"checking and totality checking."
msgstr ""

#: ../../source/implementation/overview.rst:448
msgid "Parameters"
msgstr ""

#: ../../source/implementation/overview.rst:450
msgid ""
"The parameters to a data type are taken to be the arguments which appear,"
" unchanged, in the same position, everywhere across a data definition."
msgstr ""

#: ../../source/implementation/overview.rst:454
msgid "Erasure"
msgstr ""

#: ../../source/implementation/overview.rst:456
msgid ""
"Unbound implicits are given ``0`` multiplicity, so the rule is now that "
"if you don't explicitly write it in the type of a function or "
"constructor, the argument is erased at run time."
msgstr ""

#: ../../source/implementation/overview.rst:460
msgid ""
"Elaboration and the case tree compiler check ensure that 0-multiplicity "
"arguments are not inspected in case trees. In the compiler, "
"0-multiplicity arguments to constructors are erased completely, whereas "
"0-multiplicity arguments to functions are replaced with a placeholder "
"erased value."
msgstr ""

#: ../../source/implementation/overview.rst:466
msgid "Namespaces and name visibility"
msgstr ""

#: ../../source/implementation/overview.rst:468
msgid ""
"Same rules mostly apply as in Idris 1. The difference is that visibility "
"is *per namespace* not *per file* (that is, files have no relevance other"
" except in that they introduce their own namespace, and in that they "
"allow separate typechecking)."
msgstr ""

#: ../../source/implementation/overview.rst:473
msgid ""
"One effect of this is that when a file defines nested namespaces, the "
"inner namespace can see what's in the outer namespace, but not vice versa"
" unless names defined in the inner namespace are explicitly exported. The"
" visibility modifiers ``export``, ``public export``, and ``private`` "
"control whether the name can be seen in any other namespace, and it's "
"nothing to do with the file they're defined in at all."
msgstr ""

#: ../../source/implementation/overview.rst:480
msgid ""
"Unlike Idris 1, there is no restriction on whether public definitions can"
" refer to private names. The only restriction on ``private`` names is "
"that they can't be referred to directly (i.e. in code) outside the "
"namespace."
msgstr ""

#: ../../source/implementation/overview.rst:485
msgid "Records"
msgstr ""

#: ../../source/implementation/overview.rst:487
msgid ""
"Records are part of TTImp (rather than the surface language). Elaborating"
" a record declaration creates a data type and associated projection "
"functions. Record setters are generated on demand while elaborating TTImp"
" (in ``TTImp.Elab.Record``). Setters are translated directly to ``case`` "
"blocks, which means that update of dependent fields works as one might "
"expect (i.e. it's safe as long as all of the fields are updated at the "
"same time consistently)."
msgstr ""

