# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 09:10+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/proofs/inductive.rst:5 b3c46947feb64ca8a491e9688430f42b
msgid "Inductive Proofs"
msgstr ""

#: ../../source/proofs/inductive.rst:7 4fcc486c77e44477ba2a03cb8aa3b8cd
msgid ""
"Before embarking on proving ``plus_commutes`` in Idris itself, let us "
"consider the overall structure of a proof of some property of natural "
"numbers. Recall that they are defined recursively, as follows:"
msgstr ""

#: ../../source/proofs/inductive.rst:17 b6ebd93e7f9f4167923cef8171ab8d78
msgid ""
"A *total* function over natural numbers must both terminate, and cover "
"all possible inputs. Idris checks functions for totality by checking that"
" all inputs are covered, and that all recursive calls are on "
"*structurally smaller* values (so recursion will always reach a base "
"case). Recalling ``plus``:"
msgstr ""

#: ../../source/proofs/inductive.rst:29 7151eb0711f14c12aa24a1728cf37f88
msgid ""
"This is total because it covers all possible inputs (the first argument "
"can only be ``Z`` or ``S k`` for some ``k``, and the second argument "
"``m`` covers all possible ``Nat``) and in the recursive call, ``k`` is "
"structurally smaller than ``S k`` so the first argument will always reach"
" the base case ``Z`` in any sequence of recursive calls."
msgstr ""

#: ../../source/proofs/inductive.rst:35 d347eba0eaa442ed860f9ec0f59e436e
msgid ""
"In some sense, this resembles a mathematical proof by induction (and this"
" is no coincidence!). For some property ``P`` of a natural number ``x``, "
"we can show that ``P`` holds for all ``x`` if:"
msgstr ""

#: ../../source/proofs/inductive.rst:39 db87aa96bbd646fe82ab320b82e38dee
msgid "``P`` holds for zero (the base case)."
msgstr ""

#: ../../source/proofs/inductive.rst:41 b9c430b33b174ab5a14b863769bc4bbf
msgid ""
"Assuming that ``P`` holds for ``k``, we can show ``P`` also holds for ``S"
" k`` (the inductive step)."
msgstr ""

#: ../../source/proofs/inductive.rst:44 562c101d8892419484775cb59b1cd989
msgid ""
"In ``plus``, the property we are trying to show is somewhat trivial (for "
"all natural numbers ``x``, there is a ``Nat`` which need not have any "
"relation to ``x``). However, it still takes the form of a base case and "
"an inductive step. In the base case, we show that there is a ``Nat`` "
"arising from ``plus n m`` when ``n = Z``, and in the inductive step we "
"show that there is a ``Nat`` arising when ``n = S k`` and we know we can "
"get a ``Nat`` inductively from ``plus k m``. We could even write a "
"function capturing all such inductive definitions:"
msgstr ""

#: ../../source/proofs/inductive.rst:64 0ec11ea1e6aa46e8ac4d8f45b48f2581
msgid ""
"Using ``nat_induction``, we can implement an equivalent inductive version"
" of ``plus``:"
msgstr ""

#: ../../source/proofs/inductive.rst:77 e22dfe4dc9de466891fbb950b9141e19
msgid ""
"To prove that ``plus n m = plus m n`` for all natural numbers ``n`` and "
"``m``, we can also use induction. Either we can fix ``m`` and perform "
"induction on ``n``, or vice versa. We can sketch an outline of a proof; "
"performing induction on ``n``, we have:"
msgstr ""

#: ../../source/proofs/inductive.rst:82 bd2c2eedaa72495ea1ae0f72c2a21f5c
msgid "Property ``prop`` is ``\\x => plus x m = plus m x``."
msgstr ""

#: ../../source/proofs/inductive.rst:84 62fe86f1d9b545fe91828c73c76db368
msgid "Show that ``prop`` holds in the base case and inductive step:"
msgstr ""

#: ../../source/proofs/inductive.rst c617e1963c3f47aba557fc71ba513370
msgid "Base case: ``prop Z``, i.e."
msgstr ""

#: ../../source/proofs/inductive.rst ef52b420771d446f8179d660c5f8d862
msgid "``plus Z m = plus m Z``, which reduces to"
msgstr ""

#: ../../source/proofs/inductive.rst f1b8f62a90004f22907ae00cfcc26061
msgid "``m = plus m Z`` due to the definition of ``plus``."
msgstr ""

#: ../../source/proofs/inductive.rst 7d8330fa5905468e83653859e2ff40c4
msgid ""
"Inductive step: Inductively, we know that ``prop k`` holds for a "
"specific, fixed ``k``, i.e."
msgstr ""

#: ../../source/proofs/inductive.rst 6035d96d742d4b808ed5f73e94a21958
msgid ""
"``plus k m = plus m k`` (the induction hypothesis). Given this, show "
"``prop (S k)``, i.e."
msgstr ""

#: ../../source/proofs/inductive.rst eb99487ba7ac43eab4664bfad46674b3
msgid "``plus (S k) m = plus m (S k)``, which reduces to"
msgstr ""

#: ../../source/proofs/inductive.rst 273c440c38a04d38bc1a2eb4b94395a0
msgid ""
"``S (plus k m) = plus m (S k)``. From the induction hypothesis, we can "
"rewrite this to"
msgstr ""

#: ../../source/proofs/inductive.rst ad98f3790e264639ab5ae293cddb67af
msgid "``S (plus m k) = plus m (S k)``."
msgstr ""

#: ../../source/proofs/inductive.rst:96 80ff80a64cea45128cda3d804399e2db
msgid ""
"To complete the proof we therefore need to show that ``m = plus m Z`` for"
" all natural numbers ``m``, and that ``S (plus m k) = plus m (S k)`` for "
"all natural numbers ``m`` and ``k``. Each of these can also be proved by "
"induction, this time on ``m``."
msgstr ""

#: ../../source/proofs/inductive.rst:101 dcbb53ec79704bd68dc6566c35e9ef1f
msgid ""
"We are now ready to embark on a proof of commutativity of ``plus`` "
"formally in Idris."
msgstr ""

