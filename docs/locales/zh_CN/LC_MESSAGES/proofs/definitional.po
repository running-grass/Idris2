# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 09:10+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/proofs/definitional.rst:1 225f2e7ca5574732828c4c87f4de074d
msgid ""
"Before we discuss the details of theorem proving in Idris, we will "
"describe some fundamental concepts:"
msgstr ""

#: ../../source/proofs/definitional.rst:4 c52616a18fa54db7b1dca960d2071ab2
msgid "Propositions and judgments"
msgstr ""

#: ../../source/proofs/definitional.rst:5 fa7acee9334a436f97430f16bcfabfc1
msgid "Boolean and constructive logic"
msgstr ""

#: ../../source/proofs/definitional.rst:6
#: ../../source/proofs/definitional.rst:57 44cc6936aba144dca8103da65cf61260
#: e01a6d6b4eb645de913bfd344470df51
msgid "Curry-Howard correspondence"
msgstr ""

#: ../../source/proofs/definitional.rst:7 582b823a7ee14d8b92a672ffc5356f05
msgid "Definitional and propositional equalities"
msgstr ""

#: ../../source/proofs/definitional.rst:8 065e88c1e6fc4921b63f233209062e9a
msgid "Axiomatic and constructive approaches"
msgstr ""

#: ../../source/proofs/definitional.rst:11 a03d4c9ea89a4fabba49b822ac2937eb
msgid "Propositions and Judgments"
msgstr ""

#: ../../source/proofs/definitional.rst:13 81d15fd7ac304c079695ea6901b0b571
msgid ""
"Propositions are the subject of our proofs. Before the proof, we can't "
"formally say if they are true or not. If the proof is successful then the"
" result is a 'judgment'.  For instance, if the ``proposition`` is,"
msgstr ""

#: ../../source/proofs/definitional.rst:18 5601193929bb496ca9858b05b1e43d76
msgid "1+1=2"
msgstr ""

#: ../../source/proofs/definitional.rst:21 b181c535eb834a57a1da97ddcf463ffd
msgid "When we prove it, the ``judgment`` is,"
msgstr ""

#: ../../source/proofs/definitional.rst:24 9f1eb9af56bb47039ceb334e540f8d2a
msgid "1+1=2 true"
msgstr ""

#: ../../source/proofs/definitional.rst:27 7a8a2fab8e2846908d2170fc0f9bcba5
msgid "Or if the ``proposition`` is,"
msgstr ""

#: ../../source/proofs/definitional.rst:30 a71eb6021a91441ab0e8f6e4b9ae1514
msgid "1+1=3"
msgstr ""

#: ../../source/proofs/definitional.rst:33 2b402774a3bf472db6afb8a2d36d099f
msgid ""
"we can't prove it is true, but it is still a valid proposition and "
"perhaps we can prove it is false so the ``judgment`` is,"
msgstr ""

#: ../../source/proofs/definitional.rst:37 6f602a01041647d19163928ad181e8f5
msgid "1+1=3 false"
msgstr ""

#: ../../source/proofs/definitional.rst:40 84c5336a343140b883583a8f923a503d
msgid ""
"This may seem a bit pedantic but it is important to be careful: in "
"mathematics not every proposition is true or false. For instance, a "
"proposition may be unproven or even unprovable."
msgstr ""

#: ../../source/proofs/definitional.rst:44 974452efbb144bfdb947ab0a13faec4d
msgid ""
"So the logic here is different from the logic that comes from boolean "
"algebra. In that case what is not true is false and what is not false is "
"true. The logic we are using here does not have this law, the \"Law of "
"Excluded Middle\", so we cannot use it."
msgstr ""

#: ../../source/proofs/definitional.rst:49 2c6ed25995bd48108cc748d1096f782a
msgid ""
"A false proposition is taken to be a contradiction and if we have a "
"contradiction then we can prove anything, so we need to avoid this. Some "
"languages, used in proof assistants, prevent contradictions."
msgstr ""

#: ../../source/proofs/definitional.rst:53 bf8b48e3478b44cdb491fa5c9fa9a584
msgid ""
"The logic we are using is called constructive (or sometimes intuitional) "
"because we are constructing a 'database' of judgments."
msgstr ""

#: ../../source/proofs/definitional.rst:59 215c88e05a8443c99111738b2a3c7895
msgid ""
"So how do we relate these proofs to Idris programs? It turns out that "
"there is a correspondence between constructive logic and type theory. "
"They have the same structure and we can switch back and forth between the"
" two notations."
msgstr ""

#: ../../source/proofs/definitional.rst:63 6bace47ff1ab400ba34a16019b4cca29
msgid "The way that this works is that a proposition is a type so..."
msgstr ""

#: ../../source/proofs/definitional.rst:73 c8fe41956d3e4fcfbccb1036832063c1
msgid ""
"...is a proposition and it is also a type. The following will also "
"produce an equality type:"
msgstr ""

#: ../../source/proofs/definitional.rst:82 b383a3cfa79b4514b8c3cbd6f461b865
msgid ""
"Both of these are valid propositions so both are valid equality types. "
"But how do we represent a true judgment? That is, how do we denote 1+1=2 "
"is true but not 1+1=3?  A type that is true is inhabited, that is, it can"
" be constructed. An equality type has only one constructor 'Refl' so a "
"proof of 1+1=2 is"
msgstr ""

#: ../../source/proofs/definitional.rst:92 005e6d49d49d4113bf25d9307476541e
msgid ""
"Now that we can represent propositions as types other aspects of "
"propositional logic can also be translated to types as follows:"
msgstr ""

#: ../../source/proofs/definitional.rst:96 a15916c3628c4a0fa8195ca04b1593cb
msgid "propositions"
msgstr ""

#: ../../source/proofs/definitional.rst:96 52929ba26b074821931261bba3877aa7
msgid "example of possible type"
msgstr ""

#: ../../source/proofs/definitional.rst:98 95332fc9acfb40b0bf79770d3f5625d6
msgid "A"
msgstr ""

#: ../../source/proofs/definitional.rst:98 c4b611be1ce942d9a751687c407edabf
msgid "x=y"
msgstr ""

#: ../../source/proofs/definitional.rst:100 09966a9ede774553b19e2d8a69ef60af
msgid "B"
msgstr ""

#: ../../source/proofs/definitional.rst:100
#: ../../source/proofs/definitional.rst:108
#: ../../source/proofs/definitional.rst:110 af35d9de11394b7c938117c1e18afa26
#: ccca735d08614d5bbd703209436ed886 ea8bde7860ba4814bc96e7bf6435263c
msgid "y=z"
msgstr ""

#: ../../source/proofs/definitional.rst:102 6a62857694e147deb7af27a5db78aa35
msgid "and"
msgstr ""

#: ../../source/proofs/definitional.rst:102 0319445486db43849b615cd1e73e1281
msgid "A /\\\\ B"
msgstr ""

#: ../../source/proofs/definitional.rst:102 1425167b198442918488b0137e654f5e
msgid "Pair(x=y,y=z)"
msgstr ""

#: ../../source/proofs/definitional.rst:104 cc2b58004acc4635a4bd8d67e6415491
msgid "or"
msgstr ""

#: ../../source/proofs/definitional.rst:104 b7b8545c62f34fa0a0f43d4e801aeb91
msgid "A \\\\/ B"
msgstr ""

#: ../../source/proofs/definitional.rst:104 98e6475bb49b44fabe68404199e1e217
msgid "Either(x=y,y=z)"
msgstr ""

#: ../../source/proofs/definitional.rst:106 4557b39fba0b4334b70ff370c2ea9f1c
msgid "implies"
msgstr ""

#: ../../source/proofs/definitional.rst:106 33ccdc6b3b4e430c93af9d8addf9c092
msgid "A -> B"
msgstr ""

#: ../../source/proofs/definitional.rst:106 17913f0e3fe7487f99bd4d785eb0e3c3
msgid "(x=y) -> (y=z)"
msgstr ""

#: ../../source/proofs/definitional.rst:108 cf31f4a016ae45daae7636b05a2f605b
msgid "for all"
msgstr ""

#: ../../source/proofs/definitional.rst:110 af13358a66fc4b758b1168fdfdac81d3
msgid "exists"
msgstr ""

#: ../../source/proofs/definitional.rst:115 7bbc07e70d204721b1084ad18fa92d8e
msgid "And (conjunction)"
msgstr ""

#: ../../source/proofs/definitional.rst:117 8c60fd9714df45648e766d407edc090e
msgid "We can have a type which corresponds to conjunction:"
msgstr ""

#: ../../source/proofs/definitional.rst:123 4f722ea4d8ff45af8235b8d67be3efd4
msgid "There is a built in type called 'Pair'."
msgstr ""

#: ../../source/proofs/definitional.rst:126 de4e222172a84ad8853dc56f1cae0b00
msgid "Or (disjunction)"
msgstr ""

#: ../../source/proofs/definitional.rst:128 27bddea6e58d4059acbad370b15247d1
msgid "We can have a type which corresponds to disjunction:"
msgstr ""

#: ../../source/proofs/definitional.rst:136 af8ece2a729a4fdfa4d98ff1a1647c21
msgid "There is a built in type called 'Either'."
msgstr ""

#: ../../source/proofs/definitional.rst:139 3061d6721f294fc9b894db29a26c6308
msgid "Definitional and Propositional Equalities"
msgstr ""

#: ../../source/proofs/definitional.rst:141 260dd6e5d5d24e9ea1c1789ac2c48c5e
msgid ""
"We have seen that  we can 'prove' a type by finding a way to construct a "
"term. In the case of equality types there is only one constructor which "
"is ``Refl``. We have also seen that each side of the equation does not "
"have to be identical like '2=2'. It is enough that both sides are "
"*definitionally equal* like this:"
msgstr ""

#: ../../source/proofs/definitional.rst:151 4280315d0c5547bd94d3a4a9c896d5e1
msgid ""
"Both sides of this equation normalise to 2 and so Refl matches and the "
"proposition is proved."
msgstr ""

#: ../../source/proofs/definitional.rst:154 ed615642a4ec451a9d43e5ff851fb53a
msgid ""
"We don't have to stick to terms; we can also use symbolic parameters so "
"the following type checks:"
msgstr ""

#: ../../source/proofs/definitional.rst:162 e9d590c86fbe45a7b249227975bb73ff
msgid ""
"If a proposition/equality type is not definitionally equal but is still "
"true then it is *propositionally equal*. In this case we may still be "
"able to prove it but some steps in the proof may require us to add "
"something into the terms or at least to take some sideways steps to get "
"to a proof."
msgstr ""

#: ../../source/proofs/definitional.rst:167 b5ae500a0abc44e4ad124cd3686bea53
msgid ""
"Especially when working with equalities containing variable terms (inside"
" functions) it can be hard to know which equality types are "
"definitionally equal, in this example ``plusReducesL`` is *definitionally"
" equal* but ``plusReducesR`` is not (although it is *propositionally "
"equal*). The only difference between them is the order of the operands."
msgstr ""

#: ../../source/proofs/definitional.rst:181 a31751245647435fb342ab723240e2ce
msgid "Checking ``plusReducesR`` gives the following error:"
msgstr ""

#: ../../source/proofs/definitional.rst:192 61583a85a88c42be9b31cd44a7bd45ee
msgid "So why is ``Refl`` able to prove some equality types but not others?"
msgstr ""

#: ../../source/proofs/definitional.rst:194 14f071d45d0a426c8351004716f6d1a6
msgid ""
"The first answer is that ``plus`` is defined by recursion on its first "
"argument. So, when the first argument is ``Z``, it reduces, but not when "
"the second argument is ``Z``."
msgstr ""

#: ../../source/proofs/definitional.rst:198 65504f57508f41458d1b524dc0ec5daf
msgid ""
"If an equality type can be proved/constructed by using ``Refl`` alone it "
"is known as a *definitional equality*. In order to be definitionally "
"equal both sides of the equation must normalise to the same value."
msgstr ""

#: ../../source/proofs/definitional.rst:202 a315c81073394c64942bd735f9abc828
msgid ""
"So when we type ``1+1`` in Idris it is immediately reduced to 2 because "
"definitional equality is built in"
msgstr ""

#: ../../source/proofs/definitional.rst:210 a3e334dae53e481ab539b8e36f9b918d
msgid "In the following pages we discuss how to resolve propositional equalities."
msgstr ""

