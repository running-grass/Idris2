# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 11:10+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/proofs/patterns.rst:3 8b8ff3f370874c20a8b62c81cd35f040
msgid "Pattern Matching Proofs"
msgstr ""

#: ../../source/proofs/patterns.rst:5 d27f279a47f247108ee855911a6ecaff
msgid ""
"In this section, we will provide a proof of ``plus_commutes`` directly, "
"by writing a pattern matching definition. We will use interactive editing"
" features extensively, since it is significantly easier to produce a "
"proof when the machine can give the types of intermediate values and "
"construct components of the proof itself. The commands we will use are "
"summarised below. Where we refer to commands directly, we will use the "
"Vim version, but these commands have a direct mapping to Emacs commands."
msgstr ""

#: ../../source/proofs/patterns.rst:15 3be057dc56024b42bc23cff17ebc5c03
msgid "Command"
msgstr ""

#: ../../source/proofs/patterns.rst:15 6750469e23134d8aaae87a6cb4c46597
msgid "Vim binding"
msgstr ""

#: ../../source/proofs/patterns.rst:15 c2f3533c1d934e7e9f5646c824b8458e
msgid "Emacs binding"
msgstr ""

#: ../../source/proofs/patterns.rst:15 65382e70365449e5933f3b965f98b88a
msgid "Explanation"
msgstr ""

#: ../../source/proofs/patterns.rst:17 618b6326473449e795033365eb61659c
msgid "Check type"
msgstr ""

#: ../../source/proofs/patterns.rst:17 603fb77cc9d84de08cfbd372688b370f
msgid "``\\t``"
msgstr ""

#: ../../source/proofs/patterns.rst:17 5fd4c1a0fb134f14b7d87ba64f04767e
msgid "``C-c C-t``"
msgstr ""

#: ../../source/proofs/patterns.rst:17 b2fe48aee47845c2a7b3bed2720d7eb3
msgid "Show type of identifier or hole under the cursor."
msgstr ""

#: ../../source/proofs/patterns.rst:19 57c40841d85a443cb632bec1cb369d0b
msgid "Proof search"
msgstr ""

#: ../../source/proofs/patterns.rst:19 eab064d5a8af42719aceb0808076db89
msgid "``\\s``"
msgstr ""

#: ../../source/proofs/patterns.rst:19 b87603cf002d4a3cb04b7953e72215e4
msgid "``C-c C-a``"
msgstr ""

#: ../../source/proofs/patterns.rst:19 8cd3ed23a22640e7801036e14bc1e582
msgid "Attempt to solve hole under the cursor by applying simple proof search."
msgstr ""

#: ../../source/proofs/patterns.rst:21 d4d3b8ecbba64c3d9739576069618229
msgid "Make new definition"
msgstr ""

#: ../../source/proofs/patterns.rst:21 3c2d0f106b604cac9b27ae0508a43958
msgid "``\\a``"
msgstr ""

#: ../../source/proofs/patterns.rst:21 b73574546c3b4556bdf925147f349f31
msgid "``C-c C-s``"
msgstr ""

#: ../../source/proofs/patterns.rst:21 5f206af318cc4936b05867a3e023e5c1
msgid "Add a template definition for the type defined under the cursor."
msgstr ""

#: ../../source/proofs/patterns.rst:23 7e2b2efd87e74322b7d6bf8c1b6a7256
msgid "Make lemma"
msgstr ""

#: ../../source/proofs/patterns.rst:23 c88b734a18544d3786bbb31929ff3afc
msgid "``\\l``"
msgstr ""

#: ../../source/proofs/patterns.rst:23 82996366c9fc4b21ac9750ca3f929267
msgid "``C-c C-e``"
msgstr ""

#: ../../source/proofs/patterns.rst:23 32e9fb88410345a184a3690861976148
msgid ""
"Add a top level function with a type which solves the hole under the "
"cursor."
msgstr ""

#: ../../source/proofs/patterns.rst:25 a43f6c27a7c345d7ab89e50df5e93a1f
msgid "Split cases"
msgstr ""

#: ../../source/proofs/patterns.rst:25 3c01897cd2954f1c8627fff91b9637bd
msgid "``\\c``"
msgstr ""

#: ../../source/proofs/patterns.rst:25 b1f0d9a2beff448984ecefac059d5f6d
msgid "``C-c C-c``"
msgstr ""

#: ../../source/proofs/patterns.rst:25 9eb7fb8387114e41ab19707279de83a4
msgid ""
"Create new constructor patterns for each possible case of the variable "
"under the cursor."
msgstr ""

#: ../../source/proofs/patterns.rst:30 46b53b9a6f714184bc55fe874ac841bd
msgid "Creating a Definition"
msgstr ""

#: ../../source/proofs/patterns.rst:32 238ee1488a1644cf8b0067e8d4b20961
msgid ""
"To begin, create a file ``pluscomm.idr`` containing the following type "
"declaration:"
msgstr ""

#: ../../source/proofs/patterns.rst:39 052a75666dc44ef3b302aef444ae07ae
msgid ""
"To create a template definition for the proof, press ``\\a`` (or the "
"equivalent in your editor of choice) on the line with the type "
"declaration. You should see:"
msgstr ""

#: ../../source/proofs/patterns.rst:48 3ddd2b1198644114ad3801f5bc10bbc3
msgid ""
"To prove this by induction on ``n``, as we sketched in Section :ref"
":`sect-inductive`, we begin with a case split on ``n`` (press ``\\c`` "
"with the cursor over the ``n`` in the definition.) You should see:"
msgstr ""

#: ../../source/proofs/patterns.rst:59 9eed9edf65bb4a269690ecff22459cd1
msgid ""
"If we inspect the types of the newly created holes, "
"``plus_commutes_rhs_1`` and ``plus_commutes_rhs_2``, we see that the type"
" of each reflects that ``n`` has been refined to ``Z`` and ``S k`` in "
"each respective case. Pressing ``\\t`` over ``plus_commutes_rhs_1`` "
"shows:"
msgstr ""

#: ../../source/proofs/patterns.rst:71 5ff552709fd148d38d2a0e37c10203f3
msgid "Similarly, for ``plus_commutes_rhs_2``:"
msgstr ""

#: ../../source/proofs/patterns.rst:80 bb80bfe4b8cf4b2d9e4acea66729e4c8
msgid "It is a good idea to give these slightly more meaningful names:"
msgstr ""

#: ../../source/proofs/patterns.rst:89 01667d8ab1c943049f0f70b5624b8870
msgid "Base Case"
msgstr ""

#: ../../source/proofs/patterns.rst:91 36f3f366ccd943bd902dbc254c9c7fb9
msgid ""
"We can create a separate lemma for the base case interactively, by "
"pressing ``\\l`` with the cursor over ``plus_commutes_Z``. This yields:"
msgstr ""

#: ../../source/proofs/patterns.rst:103 9a526cdb484541c4b5381ac816f2815a
msgid ""
"That is, the hole has been filled with a call to a top level function "
"``plus_commutes_Z``, applied to the variable in scope ``m``."
msgstr ""

#: ../../source/proofs/patterns.rst:106 7e1b44fe5ae248ed912d2cdb882fd130
msgid ""
"Unfortunately, we cannot prove this lemma directly, since ``plus`` is "
"defined by matching on its *first* argument, and here ``plus m Z`` has a "
"concrete value for its *second argument* (in fact, the left hand side of "
"the equality has been reduced from ``plus Z m``.) Again, we can prove "
"this by induction, this time on ``m``."
msgstr ""

#: ../../source/proofs/patterns.rst:112 9e7657056fa94591b30b09efcd058f1c
msgid "First, create a template definition with ``\\d``:"
msgstr ""

#: ../../source/proofs/patterns.rst:119 b49f8a22b93a46e6ba2c553a9cbe33a5
msgid "Now, case split on ``m`` with ``\\c``:"
msgstr ""

#: ../../source/proofs/patterns.rst:127 63d599c915464f9eb9f3998a8cbcce0e
msgid ""
"Checking the type of ``plus_commutes_Z_rhs_1`` shows the following, which"
" is provable by ``Refl``:"
msgstr ""

#: ../../source/proofs/patterns.rst:135 d1c50cd3877e47fbb58f9905fb9d7318
msgid ""
"For such immediate proofs, we can let write the proof automatically by "
"pressing ``\\s`` with the cursor over ``plus_commutes_Z_rhs_1``. This "
"yields:"
msgstr ""

#: ../../source/proofs/patterns.rst:145 4c0b6b5c06ac481cacaf7bd624b02883
msgid "For ``plus_commutes_Z_rhs_2``, we are not so lucky:"
msgstr ""

#: ../../source/proofs/patterns.rst:153 f84ac8294a33460ba6d0ecc837baf7c2
msgid ""
"Inductively, we should know that ``k = plus k Z``, and we can get access "
"to this inductive hypothesis by making a recursive call on k, as follows:"
msgstr ""

#: ../../source/proofs/patterns.rst:165 82ce88094fcd49cd994a6261d24500a0
msgid "For ``plus_commutes_Z_rhs_2``, we now see:"
msgstr ""

#: ../../source/proofs/patterns.rst:174 843776e7d61e41c6b2308dbc1850ccab
msgid ""
"So we know that ``k = plus k Z``, but how do we use this to update the "
"goal to ``S k = S k``?"
msgstr ""

#: ../../source/proofs/patterns.rst:177 273737755b6a43f59576152d61950b3a
msgid ""
"To achieve this, Idris provides a ``replace`` function as part of the "
"prelude:"
msgstr ""

#: ../../source/proofs/patterns.rst:185 f68811ef415a48a1b557cedab40aa7a3
msgid ""
"Given a proof that ``x = y``, and a property ``p`` which holds for ``x``,"
" we can get a proof of the same property for ``y``, because we know ``x``"
" and ``y`` must be the same. Note the multiplicity on ``rule`` means that"
" it's guaranteed to be erased at run time. In practice, this function can"
" be a little tricky to use because in general the implicit argument ``p``"
" can be hard to infer by unification, so Idris provides a high level "
"syntax which calculates the property and applies ``replace``:"
msgstr ""

#: ../../source/proofs/patterns.rst:198 a09375c96a764d74a4f6b666045713a2
msgid ""
"If we have ``prf : x = y``, and the required type for ``expr`` is some "
"property of ``x``, the ``rewrite ... in`` syntax will search for all "
"occurrences of ``x`` in the required type of ``expr`` and replace them "
"with ``y``. We want to replace ``plus k Z`` with ``k``, so we need to "
"apply our rule ``rec`` in reverse, which we can do using ``sym`` from the"
" Prelude"
msgstr ""

#: ../../source/proofs/patterns.rst:210 46dd231f5642496daaa1e4c6952506f5
msgid "Concretely, in our example, we can say:"
msgstr ""

#: ../../source/proofs/patterns.rst:218 60682019177747518d9990d93e139fda
msgid "Checking the type of ``plus_commutes_Z_rhs_2`` now gives:"
msgstr ""

#: ../../source/proofs/patterns.rst:227 33090a80614c41338a0f4b006048f8a4
msgid ""
"Using the rewrite rule ``rec``, the goal type has been updated with "
"``plus k Z`` replaced by ``k``."
msgstr ""

#: ../../source/proofs/patterns.rst:230 815b9e7555a3486faf305a16a27d550a
msgid "We can use proof search (``\\s``) to complete the proof, giving:"
msgstr ""

#: ../../source/proofs/patterns.rst:240 1f868bc49eee48299e81dba9fba74c9e
msgid "The base case of ``plus_commutes`` is now complete."
msgstr ""

#: ../../source/proofs/patterns.rst:243 b3d45e76a4954abebcdb69f53763fff0
msgid "Inductive Step"
msgstr ""

#: ../../source/proofs/patterns.rst:245 f38c07590506404e9b7920ca0730f542
msgid ""
"Our main theorem, ``plus_commutes`` should currently be in the following "
"state:"
msgstr ""

#: ../../source/proofs/patterns.rst:254 4e36946efaa74c93b6235c1fc312ef3e
msgid "Looking again at the type of ``plus_commutes_S``, we have:"
msgstr ""

#: ../../source/proofs/patterns.rst:263 b536b54132ec45feab17930d8a1a0736
msgid ""
"Conveniently, by induction we can immediately tell that ``plus k m = plus"
" m k``, so let us rewrite directly by making a recursive call to "
"``plus_commutes``. We add this directly, by hand, as follows:"
msgstr ""

#: ../../source/proofs/patterns.rst:274 382944d7ca69481fa4305d8e0006e9c5
msgid "Checking the type of ``plus_commutes_S`` now gives:"
msgstr ""

#: ../../source/proofs/patterns.rst:283 a78fba6cedb54561b588548579b216d2
msgid ""
"The good news is that ``m`` and ``k`` now appear in the correct order. "
"However, we still have to show that the successor symbol ``S`` can be "
"moved to the front in the right hand side of this equality. This "
"remaining lemma takes a similar form to the ``plus_commutes_Z``; we begin"
" by making a new top level lemma with ``\\l``. This gives:"
msgstr ""

#: ../../source/proofs/patterns.rst:293 01ff50b2dd394b06aae5bac31e90cc0a
msgid "Again, we make a template definition with ``\\a``:"
msgstr ""

#: ../../source/proofs/patterns.rst:300 06ef51272b1947ab931aeed7b889eed7
msgid ""
"Like ``plus_commutes_Z``, we can define this by induction over ``m``, "
"since ``plus`` is defined by matching on its first argument. The complete"
" definition is:"
msgstr ""

#: ../../source/proofs/patterns.rst:311 e9c79819e94e43a7b0762b0a5908428f
msgid "All holes have now been solved."
msgstr ""

#: ../../source/proofs/patterns.rst:313 b65f469b16534ea4b74993da340d9f29
msgid ""
"The ``total`` annotation means that we require the final function to pass"
" the totality checker; i.e. it will terminate on all possible well-typed "
"inputs. This is important for proofs, since it provides a guarantee that "
"the proof is valid in *all* cases, not just those for which it happens to"
" be well-defined."
msgstr ""

#: ../../source/proofs/patterns.rst:319 6da69e2cd4554f63a17778f308139c31
msgid ""
"Now that ``plus_commutes`` has a ``total`` annotation, we have completed "
"the proof of commutativity of addition on natural numbers."
msgstr ""

