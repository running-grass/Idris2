# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-12 09:10+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../source/reference/strings.rst:2 adc5dbe754fb4a6193a02c99b53b03f8
msgid "String literals in Idris"
msgstr ""

#: ../../source/reference/strings.rst:4 1919a0707a474fdf942640ccb87fa4a0
msgid ""
"To facilitate the use of string literals, idris provides three features "
"in addition to plain string literals: multiline strings, raw strings and "
"interpolated strings."
msgstr ""

#: ../../source/reference/strings.rst:9 a4e95500525a43d09296e45430ff1b3e
msgid "Plain string literals"
msgstr ""

#: ../../source/reference/strings.rst:11 c6f7642b8bb24c9aba77908eb05aee46
msgid ""
"String literals behave the way you expect from other programming "
"language. Use quotation marks ``\"`` around the piece of text that you "
"want to use as a string:"
msgstr ""

#: ../../source/reference/strings.rst:14 08f4a06acb594129a5392803ff13bef2
msgid "``\"hello world\"``"
msgstr ""

#: ../../source/reference/strings.rst:16 ab92ffb5db4340b9b0465c80f0f32112
msgid ""
"As explained in :doc:`overloadedlit`, string literals can be overloaded "
"to return a type different than string."
msgstr ""

#: ../../source/reference/strings.rst:19 6b0786e6a8c44f9f864839d4775bc346
msgid "Multiline string literals"
msgstr ""

#: ../../source/reference/strings.rst:21 c65afbcc01ad48319761d531cd2ea6d0
msgid ""
"In some cases you will have to display a large string literal that spans "
"multiple lines. For this you can use *multiline string literals*, they "
"allow you to span a string across multiple vertical lines, preserving the"
" line returns and the indentation. Additionally they allow you to indent "
"your multiline string with the surrounding code, without breaking the "
"intended format of the string."
msgstr ""

#: ../../source/reference/strings.rst:26 d9b108b590bb4434970d7624c86963e1
msgid ""
"To use multiline strings, start with a triple quote ``\"\"\"`` followed "
"by a line return, then enter your text and close it with another triple "
"quote ``\"\"\"`` with whitespace on its left. The indentation of the "
"closing triple quote will determine how much whitespace should be cropped"
" from each line of the text."
msgstr ""

#: ../../source/reference/strings.rst:33 ec5b7363616a480fa2a3f6762d944056
msgid ""
"Multiline strings use triple quotes to enable the automatic cropping of "
"leading whitespace when the multiline block is indented."
msgstr ""

#: ../../source/reference/strings.rst:48 a04a6012b0e841df9c9bee193f305b38
msgid "printing the variable `welcome` will result in the following text:"
msgstr ""

#: ../../source/reference/strings.rst:58 6ef5e8f9080345a69beb5cc33fc61f83
msgid ""
"As you can see, each line has been stripped of its leading 4 space, that "
"is because the closing delimiter was indented with 4 spaces."
msgstr ""

#: ../../source/reference/strings.rst:61 4b8bc0dcf9bb4905ac1f17b5e3353adb
msgid "In order to use multiline string literals, remember the following:"
msgstr ""

#: ../../source/reference/strings.rst:63 1a663a975b3f41c899da3884f2cbb44c
msgid "The starting delimited must be followed by a line return"
msgstr ""

#: ../../source/reference/strings.rst:64 ca401114e0554d17b0a7cdb64abb93be
msgid ""
"The ending delimiter's intendation level must not exceed the indentation "
"of any line"
msgstr ""

#: ../../source/reference/strings.rst:67 df0317050942410babc390399d028229
msgid "Raw string literals"
msgstr ""

#: ../../source/reference/strings.rst:69 7c7b91af6782489bb52304f75c6477c2
msgid ""
"It is not uncommon to write string literals that require some amount of "
"escaping. For plain string literals the characters ``\\\\`` and ``\"`` "
"must be escaped, for multiline strings the characters ``\"\"\"`` must be "
"escaped. Raw string literals allow you to dynamically change the required"
" escaped sequence in order to avoid having to escape those very common "
"sets of characters. For this, use ``#\"`` as starting delimiter and "
"``\"#`` as closing delimiter. The number of ``#`` symbols can be "
"increased in order to accomodate for edge cases where ``\"#`` would be a "
"valid symbol. In the following example we are able to match on ``\\{`` by"
" using half as many ``\\\\`` characters as if we didn't use raw string "
"literals:"
msgstr ""

#: ../../source/reference/strings.rst:84 9c90b73a017d486a9924fe3f1434f3f2
msgid ""
"If you need to escape characters you still can by using a ``\\\\`` "
"followed by the same number of ``#`` that you used for your string "
"delimiters. In the following example we are using two ``#`` characters as"
" our escape sequence and want to print a line return:"
msgstr ""

#: ../../source/reference/strings.rst:93 21267874f9474ec688f6c23e0a98fa9b
msgid ""
"This last example could be implemented by combining raw string literals "
"with multiline strings:"
msgstr ""

#: ../../source/reference/strings.rst:105 ac46070f463a43baabd20f5eba89389c
msgid "Interpolated strings"
msgstr ""

#: ../../source/reference/strings.rst:107 ee42541fc9eb4dfb8def772efb6408f6
msgid ""
"Concatenating string literals with runtime values happens all the time, "
"but sprinkling our code with lots of ``\"`` and ``++`` symbols sometimes "
"hurts legibility which in turn can introduce bugs that are hard to detect"
" for human eyes. Interpolated strings allow to inline the execution of "
"programs that evaluate to strings with a string literals in order to "
"avoid manually writing out the concatenation of those expressions. To use"
" interpolated strings, use ``\\{`` to start an interpolation slice in "
"which you can write an idris expression. Close it with ``}``"
msgstr ""

#: ../../source/reference/strings.rst:130 430e0ee329e74ca686c10a26814627c8
msgid ""
"As you can see in the second line, raw string literals and interpolated "
"strings can be combined. The starting and closing delimiters indicate how"
" many ``#`` must be used as escape sequence in the string, since "
"interpolated strings require the first ``{`` to be escaped, an "
"interpolated slice in a raw string uses ``\\#{`` as starting delimiter."
msgstr ""

#: ../../source/reference/strings.rst:135 4c2d58f0668046b98923b9d4428a903d
msgid ""
"Additionally multiline strings can also be combined with string "
"interpolation in the way you expect, as shown with the ``Decl`` pattern. "
"Finally all three features can be combined together in the last branch of"
" the example, where a multiline string has a custom escape sequence and "
"includes an interpolated slice."
msgstr ""

#: ../../source/reference/strings.rst:141 8bceebec43c44d8caa73228964953e0e
msgid "Interpolation Interface"
msgstr ""

#: ../../source/reference/strings.rst:143 8356c293a8cc4f54af7a96f131071bde
msgid ""
"The Prelude exposes an ``Interpolation`` interface with one function "
"``interpolate``. This function is used within every interpolation slice "
"to convert an arbitrary expression into a string that can be concatenated"
" with the rest of the interpolated string."
msgstr ""

#: ../../source/reference/strings.rst:147 3c879207046f475cb31ada3f0f046091
msgid ""
"To go into more details, when you write ``\"hello \\{username}\"`` the "
"compiler translates the expression into ``concat [interpolate \"hello \","
" interpolate username]`` so that the concatenation is fast and so that if"
" ``username`` implement the ``Interpolation`` interface, you don't have "
"to convert it to a string manually."
msgstr ""

#: ../../source/reference/strings.rst:151 4b993e6401ca4c72aa354e43d654653f
msgid ""
"Here is an example where we reuse the ``Expr`` type but instead of "
"implementing a ``print`` function we implement ``Interpolation``:"
msgstr ""

#: ../../source/reference/strings.rst:170 6e5114f0acdf4035ad5de0d12a732aa5
msgid ""
"As you can see we avoid repeated calls to ``print`` since the slices are "
"automatically applied to ``interpolate``."
msgstr ""

#: ../../source/reference/strings.rst:173 0f5ae489e4ab4eb39edcd66dbee4dc0c
msgid ""
"We use ``Interpolation`` instead of ``Show`` for interpolation slices "
"because the semantics of ``show`` are not necessarily the same as "
"``interpolate``. Typically the implementation of ``show`` for ``String`` "
"adds double quotes around the text, but for ``interpolate`` what we want "
"is to return the string as is. In the previous example, ``\"hello "
"\\{username}\"``, if we were to use ``show`` we would end up with the "
"string ``\"hello \"Susan`` which displays an extra pair of double quotes."
" That is why the implementation of ``interpolate`` for ``String`` is the "
"identity function: ``interpolate x = x``. This way the desugared code "
"looks like: ``concat [id \"hello \", interpolate username]``."
msgstr ""

