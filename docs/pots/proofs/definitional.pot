# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-23 12:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/proofs/definitional.rst:1
#: 3138adc94cad4839b4a2351ac38578a5
msgid "Before we discuss the details of theorem proving in Idris, we will describe some fundamental concepts:"
msgstr ""

#: ../source/proofs/definitional.rst:4
#: d7b6d026b8ac40f689dcfd53dca517dd
msgid "Propositions and judgments"
msgstr ""

#: ../source/proofs/definitional.rst:5
#: 46b2123fcd0a4756b2e2a6a0c12b6c8c
msgid "Boolean and constructive logic"
msgstr ""

#: ../source/proofs/definitional.rst:6
#: ../source/proofs/definitional.rst:57
#: 8c8c5339da2944e2bcfdd37943d7209f
#: 7b3a780760394728a629aacbd5a3504d
msgid "Curry-Howard correspondence"
msgstr ""

#: ../source/proofs/definitional.rst:7
#: 3b3d3ecbb36c492da60f3a443d45cfed
msgid "Definitional and propositional equalities"
msgstr ""

#: ../source/proofs/definitional.rst:8
#: 41c42568b0a24dde9ca6ac05d4089ef8
msgid "Axiomatic and constructive approaches"
msgstr ""

#: ../source/proofs/definitional.rst:11
#: 576215c63db942d5ab88d478bd217f19
msgid "Propositions and Judgments"
msgstr ""

#: ../source/proofs/definitional.rst:13
#: 0ce5f8d24cf040e8b5ea69ae5ca7dd6d
msgid "Propositions are the subject of our proofs. Before the proof, we can't formally say if they are true or not. If the proof is successful then the result is a 'judgment'.  For instance, if the ``proposition`` is,"
msgstr ""

#: ../source/proofs/definitional.rst:18
#: 0b2bd65c7093446eb6676675fa6814f4
msgid "1+1=2"
msgstr ""

#: ../source/proofs/definitional.rst:21
#: 478c3399426b4217813586abf82a3c36
msgid "When we prove it, the ``judgment`` is,"
msgstr ""

#: ../source/proofs/definitional.rst:24
#: dbaddb9360204c868f29dc414d4e4d70
msgid "1+1=2 true"
msgstr ""

#: ../source/proofs/definitional.rst:27
#: 54ffbe6f558c4b119543e1bd7c5c758e
msgid "Or if the ``proposition`` is,"
msgstr ""

#: ../source/proofs/definitional.rst:30
#: 4c9b4a6e76ec4b0d8ce0bbc382e41db3
msgid "1+1=3"
msgstr ""

#: ../source/proofs/definitional.rst:33
#: d40e95b40ed24a5b9f4317fb4290036f
msgid "we can't prove it is true, but it is still a valid proposition and perhaps we can prove it is false so the ``judgment`` is,"
msgstr ""

#: ../source/proofs/definitional.rst:37
#: 1456fd8ddb234a39a32e1b94185fed61
msgid "1+1=3 false"
msgstr ""

#: ../source/proofs/definitional.rst:40
#: 3468b4a5e0604bb8b92b834bc8ad2b21
msgid "This may seem a bit pedantic but it is important to be careful: in mathematics not every proposition is true or false. For instance, a proposition may be unproven or even unprovable."
msgstr ""

#: ../source/proofs/definitional.rst:44
#: bf9fcf28c6a04a1493b3f70beab01dab
msgid "So the logic here is different from the logic that comes from boolean algebra. In that case what is not true is false and what is not false is true. The logic we are using here does not have this law, the \"Law of Excluded Middle\", so we cannot use it."
msgstr ""

#: ../source/proofs/definitional.rst:49
#: 045f62aef6fa434e9648f8d1d492765b
msgid "A false proposition is taken to be a contradiction and if we have a contradiction then we can prove anything, so we need to avoid this. Some languages, used in proof assistants, prevent contradictions."
msgstr ""

#: ../source/proofs/definitional.rst:53
#: e3467bd832484e0b9aefecc77a3ad674
msgid "The logic we are using is called constructive (or sometimes intuitional) because we are constructing a 'database' of judgments."
msgstr ""

#: ../source/proofs/definitional.rst:59
#: 581403427f574bc98ad24fb880e5abab
msgid "So how do we relate these proofs to Idris programs? It turns out that there is a correspondence between constructive logic and type theory. They have the same structure and we can switch back and forth between the two notations."
msgstr ""

#: ../source/proofs/definitional.rst:63
#: 0087d4ab50924dfa8f0e81761bc78557
msgid "The way that this works is that a proposition is a type so..."
msgstr ""

#: ../source/proofs/definitional.rst:73
#: aef6e6a9c60e47059be74131e8c877cb
msgid "...is a proposition and it is also a type. The following will also produce an equality type:"
msgstr ""

#: ../source/proofs/definitional.rst:82
#: f6757874157f4f6495333822cffa8cfc
msgid "Both of these are valid propositions so both are valid equality types. But how do we represent a true judgment? That is, how do we denote 1+1=2 is true but not 1+1=3?  A type that is true is inhabited, that is, it can be constructed. An equality type has only one constructor 'Refl' so a proof of 1+1=2 is"
msgstr ""

#: ../source/proofs/definitional.rst:92
#: f7d696c8b57e4495943f03193d82e2bc
msgid "Now that we can represent propositions as types other aspects of propositional logic can also be translated to types as follows:"
msgstr ""

#: ../source/proofs/definitional.rst:96
#: 874916b4dce64fcf9cfaf2449d24af56
msgid "propositions"
msgstr ""

#: ../source/proofs/definitional.rst:96
#: f030e5995b6a447690977ae07cd6d6a6
msgid "example of possible type"
msgstr ""

#: ../source/proofs/definitional.rst:98
#: 214683a1ce87401b8dde697be6e2c6c3
msgid "A"
msgstr ""

#: ../source/proofs/definitional.rst:98
#: cad96e38ee5a460e83f068f66fa5dab2
msgid "x=y"
msgstr ""

#: ../source/proofs/definitional.rst:100
#: 58e64649b0fe4095aa6905c8fcaf9efe
msgid "B"
msgstr ""

#: ../source/proofs/definitional.rst:100
#: ../source/proofs/definitional.rst:108
#: ../source/proofs/definitional.rst:110
#: 6a90cf5ec9924343904901dfaa524193
#: 67dd339941eb47c98fd9068b2be4a290
#: 52f06b95a93f4eaaa0d33c7250e7ca13
msgid "y=z"
msgstr ""

#: ../source/proofs/definitional.rst:102
#: efdafc563fe44979ab455df8d123a949
msgid "and"
msgstr ""

#: ../source/proofs/definitional.rst:102
#: 107c31d61b3149b19c02ee32ad445373
msgid "A /\\\\ B"
msgstr ""

#: ../source/proofs/definitional.rst:102
#: 9022a9681e8b4079be68ba104e92097e
msgid "Pair(x=y,y=z)"
msgstr ""

#: ../source/proofs/definitional.rst:104
#: d069d8a2258f41b5a8d34824689c38be
msgid "or"
msgstr ""

#: ../source/proofs/definitional.rst:104
#: 14b85671ae834245a5ec53e1feb7dfc3
msgid "A \\\\/ B"
msgstr ""

#: ../source/proofs/definitional.rst:104
#: 801e926061d54b4987ef4953de616f44
msgid "Either(x=y,y=z)"
msgstr ""

#: ../source/proofs/definitional.rst:106
#: f4523f066d774f93a3ae452a0e60b17f
msgid "implies"
msgstr ""

#: ../source/proofs/definitional.rst:106
#: f058bb5dc10244ad9792f7013b4d5e5e
msgid "A -> B"
msgstr ""

#: ../source/proofs/definitional.rst:106
#: 79d950d17156447abc02267e9db5ffbc
msgid "(x=y) -> (y=z)"
msgstr ""

#: ../source/proofs/definitional.rst:108
#: 2e75d16ef8384a65ac6243ab87ef01aa
msgid "for all"
msgstr ""

#: ../source/proofs/definitional.rst:110
#: 25a619dfdb9945ec9f582bbe040a3cc1
msgid "exists"
msgstr ""

#: ../source/proofs/definitional.rst:115
#: 7b40c0ac1e344492bc155a5fcca211c1
msgid "And (conjunction)"
msgstr ""

#: ../source/proofs/definitional.rst:117
#: 1bed99eb37264bcd9654cd210457ae5e
msgid "We can have a type which corresponds to conjunction:"
msgstr ""

#: ../source/proofs/definitional.rst:123
#: 13f94f81b98041feba967f71eb7d06ae
msgid "There is a built in type called 'Pair'."
msgstr ""

#: ../source/proofs/definitional.rst:126
#: d60a59a702184e7a901952690ff43a7c
msgid "Or (disjunction)"
msgstr ""

#: ../source/proofs/definitional.rst:128
#: d92a7398bea94f8b9e5344ff33dca268
msgid "We can have a type which corresponds to disjunction:"
msgstr ""

#: ../source/proofs/definitional.rst:136
#: d85a8065b28e40e9b017b3fe963489de
msgid "There is a built in type called 'Either'."
msgstr ""

#: ../source/proofs/definitional.rst:139
#: 466f8374dcde429b849e10a249514f1b
msgid "Definitional and Propositional Equalities"
msgstr ""

#: ../source/proofs/definitional.rst:141
#: c633175f2d604229ac7ab1bde40e6988
msgid "We have seen that  we can 'prove' a type by finding a way to construct a term. In the case of equality types there is only one constructor which is ``Refl``. We have also seen that each side of the equation does not have to be identical like '2=2'. It is enough that both sides are *definitionally equal* like this:"
msgstr ""

#: ../source/proofs/definitional.rst:151
#: 1d8f19ebf05245c19d7f89f16e862841
msgid "Both sides of this equation normalise to 2 and so Refl matches and the proposition is proved."
msgstr ""

#: ../source/proofs/definitional.rst:154
#: 6aaa470d58fa4dec89396165a80d875c
msgid "We don't have to stick to terms; we can also use symbolic parameters so the following type checks:"
msgstr ""

#: ../source/proofs/definitional.rst:162
#: 7418ce9df22942f99f2abc8dbefc92dd
msgid "If a proposition/equality type is not definitionally equal but is still true then it is *propositionally equal*. In this case we may still be able to prove it but some steps in the proof may require us to add something into the terms or at least to take some sideways steps to get to a proof."
msgstr ""

#: ../source/proofs/definitional.rst:167
#: aad0058568ba4ca6829b4e195689626d
msgid "Especially when working with equalities containing variable terms (inside functions) it can be hard to know which equality types are definitionally equal, in this example ``plusReducesL`` is *definitionally equal* but ``plusReducesR`` is not (although it is *propositionally equal*). The only difference between them is the order of the operands."
msgstr ""

#: ../source/proofs/definitional.rst:181
#: 4bdb132fa8fe4493aca1755ded719fd1
msgid "Checking ``plusReducesR`` gives the following error:"
msgstr ""

#: ../source/proofs/definitional.rst:192
#: 7d7f7dfc60284939b8d4eeca40687d2f
msgid "So why is ``Refl`` able to prove some equality types but not others?"
msgstr ""

#: ../source/proofs/definitional.rst:194
#: 21dd824f401f4a6a9ccbb3ca60b2432a
msgid "The first answer is that ``plus`` is defined by recursion on its first argument. So, when the first argument is ``Z``, it reduces, but not when the second argument is ``Z``."
msgstr ""

#: ../source/proofs/definitional.rst:198
#: 801f1d642c094653a02e94a0b5a4a13e
msgid "If an equality type can be proved/constructed by using ``Refl`` alone it is known as a *definitional equality*. In order to be definitionally equal both sides of the equation must normalise to the same value."
msgstr ""

#: ../source/proofs/definitional.rst:202
#: 0fd191732cf546a3a733bb376e9c9534
msgid "So when we type ``1+1`` in Idris it is immediately reduced to 2 because definitional equality is built in"
msgstr ""

#: ../source/proofs/definitional.rst:210
#: a035d098b342417cbb906bb82792487d
msgid "In the following pages we discuss how to resolve propositional equalities."
msgstr ""
