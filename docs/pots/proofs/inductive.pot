# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-23 12:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/proofs/inductive.rst:5
#: 040e526895df46bc8550957e6fab6a0a
msgid "Inductive Proofs"
msgstr ""

#: ../source/proofs/inductive.rst:7
#: d03c8520746e4443acf82806bf066ce5
msgid "Before embarking on proving ``plus_commutes`` in Idris itself, let us consider the overall structure of a proof of some property of natural numbers. Recall that they are defined recursively, as follows:"
msgstr ""

#: ../source/proofs/inductive.rst:17
#: 4538581c8ddf42059f23994468d12879
msgid "A *total* function over natural numbers must both terminate, and cover all possible inputs. Idris checks functions for totality by checking that all inputs are covered, and that all recursive calls are on *structurally smaller* values (so recursion will always reach a base case). Recalling ``plus``:"
msgstr ""

#: ../source/proofs/inductive.rst:29
#: 5375603f47034684a88918dbac76b7b1
msgid "This is total because it covers all possible inputs (the first argument can only be ``Z`` or ``S k`` for some ``k``, and the second argument ``m`` covers all possible ``Nat``) and in the recursive call, ``k`` is structurally smaller than ``S k`` so the first argument will always reach the base case ``Z`` in any sequence of recursive calls."
msgstr ""

#: ../source/proofs/inductive.rst:35
#: 0a7f2a52e09743e5a82b9d6d49ec3df0
msgid "In some sense, this resembles a mathematical proof by induction (and this is no coincidence!). For some property ``P`` of a natural number ``x``, we can show that ``P`` holds for all ``x`` if:"
msgstr ""

#: ../source/proofs/inductive.rst:39
#: c8e84e2026124bd3bc1e0dd442b8319f
msgid "``P`` holds for zero (the base case)."
msgstr ""

#: ../source/proofs/inductive.rst:41
#: b4564c68a71d4e0993f8830f95553f26
msgid "Assuming that ``P`` holds for ``k``, we can show ``P`` also holds for ``S k`` (the inductive step)."
msgstr ""

#: ../source/proofs/inductive.rst:44
#: 9de529349aee4c7f915d2fcc323f6eb8
msgid "In ``plus``, the property we are trying to show is somewhat trivial (for all natural numbers ``x``, there is a ``Nat`` which need not have any relation to ``x``). However, it still takes the form of a base case and an inductive step. In the base case, we show that there is a ``Nat`` arising from ``plus n m`` when ``n = Z``, and in the inductive step we show that there is a ``Nat`` arising when ``n = S k`` and we know we can get a ``Nat`` inductively from ``plus k m``. We could even write a function capturing all such inductive definitions:"
msgstr ""

#: ../source/proofs/inductive.rst:64
#: 7deb6d8c21f14d41985ed41a0e8af06a
msgid "Using ``nat_induction``, we can implement an equivalent inductive version of ``plus``:"
msgstr ""

#: ../source/proofs/inductive.rst:77
#: 710ec849abc64d9b934668405bd2f034
msgid "To prove that ``plus n m = plus m n`` for all natural numbers ``n`` and ``m``, we can also use induction. Either we can fix ``m`` and perform induction on ``n``, or vice versa. We can sketch an outline of a proof; performing induction on ``n``, we have:"
msgstr ""

#: ../source/proofs/inductive.rst:82
#: 865e53d7fd3845728524ff91ce47eb2e
msgid "Property ``prop`` is ``\\x => plus x m = plus m x``."
msgstr ""

#: ../source/proofs/inductive.rst:84
#: 80b88300eefa433db4f581780e7b7482
msgid "Show that ``prop`` holds in the base case and inductive step:"
msgstr ""

#: ../source/proofs/inductive.rst:0
#: 094cb76d248a49268dc725bccb3ea61c
msgid "Base case: ``prop Z``, i.e."
msgstr ""

#: ../source/proofs/inductive.rst:0
#: 7af2139c98434d27b4cda0e657eb8e90
msgid "``plus Z m = plus m Z``, which reduces to"
msgstr ""

#: ../source/proofs/inductive.rst:0
#: 6c53a7174b6f4438b76ef8b34d44fe4e
msgid "``m = plus m Z`` due to the definition of ``plus``."
msgstr ""

#: ../source/proofs/inductive.rst:0
#: adb024892f634020a5fa4af9550c714d
msgid "Inductive step: Inductively, we know that ``prop k`` holds for a specific, fixed ``k``, i.e."
msgstr ""

#: ../source/proofs/inductive.rst:0
#: 869e8664d8e54015aea6c9860b151f1b
msgid "``plus k m = plus m k`` (the induction hypothesis). Given this, show ``prop (S k)``, i.e."
msgstr ""

#: ../source/proofs/inductive.rst:0
#: aaa7010417bd4197b37d488737221f43
msgid "``plus (S k) m = plus m (S k)``, which reduces to"
msgstr ""

#: ../source/proofs/inductive.rst:0
#: b5ec3344c3df450aadd5052f3309e4d3
msgid "``S (plus k m) = plus m (S k)``. From the induction hypothesis, we can rewrite this to"
msgstr ""

#: ../source/proofs/inductive.rst:0
#: 8c98714a4aef44ebaa2f31dc1229bc21
msgid "``S (plus m k) = plus m (S k)``."
msgstr ""

#: ../source/proofs/inductive.rst:96
#: b679d8996cad4470b72db901f5b04d5b
msgid "To complete the proof we therefore need to show that ``m = plus m Z`` for all natural numbers ``m``, and that ``S (plus m k) = plus m (S k)`` for all natural numbers ``m`` and ``k``. Each of these can also be proved by induction, this time on ``m``."
msgstr ""

#: ../source/proofs/inductive.rst:101
#: 961531a7918a4727aa56739d2f0cd0cc
msgid "We are now ready to embark on a proof of commutativity of ``plus`` formally in Idris."
msgstr ""
