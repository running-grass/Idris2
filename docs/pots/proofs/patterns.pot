# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-23 12:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/proofs/patterns.rst:3
#: ce919df581684ee5ad46418c2b7991ae
msgid "Pattern Matching Proofs"
msgstr ""

#: ../source/proofs/patterns.rst:5
#: 3f21912fdc0846d5a67262b596804bd9
msgid "In this section, we will provide a proof of ``plus_commutes`` directly, by writing a pattern matching definition. We will use interactive editing features extensively, since it is significantly easier to produce a proof when the machine can give the types of intermediate values and construct components of the proof itself. The commands we will use are summarised below. Where we refer to commands directly, we will use the Vim version, but these commands have a direct mapping to Emacs commands."
msgstr ""

#: ../source/proofs/patterns.rst:15
#: 91c9359046164f279dfd59a7c8d3ad38
msgid "Command"
msgstr ""

#: ../source/proofs/patterns.rst:15
#: d4d2476bc2a74f3a86f624145a7cbd52
msgid "Vim binding"
msgstr ""

#: ../source/proofs/patterns.rst:15
#: 141ecb37489947f39736e804fe4eab08
msgid "Emacs binding"
msgstr ""

#: ../source/proofs/patterns.rst:15
#: 34fead4f4f2b40fa977ebb6ee25b208b
msgid "Explanation"
msgstr ""

#: ../source/proofs/patterns.rst:17
#: 3f4a3e635d594349a60b08850d673011
msgid "Check type"
msgstr ""

#: ../source/proofs/patterns.rst:17
#: 05187a54a6754c12b54cdc64d2bd7c4f
msgid "``\\t``"
msgstr ""

#: ../source/proofs/patterns.rst:17
#: 43f29377d3e14a7f905a67cf22278f62
msgid "``C-c C-t``"
msgstr ""

#: ../source/proofs/patterns.rst:17
#: 9cc7e2d2ac58429e8af2908282cd917c
msgid "Show type of identifier or hole under the cursor."
msgstr ""

#: ../source/proofs/patterns.rst:19
#: b10c720f3b6443ed923706b98ee0202c
msgid "Proof search"
msgstr ""

#: ../source/proofs/patterns.rst:19
#: 9a049e720a144c418679b6741415ca9d
msgid "``\\s``"
msgstr ""

#: ../source/proofs/patterns.rst:19
#: 99e201d9c8fd4185a012798afa9bbd8e
msgid "``C-c C-a``"
msgstr ""

#: ../source/proofs/patterns.rst:19
#: ad6092a258224b84a7016e507fff581c
msgid "Attempt to solve hole under the cursor by applying simple proof search."
msgstr ""

#: ../source/proofs/patterns.rst:21
#: 3efaef735b2f44b59fd95a37784c77e6
msgid "Make new definition"
msgstr ""

#: ../source/proofs/patterns.rst:21
#: dd7963d84419444889537d01b494ddff
msgid "``\\a``"
msgstr ""

#: ../source/proofs/patterns.rst:21
#: 9d2cd512c9b045a3a0d3f9df215920a6
msgid "``C-c C-s``"
msgstr ""

#: ../source/proofs/patterns.rst:21
#: c4ebd30cf8e7430aa1fbe3200d49317b
msgid "Add a template definition for the type defined under the cursor."
msgstr ""

#: ../source/proofs/patterns.rst:23
#: 2f580af03a0148099652f1fabbbfab00
msgid "Make lemma"
msgstr ""

#: ../source/proofs/patterns.rst:23
#: 4de816bc4f0941caa21acd6435643710
msgid "``\\l``"
msgstr ""

#: ../source/proofs/patterns.rst:23
#: 7ee6c13b25364a42996fc8420ef03403
msgid "``C-c C-e``"
msgstr ""

#: ../source/proofs/patterns.rst:23
#: 3f2d0cce74a941f995cbc890570b30a0
msgid "Add a top level function with a type which solves the hole under the cursor."
msgstr ""

#: ../source/proofs/patterns.rst:25
#: 9968cced737e43ccbb654b83880daa18
msgid "Split cases"
msgstr ""

#: ../source/proofs/patterns.rst:25
#: 1491714d73d94e6093ffa3fcc2d8569b
msgid "``\\c``"
msgstr ""

#: ../source/proofs/patterns.rst:25
#: f017799ef6ec403eb00702a6edc7c848
msgid "``C-c C-c``"
msgstr ""

#: ../source/proofs/patterns.rst:25
#: 25ec272a696f42a89f4f8305401f676c
msgid "Create new constructor patterns for each possible case of the variable under the cursor."
msgstr ""

#: ../source/proofs/patterns.rst:30
#: acd2a1938710420a992643e21d15da61
msgid "Creating a Definition"
msgstr ""

#: ../source/proofs/patterns.rst:32
#: bfcf6d8c7d89469bb499ae6dc2f30785
msgid "To begin, create a file ``pluscomm.idr`` containing the following type declaration:"
msgstr ""

#: ../source/proofs/patterns.rst:39
#: cea4911d27f94e1aad01291d2cd8825a
msgid "To create a template definition for the proof, press ``\\a`` (or the equivalent in your editor of choice) on the line with the type declaration. You should see:"
msgstr ""

#: ../source/proofs/patterns.rst:48
#: 4f84184beea746d8b867b35f5fd5fe1a
msgid "To prove this by induction on ``n``, as we sketched in Section :ref:`sect-inductive`, we begin with a case split on ``n`` (press ``\\c`` with the cursor over the ``n`` in the definition.) You should see:"
msgstr ""

#: ../source/proofs/patterns.rst:59
#: 41e0832ae2d34d818cb8abb50e1b2edb
msgid "If we inspect the types of the newly created holes, ``plus_commutes_rhs_1`` and ``plus_commutes_rhs_2``, we see that the type of each reflects that ``n`` has been refined to ``Z`` and ``S k`` in each respective case. Pressing ``\\t`` over ``plus_commutes_rhs_1`` shows:"
msgstr ""

#: ../source/proofs/patterns.rst:71
#: 6c32d3646f014b268c05f297071f4228
msgid "Similarly, for ``plus_commutes_rhs_2``:"
msgstr ""

#: ../source/proofs/patterns.rst:80
#: b62f1541f60746468926d40d294b2e5f
msgid "It is a good idea to give these slightly more meaningful names:"
msgstr ""

#: ../source/proofs/patterns.rst:89
#: cbb198e6b157481abbf46b53748560f1
msgid "Base Case"
msgstr ""

#: ../source/proofs/patterns.rst:91
#: 91c8c4a7de2e49fb9d8e58469a8b73e6
msgid "We can create a separate lemma for the base case interactively, by pressing ``\\l`` with the cursor over ``plus_commutes_Z``. This yields:"
msgstr ""

#: ../source/proofs/patterns.rst:103
#: e2f88d71e58749d1ad084f60654bc4d2
msgid "That is, the hole has been filled with a call to a top level function ``plus_commutes_Z``, applied to the variable in scope ``m``."
msgstr ""

#: ../source/proofs/patterns.rst:106
#: 65e5a31f0dcf47019bc9e96cc1d62537
msgid "Unfortunately, we cannot prove this lemma directly, since ``plus`` is defined by matching on its *first* argument, and here ``plus m Z`` has a concrete value for its *second argument* (in fact, the left hand side of the equality has been reduced from ``plus Z m``.) Again, we can prove this by induction, this time on ``m``."
msgstr ""

#: ../source/proofs/patterns.rst:112
#: 5e7d07d5a37743e59e763ec43de19da5
msgid "First, create a template definition with ``\\d``:"
msgstr ""

#: ../source/proofs/patterns.rst:119
#: 46770312bdf546ffb7b6ac18b721a1d7
msgid "Now, case split on ``m`` with ``\\c``:"
msgstr ""

#: ../source/proofs/patterns.rst:127
#: 1a65253384be4844a253b6ad131ac7e7
msgid "Checking the type of ``plus_commutes_Z_rhs_1`` shows the following, which is provable by ``Refl``:"
msgstr ""

#: ../source/proofs/patterns.rst:135
#: 6cd15d9f989a4f73af92c4d8558e8797
msgid "For such immediate proofs, we can let write the proof automatically by pressing ``\\s`` with the cursor over ``plus_commutes_Z_rhs_1``. This yields:"
msgstr ""

#: ../source/proofs/patterns.rst:145
#: 93f5b7d7cdf549c7aad3dfdceefa61e3
msgid "For ``plus_commutes_Z_rhs_2``, we are not so lucky:"
msgstr ""

#: ../source/proofs/patterns.rst:153
#: aaa7e12391f04970985a2908742538c6
msgid "Inductively, we should know that ``k = plus k Z``, and we can get access to this inductive hypothesis by making a recursive call on k, as follows:"
msgstr ""

#: ../source/proofs/patterns.rst:165
#: 37cf469d58d94af884c04c41dec98c6c
msgid "For ``plus_commutes_Z_rhs_2``, we now see:"
msgstr ""

#: ../source/proofs/patterns.rst:174
#: 954f3d9c854245a28004d14cd725c831
msgid "So we know that ``k = plus k Z``, but how do we use this to update the goal to ``S k = S k``?"
msgstr ""

#: ../source/proofs/patterns.rst:177
#: 89afc4bbc97940818f24552f56ffc89e
msgid "To achieve this, Idris provides a ``replace`` function as part of the prelude:"
msgstr ""

#: ../source/proofs/patterns.rst:185
#: 61e762fba1ff4e0597c60b47ea58d280
msgid "Given a proof that ``x = y``, and a property ``p`` which holds for ``x``, we can get a proof of the same property for ``y``, because we know ``x`` and ``y`` must be the same. Note the multiplicity on ``rule`` means that it's guaranteed to be erased at run time. In practice, this function can be a little tricky to use because in general the implicit argument ``p`` can be hard to infer by unification, so Idris provides a high level syntax which calculates the property and applies ``replace``:"
msgstr ""

#: ../source/proofs/patterns.rst:198
#: 53cb38d5a7b049f7a916fb33d1aa6ad7
msgid "If we have ``prf : x = y``, and the required type for ``expr`` is some property of ``x``, the ``rewrite ... in`` syntax will search for all occurrences of ``x`` in the required type of ``expr`` and replace them with ``y``. We want to replace ``plus k Z`` with ``k``, so we need to apply our rule ``rec`` in reverse, which we can do using ``sym`` from the Prelude"
msgstr ""

#: ../source/proofs/patterns.rst:210
#: 86a8349af8044b50aa1355844fe9414a
msgid "Concretely, in our example, we can say:"
msgstr ""

#: ../source/proofs/patterns.rst:218
#: 98613a3590de471e9295799314f09539
msgid "Checking the type of ``plus_commutes_Z_rhs_2`` now gives:"
msgstr ""

#: ../source/proofs/patterns.rst:227
#: 7c90604966c341a3935b9e6f3ce5c22c
msgid "Using the rewrite rule ``rec``, the goal type has been updated with ``plus k Z`` replaced by ``k``."
msgstr ""

#: ../source/proofs/patterns.rst:230
#: 87217a01e7194fc3ad97355028d7f522
msgid "We can use proof search (``\\s``) to complete the proof, giving:"
msgstr ""

#: ../source/proofs/patterns.rst:240
#: e1c5f455a8484c8db28fd2d3b0e6fe31
msgid "The base case of ``plus_commutes`` is now complete."
msgstr ""

#: ../source/proofs/patterns.rst:243
#: 3240526c32ff4046bd07b60c77b03c97
msgid "Inductive Step"
msgstr ""

#: ../source/proofs/patterns.rst:245
#: 0678e92638ab4ac282b80a275478cd66
msgid "Our main theorem, ``plus_commutes`` should currently be in the following state:"
msgstr ""

#: ../source/proofs/patterns.rst:254
#: bdc8b5b373d4411a91bcc4e9f64a95f9
msgid "Looking again at the type of ``plus_commutes_S``, we have:"
msgstr ""

#: ../source/proofs/patterns.rst:263
#: 0d689435dbce46d4b47fcdb274ccd3e3
msgid "Conveniently, by induction we can immediately tell that ``plus k m = plus m k``, so let us rewrite directly by making a recursive call to ``plus_commutes``. We add this directly, by hand, as follows:"
msgstr ""

#: ../source/proofs/patterns.rst:274
#: d72ea92b288740049e87817767e54f1d
msgid "Checking the type of ``plus_commutes_S`` now gives:"
msgstr ""

#: ../source/proofs/patterns.rst:283
#: 6f8a0925331f465baa29611bc4ac17e3
msgid "The good news is that ``m`` and ``k`` now appear in the correct order. However, we still have to show that the successor symbol ``S`` can be moved to the front in the right hand side of this equality. This remaining lemma takes a similar form to the ``plus_commutes_Z``; we begin by making a new top level lemma with ``\\l``. This gives:"
msgstr ""

#: ../source/proofs/patterns.rst:293
#: 497cfcc75dd4469fad3cf3c64b622d52
msgid "Again, we make a template definition with ``\\a``:"
msgstr ""

#: ../source/proofs/patterns.rst:300
#: c7bcd2ca9dc94c33815522727f9b0010
msgid "Like ``plus_commutes_Z``, we can define this by induction over ``m``, since ``plus`` is defined by matching on its first argument. The complete definition is:"
msgstr ""

#: ../source/proofs/patterns.rst:311
#: 5e9c1e65753e406bbe28d7b1b9883c6f
msgid "All holes have now been solved."
msgstr ""

#: ../source/proofs/patterns.rst:313
#: eb028d0942a84186adb1cf68383cdffd
msgid "The ``total`` annotation means that we require the final function to pass the totality checker; i.e. it will terminate on all possible well-typed inputs. This is important for proofs, since it provides a guarantee that the proof is valid in *all* cases, not just those for which it happens to be well-defined."
msgstr ""

#: ../source/proofs/patterns.rst:319
#: ebffb49fd6e644f4b2109ec2bca40647
msgid "Now that ``plus_commutes`` has a ``total`` annotation, we have completed the proof of commutativity of addition on natural numbers."
msgstr ""
