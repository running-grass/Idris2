# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-23 12:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/backends/backend-cookbook.rst:2
#: 78d13fa0278543afb0b6390e7d9a47d0
msgid "Custom backend cookbook"
msgstr ""

#: ../source/backends/backend-cookbook.rst:4
#: a6af953c2be94619b9d2b835cae3dcab
msgid "This document addresses the details on how to implement a custom code generation backend for the Idris compiler."
msgstr ""

#: ../source/backends/backend-cookbook.rst:7
#: d022148e75504161bd7c479f1493958e
msgid "This part has no insights about how to implement the dependently typed bits. For that part of the compiler Edwin Brady gave lectures at SPLV20_ which are available online."
msgstr ""

#: ../source/backends/backend-cookbook.rst:11
#: fd7682f4e0a74893a760ffab46c55d68
msgid "The architecture of the Idris2 compiler makes it easy to implement a custom code generation back-end."
msgstr ""

#: ../source/backends/backend-cookbook.rst:14
#: 1fa78e537ee34c4ca02a22c0f5047d21
msgid "The way to extend Idris with new back-ends is to use it as a library. The module ``Idris.Driver`` exports the function ``mainWithCodegens``, that takes a list of ``(String, Codegen)``, starting idris with these codegens in addition to the built-in ones. The first codegen in the list will be set as the default codegen."
msgstr ""

#: ../source/backends/backend-cookbook.rst:20
#: 9195b1379b8a4a14855e99964e658a1d
msgid "Anyone who is interested in implementing a custom back-end needs to answer the following questions:"
msgstr ""

#: ../source/backends/backend-cookbook.rst:23
#: ../source/backends/backend-cookbook.rst:119
#: b4079e699e1d49cd9bca830d1087dc73
#: c908453b547d491da392c71677283335
msgid "Which Intermediate Representation (IR) should be consumed by the custom back-end?"
msgstr ""

#: ../source/backends/backend-cookbook.rst:24
#: ../source/backends/backend-cookbook.rst:136
#: 6000e806775c4cec9d11532974b33ff5
#: ff435c2ac3e141939f9ca686836bc5fb
msgid "How to represent primitive values defined by the ``Core.TT.Constant`` type?"
msgstr ""

#: ../source/backends/backend-cookbook.rst:25
#: ../source/backends/backend-cookbook.rst:218
#: cd5f51ce44714981b5d7a335d05c76f3
#: e35c2593366f441a808a2820ec5d5d8b
msgid "How to represent Algebraic Data Types?"
msgstr ""

#: ../source/backends/backend-cookbook.rst:26
#: ../source/backends/backend-cookbook.rst:288
#: b64fe82350994e449ad18d93568fa9d5
#: 2ed263af43014c8a8f278b80136dcdb5
msgid "How to implement special values?"
msgstr ""

#: ../source/backends/backend-cookbook.rst:27
#: ../source/backends/backend-cookbook.rst:351
#: 326534ff6f724e968b16128a911a577d
#: 428c90ddb9054801acd2847ca93e6754
msgid "How to implement primitive operations?"
msgstr ""

#: ../source/backends/backend-cookbook.rst:28
#: ../source/backends/backend-cookbook.rst:443
#: e03d1b8eb5ee4222a5819ef269a0f18f
#: 0c1dc966f0e94d329c559627322309ef
msgid "How to compile IR expressions?"
msgstr ""

#: ../source/backends/backend-cookbook.rst:29
#: a69ad97938d24ecfac9528cd5ace6944
msgid "How to compile Definitions?"
msgstr ""

#: ../source/backends/backend-cookbook.rst:30
#: 72d27f401dd74d79bfe3710cce6ac834
msgid "How to implement Foreign Function Interface?"
msgstr ""

#: ../source/backends/backend-cookbook.rst:31
#: ../source/backends/backend-cookbook.rst:673
#: f883f96d79ba4bcf8b0f3120a289792d
#: 8783a0f2926142f5b47f2fd9ae185adc
msgid "How to compile modules?"
msgstr ""

#: ../source/backends/backend-cookbook.rst:32
#: ../source/backends/backend-cookbook.rst:692
#: 068eaa4b1278450b805916b33a6dae6b
#: 84292cd8e3a346eea50c9dcc1d6e5932
msgid "How to embed code snippets?"
msgstr ""

#: ../source/backends/backend-cookbook.rst:33
#: ../source/backends/backend-cookbook.rst:713
#: c738b6eb257d4a629541347b39835686
#: 9eaa9a63100c444bb9a8f7f1bb98f075
msgid "What should the runtime system support?"
msgstr ""

#: ../source/backends/backend-cookbook.rst:35
#: ef459c7224514ed3ac5a83bf1fdfdb41
msgid "First of all, we should know that Idris2 is not an optimizing compiler. Currently its focus is only to compile dependently typed functional code in a timely manner. Its main purpose is to check if the given program is correct in a dependently typed setting and generate code in form of a lambda-calculus like IR where higher-order functions are present. Idris has 3 intermediate representations for code generation. At every level we get a simpler representation, closer to machine code, but it should be stressed that all the aggressive code optimizations should happen in the custom back-ends. The quality and readability of the generated back-end code is on the shoulders of the implementor of the back-end. Idris erases type information, in the IRs as it compiles to scheme by default, and there is no need to keep the type information around. With this in mind let's answer the questions above."
msgstr ""

#: ../source/backends/backend-cookbook.rst:52
#: de0bf06d476d430885a82d09b588eb62
msgid "The architecture of an Idris back-end"
msgstr ""

#: ../source/backends/backend-cookbook.rst:54
#: 4ceef0edc3b64bf5beaeb6648c92769e
msgid "Idris compiles its dependently typed front-end language into a representation which is called ``Compile.TT.Term`` . This data type has a few constructors and it represents a dependently typed term. This ``Term`` is transformed to ``Core.CompileExpr.CExp`` which has more constructors than ``Term`` and it is a very similar construct to a lambda calculus with let bindings, structured and tagged data representation, primitive operations, external operations, and case expressions. The ``CExp`` is closer in the compiling process to code generation."
msgstr ""

#: ../source/backends/backend-cookbook.rst:64
#: 32c456a0e97948e08f3f0891598f3655
msgid "The custom code generation back-end gets a context of definitions, a template directory and an output directory, a ``Core.TT.ClosedTerm`` to compile and a path to an output file."
msgstr ""

#: ../source/backends/backend-cookbook.rst:75
#: 29a85956dfe845288163689f65c50fde
msgid "The ``ClosedTerm`` is a special ``Term`` where the list of the unbound variables is empty. This technicality is not important for the code generation of the custom back-end as the back-end needs to call the ``getCompileData`` function which produces the ``Compiler.Common.CompileData`` record."
msgstr ""

#: ../source/backends/backend-cookbook.rst:81
#: 75709fd862cc4dc8a8c4ef8eecca65cc
msgid "The ``CompileData`` contains:"
msgstr ""

#: ../source/backends/backend-cookbook.rst:83
#: 8a9f7202551e499789dbd2707e9a4c8b
msgid "A main expression that will be the entry point for the program in ``CExp``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:84
#: 2a4438ba87d344a2a007b4ce673d7b55
msgid "A list of ``Core.CompileExpr.NamedDef``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:85
#: 2f1b91978abe456eaa56cb02fde5a3c5
msgid "A list of lambda-lifted definitions ``Compiler.LambdaLift.LiftedDef``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:86
#: ab1ef94d2d0545daa7d41b9e757d56be
msgid "A list of ``Compiler.ANF.ANFDef``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:87
#: d41a35342bdb44c0b35809b5ea9c0396
msgid "A list of ``Compiler.VMCode.VMDef`` definitions"
msgstr ""

#: ../source/backends/backend-cookbook.rst:89
#: b60d61f85b2347a9883559e5be433a36
msgid "These lists contain:"
msgstr ""

#: ../source/backends/backend-cookbook.rst:91
#: 71c073f453214d239a5086c708df678d
msgid "Functions"
msgstr ""

#: ../source/backends/backend-cookbook.rst:92
#: 3146052eea7e461592a0c1e5b21f3c71
msgid "Top-level data definitions"
msgstr ""

#: ../source/backends/backend-cookbook.rst:93
#: e3fe678a1ba14a06994fbc1c21fbc6b1
msgid "Runtime crashes which represent unfilled holes, explicit calls by the user to ``idris_crash``, and unreachable branches in case trees"
msgstr ""

#: ../source/backends/backend-cookbook.rst:96
#: c3a7599bad104a24822205d1c4a8b927
msgid "Foreign call constructs"
msgstr ""

#: ../source/backends/backend-cookbook.rst:98
#: a070f7e25290458b80057183c706a97c
msgid "The job of the custom code generation back-end is to transform one of the phase encoded definitions (``NamedDef``, ``LiftedDef``, ``CExp``, ``ANF``, or ``VM``) into the intermediate representation of the code generator. It can then run optimizations and generate some form of executable. In summary, the code generator has to understand how to represent tagged data and function applications (even if the function application is partial), how to handle let expressions, how to implement and invoke primitive operations, how to handle ``Erased`` arguments, and how to do runtime crashes."
msgstr ""

#: ../source/backends/backend-cookbook.rst:107
#: 8c16b4252b2e4d23a9ce0e0c852be04b
msgid "The implementor of the custom back-end should pick the closest Idris IR which fits to the abstraction of the technology that is aimed to compile to. The implementor should also consider how to transform the simple main expression which is represented in CExp. As Idris does not focus on memory management and threading. The custom back-end should model these concepts for the program that is compiled. One possible approach is to target a fairly high level language and reuse as much as possible from it for the custom back-end. Another possibility is to implement a runtime that is capable of handling memory management and threading."
msgstr ""

#: ../source/backends/backend-cookbook.rst:121
#: 32030146cd0c440d8dc80f990cc389e3
msgid "Now lets turn our attention to the different intermediate representations (IRs) that Idris provides. When the ``getCompiledData`` function is invoked with the ``Phase`` parameter it will produce a ``CompileData`` record, which will contain lists of top-level definitions that needs to be compiled. These are:"
msgstr ""

#: ../source/backends/backend-cookbook.rst:127
#: 6c4738c79f9c41bcbdfe80ee43856d0e
msgid "``NamedDef``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:128
#: 0cd0a6ea739440568ba87d2a52f530e0
msgid "``LiftedDef``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:129
#: a6e0b23b1fa64384befaacec735e6625
msgid "``ANFDef``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:130
#: b8c642b878c8469e94fc4f13330f0f16
msgid "``VMDef``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:132
#: 265bce5154c54d8c84c4ef55e6c198f9
msgid "The question to answer here is: Which one should be picked? Which one fits to the custom back-end?"
msgstr ""

#: ../source/backends/backend-cookbook.rst:138
#: bc5a1ff043474591be1689514c716718
msgid "After one selects the IR to be used during code generation, the next question to answer is how primitive types should be represented in the back-end. Idris has the following primitive types:"
msgstr ""

#: ../source/backends/backend-cookbook.rst:142
#: 146cc318728147c2bf7fb14af8261317
msgid "``Int``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:143
#: 490be6a7ebce4cedb224d13f47e15583
msgid "``Integer`` (arbitrary precision)"
msgstr ""

#: ../source/backends/backend-cookbook.rst:144
#: eca16c621f3b442f99f07f420d0b8263
msgid "``Bits(8/16/32/64)``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:145
#: 765282bff8c5450f94d68c3dc883a3ad
msgid "``Char``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:146
#: 16b8e204b26349eba8e4d53001264116
msgid "``String``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:147
#: cce97eed3f8143e182d6ea7b6e98a0ea
msgid "``Double``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:148
#: ad5b3aac215943d8acd75e82e784d1f5
msgid "``WorldVal`` (token for IO computations)"
msgstr ""

#: ../source/backends/backend-cookbook.rst:150
#: 008f8c3465f9467e806093011ee06b30
msgid "And as Idris allows pattern matching on types all the primitive types have their primitive counterpart for describing a type:"
msgstr ""

#: ../source/backends/backend-cookbook.rst:153
#: 27496cd299db4d63a180e21dcf854248
msgid "``IntType``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:154
#: 7415fcea74ec4b708275bd58f770e4f1
msgid "``IntegerType``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:155
#: 6490e445f0414076842c12113f2bf7ee
msgid "``Bits(8/16/32/64)Type``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:156
#: 31402c5786e445aa967e24fac3b72128
msgid "``StringType``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:157
#: acec09ace5b6481faa00eae2380b9da1
msgid "``CharType``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:158
#: cd39a06a36df4a7d9f579bae2a223640
msgid "``DoubleType``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:159
#: f8b54736b8954eb189f79e4d1050b641
msgid "``WorldType``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:161
#: 9a07364568ac4b73a9745b975752250e
msgid "The representation of these primitive types should be a well-thought out design decision as it affects many parts of the code generation, such as conversion from the back-end values when FFI is involved, big part of the data during the runtime is represented in these forms. Representation of primitive types affect the possible optimisation techniques, and they also affect the memory management and garbage collection."
msgstr ""

#: ../source/backends/backend-cookbook.rst:168
#: 01335085046e44aa95be643b30064cdd
msgid "There are two special primitive types: String and World."
msgstr ""

#: ../source/backends/backend-cookbook.rst:170
#: e3c9347042394809aa4369a5f1eb318d
msgid "**String**"
msgstr ""

#: ../source/backends/backend-cookbook.rst:172
#: 002e415fc0e24c3186be907a44b46d22
msgid "As its name suggest this type represent a string of characters. As mentioned in `Primitive FFI Types <https://idris2.readthedocs.io/en/latest/ffi/ffi.html#primitive-ffi-types>`_, Strings are encoded in UTF-8."
msgstr ""

#: ../source/backends/backend-cookbook.rst:176
#: 5b9bbe542916426b8dc47b85231b4b83
msgid "It is not always clear who is responsible for freeing up a ``String`` created by a component other than the Idris runtime. Strings created in Idris will always have value, unlike possible String representation of the host technology, where for example NULL pointer can be a value, which can not happen on the Idris side. This creates constraints on the possible representations of the Strings in the custom back-end and diverging from the Idris representation is not a good idea. The best approach here is to build a conversion layer between the string representation of the custom back-end and the runtime."
msgstr ""

#: ../source/backends/backend-cookbook.rst:185
#: 5daac3aa752f490a91126fe0faa66b17
msgid "**World**"
msgstr ""

#: ../source/backends/backend-cookbook.rst:187
#: 3198e6587996401e8d5772640beae456
msgid "In pure functional programming, causality needs to be represented whenever we want to maintain the order in which subexpressions are executed. In Idris a token is used to chain IO function calls. This is an abstract notion about the state of the world. For example this information could be the information that the runtime needs for bookkeeping of the running program."
msgstr ""

#: ../source/backends/backend-cookbook.rst:194
#: 345ec75809b645dd963f9e6229212fd3
msgid "The ``WorldVal`` value in Idris programs is accessed via the ``primIO`` construction which leads us to the ``PrimIO`` module. Let's see the relevant snippets:"
msgstr ""

#: ../source/backends/backend-cookbook.rst:209
#: 0667899aaa5b46fc8b0e02fcf4b56703
msgid "The world value is referenced as ``%World`` in Idris. It is created by the runtime when the program starts. Its content is changed by the custom runtime. More precisely, the World is created when the ``WorldVal`` is evaluated during the execution of the program. This can happen when the program gets initialized or when an ``unsafePerformIO`` function is executed."
msgstr ""

#: ../source/backends/backend-cookbook.rst:220
#: ca6e7311f527482983ea6e7f5a66c698
msgid "In Idris there are two different ways to define a data type: tagged unions are introduced using the ``data`` keyword while structs are declared via the ``record`` keyword. Declaring a ``record`` amounts to defining a named collection of fields. Let's see examples for both:"
msgstr ""

#: ../source/backends/backend-cookbook.rst:239
#: 23046960dbde43f6b95829cfe605b500
msgid "Idris offers not only algebraic data types but also indexed families. These are tagged union where different constructors may have different return types. Here is ``Vect`` an example of a data type which is an indexed family corresponding to a linked-list whose length is known at compile time. It has one index (of type ``Nat``) representing the length of the list (the value of this index is therefore different for the ``[]`` and ``(::)`` constructors) and a parameter (of type ``Type``) corresponding to the type of values stored in the list."
msgstr ""

#: ../source/backends/backend-cookbook.rst:254
#: d53d137b5ed148e5b9b616279942d911
msgid "Both data and record are compiled to constructors in the intermediate representations. Two examples of such Constructors are ``Core.CompileExpr.CExp.CCon`` and ``Core.CompileExpr.CDef.MkCon``."
msgstr ""

#: ../source/backends/backend-cookbook.rst:258
#: 10870ff0d73749698ef6590b95c0853e
msgid "Compiling the ``Either`` data type will produce three constructor definitions in the IR:"
msgstr ""

#: ../source/backends/backend-cookbook.rst:261
#: 091ae75f6e36486d889d960b73f84a85
msgid "One for the ``Either`` type itself, with the arity of two. Arity tells how many parameters of the constructor should have. Two is reasonable in this case as the original Idris ``Either`` type has two parameters."
msgstr ""

#: ../source/backends/backend-cookbook.rst:265
#: ac5d89c0d4364e23a4ff5da88a5d5307
msgid "One for the ``Left`` constructor with arity of three. Three may be surprising, as the constructor only has one argument in Idris, but we should keep in mind the type parameters for the data type too."
msgstr ""

#: ../source/backends/backend-cookbook.rst:268
#: 3cca1992ba3c49139f294dc566f33a31
msgid "One for the ``Right`` constructor with arity of three."
msgstr ""

#: ../source/backends/backend-cookbook.rst:270
#: 89b50cf633b04779b5688d340d851000
msgid "In the IR constructors have unique names. For efficiency reasons, Idris assigns a unique integer tag to each data constructors so that constructor matching is reduced to comparisons of integers instead of strings. In the ``Either`` example above ``Left`` gets tag 0 and ``Right`` gets tag 1."
msgstr ""

#: ../source/backends/backend-cookbook.rst:275
#: 7f04d500ace84e3dbe14b5f674657ca1
msgid "Constructors can be considered structured information: a name together with parameters. The custom back-end needs to decide how to represent such data. For example using ``Dict`` in Python, ``JSON`` in JavaScript, etc. The most important aspect to consider is that these structured values are heap related values, which should be created and stored dynamically. If there is an easy way to map in the host technology, the memory management for these values could be inherited. If not, then the host technology is responsible for implementing an appropriate memory management. For example ``RefC`` is a C backend that implements its own memory management based on reference counting."
msgstr ""

#: ../source/backends/backend-cookbook.rst:290
#: 55439d9c58a942d18c6a3d44656e065d
msgid "Apart from the data constructors there are two special kind of values present in the Idris IRs: type constructors and ``Erased``."
msgstr ""

#: ../source/backends/backend-cookbook.rst:294
#: a2fea3fa702a46ef8b8e0e90f4a7d813
msgid "Type constructors"
msgstr ""

#: ../source/backends/backend-cookbook.rst:296
#: f9f463ead0c4488280b29331f27e1a11
msgid "Type and data constructors that are not relevant for the program's runtime behaviour may be used at compile butand will be erased from the intermediate representation."
msgstr ""

#: ../source/backends/backend-cookbook.rst:300
#: 9a1f40c286a44b489eb7c285007e2180
msgid "However some type constructors need to be kept around even at runtime because pattern matching on types is allowed in Idris:"
msgstr ""

#: ../source/backends/backend-cookbook.rst:309
#: ccdcce3dd1c843d9b977a5e1399aa15f
msgid "Here we can pattern match on ``a`` and ensure that ``notId`` behaves differently on ``Int`` than all the other types. This will generate an IR that will contain a ``Case`` expression with two branches: one ``Alt`` matching on the ``Int`` type constructor and a default for the non-``Int`` matching part of the ``notId`` function."
msgstr ""

#: ../source/backends/backend-cookbook.rst:316
#: 3216074344804ec8a1f2e17f28b33886
msgid "This is not that special: ``Type`` is a bit like an infinite data type that contains all of the types a user may ever declare or use. This can be handled in the back-end and host language using the same mechanisms that were mobilised to deal with data constructors. The reason for using the same approach is that in dependently typed languages, the same language is used to form both type and value level expressions. Compilation of type level terms will be the same as that of value level terms. This is one of the things that make dependently typed abstraction elegant."
msgstr ""

#: ../source/backends/backend-cookbook.rst:326
#: 61481721ef7143099032e2d1245d2c7b
msgid "``Erased``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:328
#: 420e7a22adb049f993e9ca9d9c04f71e
msgid "The other kind of special value is ``Erased``. This is generated by the Idris compiler and part of the IR if the original value is only needed during the type elaboration process. For example:"
msgstr ""

#: ../source/backends/backend-cookbook.rst:342
#: c100e26d60134cfcb76e7aa9934ff75a
msgid "Because ``prf`` has quantity ``0``, it is guaranteed to be erased during compilation and thus not present at runtime. Therefore ``prf`` will be represented as ``Erased`` in the IR. The custom back-end needs to represent this value too as any other data value, as it could occur in place of normal values. The simplest approach is to implement it as a special data constructor and let the host technology provided optimizations take care of its removal."
msgstr ""

#: ../source/backends/backend-cookbook.rst:353
#: 9807fc40bf45429784c49ac1f201d1e6
msgid "Primitive operations are defined in the module ``Core.TT.PrimFn``. The constructors of this data type represent the primitive operations that the custom back-end needs to implement. These primitive operations can be grouped as:"
msgstr ""

#: ../source/backends/backend-cookbook.rst:358
#: 52265d9fc91f4f109c7e15992f0658c5
msgid "Arithmetic operations (``Add``, ``Sub``, ``Mul``, ``Div``, ``Mod``, ``Neg``)"
msgstr ""

#: ../source/backends/backend-cookbook.rst:359
#: 14abab4201c2412caef265d2d6fc5120
msgid "Bit operations (``ShiftL``, ``ShiftR``, ``BAnd``, ``BOr``, ``BXor``)"
msgstr ""

#: ../source/backends/backend-cookbook.rst:360
#: 513f1707d99c4cd2aa2910c837f89cf4
msgid "Comparison operations (``LT``, ``LTE``, ``EQ``, ``GTE``, ``GT``)"
msgstr ""

#: ../source/backends/backend-cookbook.rst:361
#: 96eaff261dfd4e47b7db698291c61e1d
msgid "String operations (``Length``, ``Head``, ``Tail``, ``Index``, ``Cons``, ``Append``, ``Reverse``, ``Substr``)"
msgstr ""

#: ../source/backends/backend-cookbook.rst:364
#: 79355a7b3e20482f90a629f3b122840a
msgid "Double precision floating point operations (``Exp``, ``Log``, ``Sin``, ``Cos``, ``Tan``, ``ASin``, ``ACos``, ``ATan``, ``Sqrt``, ``Floor``, ``Ceiling``)"
msgstr ""

#: ../source/backends/backend-cookbook.rst:367
#: 1382ca67338b4682ac2d133567b6bbce
msgid "Casting of numeric and string values"
msgstr ""

#: ../source/backends/backend-cookbook.rst:368
#: 4a8f52ce1d534219ad7150c865be5c24
msgid "An unsafe  cast operation ``BelieveMe``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:369
#: 823abcf0a6b84dee94a80b982a84371b
msgid "A ``Crash`` operation taking a type and a string and creating a value at that type by raising an error."
msgstr ""

#: ../source/backends/backend-cookbook.rst:373
#: d27ec42bf7f343e084a0a6f559366f8f
msgid "BelieveMe"
msgstr ""

#: ../source/backends/backend-cookbook.rst:375
#: 50e87636f9c54067abaca647a0d95284
msgid "The primitive ``believe_me`` is an unsafe cast that allows users to bypass the typechecker when they know something to be true even though it cannot be proven."
msgstr ""

#: ../source/backends/backend-cookbook.rst:378
#: f641677979f84fe49bb5adfccead1d49
msgid "For instance, assuming that Idris' primitives are correctly implemented, it should be true that if a boolean equality test on two ``Int`` ``i`` and ``j`` returns ``True`` then ``i`` and ``j`` are equal. Such a theorem can be implemented by using ``believe_me`` to cast ``Refl`` (the constructor for proofs of a propositional equality) from ``i === i`` to ``i === j``. In this case, it should be safe to implement."
msgstr ""

#: ../source/backends/backend-cookbook.rst:386
#: b54594ea613744ac8d633bca8ef766d8
msgid "Boxing"
msgstr ""

#: ../source/backends/backend-cookbook.rst:388
#: aa69db7421694b1580fe2635d29b2d9e
msgid "Idris assumes that the back-end representation of the data is not strongly typed and that all the data type have the same kind of representation. This could introduce a constraint on the representation of the primitives and constructor represented data types. One possible solution is that the custom back-end should represent primitive data types the same way it does constructors, using special tags. This is called boxing."
msgstr ""

#: ../source/backends/backend-cookbook.rst:396
#: 9da1d49690eb4fd1a21ef108090ea101
msgid "Official backends represent primitive data types as boxed ones."
msgstr ""

#: ../source/backends/backend-cookbook.rst:398
#: b49f693f21364b2a9302a6350825c50a
msgid "RefC: Boxes the primitives, which makes them easy to put on the heap."
msgstr ""

#: ../source/backends/backend-cookbook.rst:399
#: 6c8bbb62b4884fedba8d09d575ce78cc
msgid "Scheme: Prints the values that are a ``Constant`` as Scheme literals."
msgstr ""

#: ../source/backends/backend-cookbook.rst:402
#: 18243c3f6f3e4509a5ebe49a7e7e9450
msgid "How to compile top-level definitions?"
msgstr ""

#: ../source/backends/backend-cookbook.rst:404
#: fd8e818048ca4b578f682ec53f6d7cb0
msgid "As mentioned earlier, Idris has 4 different IRs that are available in the ``CompileData`` record: ``Named``, ``LambdaLifted``, ``ANF``, and ``VMDef``. When assembling the ``CompileData`` we have to tell the Idris compiler which level we are interested in. The ``CompileData`` contains lists of definitions that can be considered as top level definitions that the custom back-end need to generate functions for."
msgstr ""

#: ../source/backends/backend-cookbook.rst:411
#: a62d4729c91744d998dd50744bf7972b
msgid "There are four types of top-level definitions that the code generation back-end needs to support:"
msgstr ""

#: ../source/backends/backend-cookbook.rst:414
#: 5b13597029c64200980426fe34391d94
msgid "Function"
msgstr ""

#: ../source/backends/backend-cookbook.rst:415
#: 218caa990e4b4c509a5bd4e3530c38ae
msgid "Constructor"
msgstr ""

#: ../source/backends/backend-cookbook.rst:416
#: 9f450e22f7024e1ba0b8888ce31020fa
msgid "Foreign call"
msgstr ""

#: ../source/backends/backend-cookbook.rst:417
#: 3f545bdf5c024822a1fe35e8a19979f1
msgid "Error"
msgstr ""

#: ../source/backends/backend-cookbook.rst:419
#: e56bd3d0c73c4f2099e005b35444fb1d
msgid "**Function** contains a lambda calculus like expression."
msgstr ""

#: ../source/backends/backend-cookbook.rst:421
#: b51ef32b41214de1affd9fdba34a0fe9
msgid "**Constructor** represents a data or a type constructor, and it should be implemented as a function creating the corresponding data structure in the custom back-end."
msgstr ""

#: ../source/backends/backend-cookbook.rst:425
#: a9711f305ac248c283ac6e32bc5cbc49
msgid "A top-level **foreign call** defines an entry point for calling functions implemented outside the Idris program under compilation. The Foreign construction contains a list of Strings which are the snippets defined by the programmer, the type of the arguments and the return type of the foreign function. The custom back-end should generate a wrapper function. More on this on `How to implement the Foreign Function Interface?`_"
msgstr ""

#: ../source/backends/backend-cookbook.rst:432
#: 4c65672acd4d4e6fb99e66ac3472444e
msgid "A top-level **error** definition represents holes in Idris programs, uses of ``idris_crash``, or unreachable branches in a case tree. Users may want to execute incomplete programs for testing purposes which is fine as long as we never actually need the value of any of the holes. Library writers may want to raise an exception if an unrecoverable error has happened. Finally, Idris compiles the unreachable branches of a case tree to runtime error as it is dead code anyway."
msgstr ""

#: ../source/backends/backend-cookbook.rst:445
#: 1b2437c583a84664b1c6600b78ce594f
msgid "The custom back-end should decide which intermediate representation is used as a starting point. The result of the transformation should be expressions and functions of the host technology."
msgstr ""

#: ../source/backends/backend-cookbook.rst:449
#: 3cd555638ed94382b6feaf1888cf37ba
msgid "Definitions in ``ANF`` and ``Lifted`` are represented as a tree like expression, where control flow is based on the ``Let`` and ``Case`` expressions."
msgstr ""

#: ../source/backends/backend-cookbook.rst:453
#: 9dd7636a35324b318fe1bfe17bff9213
msgid "Case expressions"
msgstr ""

#: ../source/backends/backend-cookbook.rst:455
#: 50545eddd2bf497a93322f22f96188b6
msgid "There are two types of case expressions, one for matching and branching on primitive values such as ``Int``, and the second one is matching and branching on constructor values. The two types of case expressions will have two different representation for alternatives of the cases. These are ``ConstCase`` (for matching on constant values) and ``ConCase`` (for matching on constructors)."
msgstr ""

#: ../source/backends/backend-cookbook.rst:462
#: 14ca91527bdc42579195a93fc73a21da
msgid "Matching on constructors can be implemented as matching on their tags or, less efficiently, as matching on the name of the constructor. In both cases a match should bind the values of the constructor's arguments to variables in the body of the matching branch. This can be implemented in various ways depending on the host technology: switch expressions, case with pattern matching, or if-then-else chains."
msgstr ""

#: ../source/backends/backend-cookbook.rst:469
#: b8f5459518ea4b48ab3682d570d8b65a
msgid "When pattern matching binds variables, the number of arguments can be different from the arity of the constructor defined in top-level definitions and in ``GlobalDef``. This is because all the arguments are kept around at typechecking time, but the code generator for the case tree removes the ones which are marked as erased. The code generator of the custom back-end also needs to remove the erased arguments in the constructor implementation. In ``GlobalDef``, ``eraseArg`` contains this information, which can be used to extract the number of arguments which needs to be kept around."
msgstr ""

#: ../source/backends/backend-cookbook.rst:480
#: 01c9af6e566842dea15264a8b2b2b7be
msgid "Creating values"
msgstr ""

#: ../source/backends/backend-cookbook.rst:482
#: f4e4093e01244be995e72957cf0efdee
msgid "Values can be created in two ways."
msgstr ""

#: ../source/backends/backend-cookbook.rst:484
#: f1cc6aefcb664b2780b5518e5d90269e
msgid "If the value is a primitive value, it will be handed to the back-end as a ``PrimVal``. It should be compiled to a constant in the host language following the  design decisions made in the 'How to represent primitive values?' section."
msgstr ""

#: ../source/backends/backend-cookbook.rst:489
#: 527feedbea4f4a55868644fa806d15d8
msgid "If it is a structured value (i.e. a ``Con``) it should be compiled to a function in the host language which creates a dynamic value. Design decisions made for 'How to represent constructor values?' is going to have effect here."
msgstr ""

#: ../source/backends/backend-cookbook.rst:494
#: c3daeb5f3a30402bb1f95d2a22f33118
msgid "Function calls"
msgstr ""

#: ../source/backends/backend-cookbook.rst:496
#: 077569dd5d984c16b26c46c694e7928f
msgid "There are four types of function calls: - Saturated function calls (all the arguments are there) - Under-applied function calls (some arguments are missing) - Primitive function calls (necessarily saturated, ``PrimFn`` constructor) - Foreign Function calls (referred to by its name)"
msgstr ""

#: ../source/backends/backend-cookbook.rst:502
#: cfa379cb03914602bf89a8fee7b3130c
msgid "The ``ANF`` and ``Lifted`` intermediate representations support under-applied function calls (using the ``UnderApp`` constructor in both IR). The custom back-end needs to support partial application of functions and creating closures in the host technology. This is not a problem with back-ends like Scheme where we get the partial application of a function for free. But if the host language does not have this tool in its toolbox, the custom back-end needs to simulate closures. One possible solution is to manufacture a closure as a special object storing the function and the values it is currently applied to and wait until all the necessary arguments have been received before evaluating it. The same approach is needed if the ``VMCode`` IR was chosen for code generation."
msgstr ""

#: ../source/backends/backend-cookbook.rst:516
#: 6961781efe864ac5a24ef104dc4082f9
msgid "Let bindings"
msgstr ""

#: ../source/backends/backend-cookbook.rst:518
#: 5528f658bb604fb9a354144f64353691
msgid "Both the ``ANF`` and ``Lifted`` intermediate representations have a ``Let`` construct that lets users assign values to local variables. These two IRs differ in their representation of bound variables."
msgstr ""

#: ../source/backends/backend-cookbook.rst:522
#: f92b316ebe61413e9e0a8624766d2e96
msgid "``Lifted`` is a type family indexed by the ``List Name`` of local variables in scope. A variable is represented using ``LLocal``, a constructor that stores a ``Nat`` together with a proof that it points to a valid name in the local scope."
msgstr ""

#: ../source/backends/backend-cookbook.rst:527
#: 62107f9edb8d4b56a92735e81a1e6c2c
msgid "``ANF`` is a lower level representation where this kind of guarantees are not present anymore. A local variable is represented using the ``AV`` constructor which stores an ``AVar`` whose definition we include below. The ``ALocal`` constructor stores an ``Int`` that corresponds to the ``Nat`` we would have seen in ``Lifted``. The ``ANull`` constructor refers to an erased variable and its representation in the host language will depend on the design choices made in the 'How to represent ``Erased`` values' section."
msgstr ""

#: ../source/backends/backend-cookbook.rst:542
#: f945c3ec19be44ed9bb31dbf31d2fcdc
msgid "VMDef specificities"
msgstr ""

#: ../source/backends/backend-cookbook.rst:544
#: 01f863031462459c97d5054ae71c3103
msgid "``VMDef`` is meant to be the closest IR to machine code. In ``VMDef``, all the definitions have been compiled to instructions for a small virtual machine with registers and closures."
msgstr ""

#: ../source/backends/backend-cookbook.rst:548
#: 3851b827b5174e72acd09142591c7136
msgid "Instead of ``Let`` expressions, there only are ``ASSIGN`` statements at this level."
msgstr ""

#: ../source/backends/backend-cookbook.rst:551
#: 1a0f0535674d4cb3981eaf8cbee6926e
msgid "Instead of ``Case`` expressions binding variables when they successfully match on a data constructor, ``CASE`` picks a branch based on the constructor itself. An extra operation called ``PROJECT`` is introduced to explicitly extract a constructor's argument based on their position."
msgstr ""

#: ../source/backends/backend-cookbook.rst:556
#: e59db29e18ab44fab5158d9c716f8678
msgid "There are no ``App`` or ``UnderApp``. Both are replaced by ``APPLY`` which applies only one value and creates a closure from the application. For erased values the operation ``NULL`` assigns an empty/null value for the register."
msgstr ""

#: ../source/backends/backend-cookbook.rst:561
#: 666708aaf0b94b4696fd856509f3ca81
msgid "How to implement the Foreign Function Interface?"
msgstr ""

#: ../source/backends/backend-cookbook.rst:563
#: 764670db0995456a8dbc0e9ce0c1fcd2
msgid "The Foreign Function Interface (FFI) plays a big role in running Idris programs. The primitive operations which are mentioned above are functions for manipulating values and those functions aren't meant for complex interaction with the runtime system. Many of the primitive types can be thought of as abstract types provided via ``external`` and foreign functions to manipulate them."
msgstr ""

#: ../source/backends/backend-cookbook.rst:570
#: e143f2df69e842cfa232989996bed347
msgid "The responsibility of the custom back-end and the host technology is to represent these computations the operationally correct way. The design decisions with respect to representing primitive types in the host technology will inevitably have effects on the design of the FFI."
msgstr ""

#: ../source/backends/backend-cookbook.rst:576
#: 3b99e3052b6446c2a9c61a131c0ea022
msgid "Foreign Types"
msgstr ""

#: ../source/backends/backend-cookbook.rst:578
#: 4948556feaab4c588809ca33fba36394
msgid "Originally Idris had an official back-end implementation in C. Even though this has changed, the names in the types for the FFI kept their C prefix. The ``Core.CompileExpr.CFType`` contains the following definitions, many of them one-to-one mapping from the corresponding primitive type, but some of them needs explanation."
msgstr ""

#: ../source/backends/backend-cookbook.rst:584
#: 636e50e36ced473290cb5e8089f3fd41
msgid "The foreign types are:"
msgstr ""

#: ../source/backends/backend-cookbook.rst:586
#: d48488392995494d8582272c4b5f29e0
msgid "``CFUnit``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:587
#: 567e9659d7bb4176bc8fc25198c64d7b
msgid "``CFInt``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:588
#: c475353c22ca431981f698b35ef68508
msgid "``CFUnsigned(8/16/32/64)``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:589
#: c67459a8e387471d8a0e201d7e4521d8
msgid "``CFString``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:590
#: f84fc707cafe42948de456ff58eaf41e
msgid "``CFDouble``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:591
#: 4049f11adc054dcdb8e16f4ee6141c49
msgid "``CFChar``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:592
#: cfdcd6e9b8544807aebceb57eb18bad9
msgid "``CFFun`` of type  ``CFType -> CFType -> CFType`` Callbacks can be registered in the host technology via parameters that have CFFun type. The back-end should be able to handle functions that are defined in Idris side and compiled to the host technology. If the custom back-end supports higher order functions then it should be used to implement the support for this kind of FFI type."
msgstr ""

#: ../source/backends/backend-cookbook.rst:598
#: 6c18f8da6fb84ba6bd618cbb8f835597
msgid "``CFIORes`` of type ``CFType -> CFType`` Any ``PrimIO`` defined computation will have this extra layer. Pure functions shouldn't have any observable IO effect on the program state in the host technology implemented runtime. NOTE: ``IORes`` is also used when callback functions are registered in the host technology."
msgstr ""

#: ../source/backends/backend-cookbook.rst:604
#: d84557a424584ecea5cbde214cc9717a
msgid "``CFWorld`` Represents the current state of the world. This should refer to a token that is passed around between function calls. The implementation of the World value should contain back-end specific values and information about the state of the Idris runtime."
msgstr ""

#: ../source/backends/backend-cookbook.rst:609
#: 69e40994c1a94d89965586ca3883bc12
msgid "``CFStruct`` of type ``String -> List (String, CFType) -> CFType`` is the foreign type associated with the ``System.FFI.Struct``. It represents a C like structure in the custom back-end. ``prim__getField`` and ``prim__setField`` primitives should be implemented to support this CFType."
msgstr ""

#: ../source/backends/backend-cookbook.rst:614
#: 209c692a8a5b4caa9eb14b2e35315349
msgid "``CFUser`` of type ``Name -> List CFType -> CFType`` Types defined with [external] are represented with ``CFUser``. For example ``data MyType : Type where [external]`` will be represented as ``CFUser Module.MyType []``"
msgstr ""

#: ../source/backends/backend-cookbook.rst:618
#: 66f845458b7d414a9ec2f7316dab4772
msgid "``CFBuffer`` Foreign type defined for ``Data.Buffer``. Although this is an external type, Idris builds on a random access buffer."
msgstr ""

#: ../source/backends/backend-cookbook.rst:621
#: c4dd6d6864ba49798526ec7b053948df
msgid "``CFPtr`` The ``Ptr t`` and ``AnyPtr`` are compiled to ``CFPtr`` Any complex structured data that can not be represented as a simple primitive can use this CFPtr to keep track where the value is used. In Idris ``Ptr t`` is defined as external type."
msgstr ""

#: ../source/backends/backend-cookbook.rst:625
#: 5a75da1126d2430998f6e08dbeec88dc
msgid "``CFGCPtr`` The ``GCPtr t`` and ``GCAnyPtr`` are compiled to ``CFGCPtr``. ``GCPtr`` is inferred from a Ptr value calling the ``onCollect`` function and has a special property. The ``onCollect`` attaches a finalizer for the pointer which should run when the pointer is freed."
msgstr ""

#: ../source/backends/backend-cookbook.rst:631
#: 0dfbcdf9019643769473f0eeebeb4dbf
msgid "Examples"
msgstr ""

#: ../source/backends/backend-cookbook.rst:633
#: fdeff52f70c24e4786980fe1bf835d22
msgid "Let's step back and look into how this is represented at the Idris source level. The simplest form of a definition involving the FFI a function definition with a ``%foreign`` pragma. The pragma is passed a list of strings corresponding to a mapping from backends to names for the foreign calls. For instance:"
msgstr ""

#: ../source/backends/backend-cookbook.rst:643
#: 2f1a346db5d84c5e8e8ce1edf27818f6
msgid "this function should be translated by the C back end as a call to the ``add`` function defined in the ``smallc.c`` file. In the FFI, ``Int`` is translated to ``CFInt``. The back-end assumes that the data representation specified in the library file correspond to that of normal Idris values."
msgstr ""

#: ../source/backends/backend-cookbook.rst:648
#: 40ae60cb284b4f07a69cb6baa26b578f
msgid "We can also define ``external`` types like in the following examples:"
msgstr ""

#: ../source/backends/backend-cookbook.rst:657
#: b01f77996a1a4238b2a05e5e723e95c5
msgid "Here ``ThreadID`` is defined as an external type and this type will be represented as ``CFUser \"ThreadID\" []`` internally. The value which is created by the scheme runtime will be considered as a black box."
msgstr ""

#: ../source/backends/backend-cookbook.rst:661
#: b11e4eb7a08447fb80b2a92e9503c6cb
msgid "The type of ``prim__fork``, once translated as a foreign type, is ``[%World -> IORes Unit, %World] -> IORes Main.ThreadID`` Here we see that the ``%World`` is added to the IO computations. The ``%World`` parameter is always the last in the argument list."
msgstr ""

#: ../source/backends/backend-cookbook.rst:666
#: ea5b6d47e6134f39b9fd01755328fd04
msgid "For the FFI functions, the type information and the user defined string can be found in the top-level definitions. The custom back-end should use the definitions to generate wrapper code, which should convert the types that are described by the ``CFType`` to the types that the function in the ``%foreign`` directive needs.."
msgstr ""

#: ../source/backends/backend-cookbook.rst:675
#: 03f551530f484910bbe13c83a2c0db9e
msgid "The Idris compiler generates intermediate files for modules, the content of the files are neither part of ``Lifted``, ``ANF``, nor ``VMCode``. Because of this, when the compilation pipeline enters the stage of code generation, all the information will be in one instance of the ``CompileData`` record and the custom code generator back-end can process them as it would see the whole program."
msgstr ""

#: ../source/backends/backend-cookbook.rst:682
#: 90c5e3d6aba546b1a2170d166ed02050
msgid "The custom back-end has the option to introduce some hierarchy for the functions in different namespaces and organize some module structure to let the host technology process the bits and pieces in different sized chunks. However, this feature is not in the scope of the Idris compiler."
msgstr ""

#: ../source/backends/backend-cookbook.rst:687
#: 20f2a826040448cf8ce06998baa765f9
msgid "It is worth noting that modules can be mutually recursive in Idris. So a direct compilation of Idris modules to modules in the host language may be unsuccessful."
msgstr ""

#: ../source/backends/backend-cookbook.rst:694
#: d8cdebc82e08419da04f00dccb587d45
msgid "A possible motivation for implementing a custom back-end for Idris is to generate code that is meant to be used in a larger project. This project may be bound to another language that has many useful librarie  but could benefit from relying on Idris' strong type system in places."
msgstr ""

#: ../source/backends/backend-cookbook.rst:699
#: 1e1ee2dbbe6a49f8a1ec5d6a29a3f872
msgid "When writing a code generator for this purpose, the interoperability of the host technology and Idris based on the Foreign Interface can be inconvenient. In this situation, the need to embed code of the host technology arises naturally. Elaboration can be an answer for that."
msgstr ""

#: ../source/backends/backend-cookbook.rst:704
#: 2dac3384b44240c2836aa557101578d5
msgid "Elaboration is a typechecking time code generation technique. It relies on the ``Elab`` monad to write scripts that can interact with the typechecking machinery to generate Idris code in ``Core.TT``."
msgstr ""

#: ../source/backends/backend-cookbook.rst:708
#: 52d5b9f3922a4fa3b815fd37fc7ed29f
msgid "When code snippets need to be embedded a custom library should be provided with the custom back-end to turn the valid code snippets into their representation in ``Core.TT``."
msgstr ""

#: ../source/backends/backend-cookbook.rst:715
#: 58d638b76e5b4fc8b62dd3236102717c
msgid "As a summary, a custom back-end for the Idris compiler should create an environment in the host technology that is able to run Idris programs. As Idris is part of the family of functional programming languages, its computation model is based on graph reduction. Programs represented as simple graphs in the memory are based on the closure creation mechanism during evaluation. Closure creation exist even on the lowest levels of IRs. For that reason any runtime in any host technology needs to support some kind of representation of closures and be able to store them on the heap, thus the responsibility of memory management falls on the lap of the implementor of the custom back-end. If the host technology has memory management, the problem is not difficult. It is also likely that storing closures can be easily implemented via the tools of the host technology."
msgstr ""

#: ../source/backends/backend-cookbook.rst:727
#: aa7fb9df8080485d87a786410fb23011
msgid "Although it is not clear how much functionality a back-end should support. Tools from the Scheme back-end are brought into the Idris world via external types and primitive operations around them. This is a good practice and gives the community the ability to focus on the implementation of a quick compiler for a dependently typed language. One of these hidden features is the concurrency primitives. These are part of the different libraries that could be part of the compiler or part of the contribution package. If the threading model is different for the host technology that the Idris default back-end inherits currently from the Scheme technology it could be a bigger piece of work."
msgstr ""

#: ../source/backends/backend-cookbook.rst:737
#: 2840d2ce700d43b8b351da0b1f661c46
msgid "IO in Idris is implemented using an abstract ``%World`` value, which serves as token for functions that operate interactively with the World through simple calls to the underlying runtime system. The entry point of the program is the main function, which has the type of the IO unit, such as ``main : IO ()``. This means that every program which runs, starts its part of some IO computation. Under the hood this is implemented via the creation of the ``%World`` abstract value, and invoking the main function, which is compiled to pass the abstract %World value for IO related foreign or external operations."
msgstr ""

#: ../source/backends/backend-cookbook.rst:746
#: b35242fe6d734fea8e4b1d2f5a286752
msgid "There is an operation called ``unsafePerformIO`` in the ``PrimIO`` module. The type signature of ``unsafePerformIO`` tells us that it is capable of evaluating an ``IO`` computation in a pure context. Under the hood it is run in exactly the same way the ``main`` function is. It manufactures a fresh ``%World`` token and passes it to the ``IO`` computations. This leads to a design decision: How to represent the state of the World, and how to represent the world that is instantiated for the sake of the ``unsafePerformIO`` operation via the ``unsafeCreateWorld``? Both the mechanisms of ``main`` and ``unsafeCreateWorld`` use the ``%MkWorld`` constructor, which will be compiled to ``WorldVal`` and its type to ``WorldType``, which means the implementation of the runtime is responsible for creating the abstraction around the World. Implementation of an abstract World value could be based on a singleton pattern, where we can have just one world, or we could have more than one world, resulting in parallel universes for ``unsafePerformIO``."
msgstr ""
