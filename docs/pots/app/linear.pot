# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-23 12:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/app/linear.rst:2
#: c67340197c1442e9802635c51be76c68
msgid "Linear Resources"
msgstr ""

#: ../source/app/linear.rst:4
#: 71c121fa069e4727a81dddd16123125c
msgid "We have introduced ``App`` for writing interactive programs, using interfaces to constrain which operations are permitted, but have not yet seen the ``Path`` parameter in action. Its purpose is to constrain when programs can throw exceptions, to know where linear resource usage is allowed. The bind operator for ``App`` is defined as follows (not via ``Monad``):"
msgstr ""

#: ../source/app/linear.rst:20
#: 74926b183e7b4ff699fe2bc157af7da2
msgid "The intuition behind this type is that, when sequencing two ``App`` programs:"
msgstr ""

#: ../source/app/linear.rst:23
#: 04e9559673ec45c4b92042ddb5c7dd4b
msgid "if the first action might throw an exception, then the whole program might throw."
msgstr ""

#: ../source/app/linear.rst:25
#: 693b6b1973544db6b03fd3cffe56d42e
msgid "if the first action cannot throw an exception, the second action can still throw, and the program as a whole can throw."
msgstr ""

#: ../source/app/linear.rst:27
#: 8103ba77dc984c71aa3443e35aa53500
msgid "if neither action can throw an exception, the program as a whole cannot throw."
msgstr ""

#: ../source/app/linear.rst:30
#: d94402ec63234a9db70ee3732e29e665
msgid "The reason for the detail in the type is that it is useful to be able to sequence programs with a different ``Path``, but in doing so, we must calculate the resulting ``Path`` accurately. Then, if we want to sequence subprograms with linear variables, we can use an alternative bind operator which guarantees to run the continuation exactly once:"
msgstr ""

#: ../source/app/linear.rst:42
#: 61315ee54bb348fd90f29f8637c30e4d
msgid "To illustrate the need for ``bindL``, we can try writing a program which tracks the state of a secure data store, which requires logging in before reading the data."
msgstr ""

#: ../source/app/linear.rst:47
#: 16a8096996154f0d8bfb981403251948
msgid "Example: a data store requiring a login"
msgstr ""

#: ../source/app/linear.rst:49
#: 336039cf7b65413084dfa25de35f4b2f
msgid "Many software components rely on some form of state, and there may be operations which are only valid in specific states. For example, consider a secure data store in which a user must log in before getting access to some secret data. This system can be in one of two states:"
msgstr ""

#: ../source/app/linear.rst:54
#: 2da483d3685546c6bf1b95b68f9b265d
msgid "``LoggedIn``, in which the user is allowed to read the secret"
msgstr ""

#: ../source/app/linear.rst:55
#: f32d8621744e4ea1a0f191457dce7d16
msgid "``LoggedOut``, in which the user has no access to the secret"
msgstr ""

#: ../source/app/linear.rst:57
#: b8b5ad01928e4c68916f7f97891e079f
msgid "We can provide commands to log in, log out, and read the data, as illustrated in the following diagram:"
msgstr ""

#: ../source/app/linear.rst:60
#: b813459616f14a30868990f0bfa65f0c
msgid "|login|"
msgstr ""

#: ../source/app/linear.rst:126
#: 4d8aac8fd0184086b065fefc5666414b
#: 514a1f0eeba24474b0d00a20e2503546
msgid "login"
msgstr ""

#: ../source/app/linear.rst:62
#: 3dbdb0eed22d465cb4c0d4925b46fc3b
msgid "The ``login`` command, if it succeeds, moves the overall system state from ``LoggedOut`` to ``LoggedIn``. The ``logout`` command moves the state from ``LoggedIn`` to ``LoggedOut``. Most importantly, the ``readSecret`` command is only valid when the system is in the ``LoggedIn`` state."
msgstr ""

#: ../source/app/linear.rst:67
#: b5e64d04f68b49aa89e7cd016e792d34
msgid "We can represent the state transitions using functions with linear types. To begin, we define an interface for connecting to and disconnecting from a store:"
msgstr ""

#: ../source/app/linear.rst:78
#: c07f3a79efc94e7780c7850effa9b435
msgid "Neither ``connect`` nor ``disconnect`` throw, as shown by generalising over ``l``. Once we have a connection, we can use the following functions to access the resource directly:"
msgstr ""

#: ../source/app/linear.rst:94
#: ec97e173434647f58f27977a5397cd9d
msgid "``Res`` is defined in the Prelude, since it is commonly useful.  It is a dependent pair type, which associates a value with a linear resource. We'll leave the other definitions abstract, for the purposes of this introductory example."
msgstr ""

#: ../source/app/linear.rst:99
#: 6129eae5431b410fa5f213a3509da842
msgid "The following listing shows a complete program accessing the store, which reads a password, accesses the store if the password is correct and prints the secret data. It uses ``let (>>=) = bindL`` to redefine ``do``-notation locally."
msgstr ""

#: ../source/app/linear.rst:119
#: ba10d31af905426e90d3bb73a8ff2fed
msgid "If we omit the ``let (>>=) = bindL``, it will use the default ``(>>=)`` operator, which allows the continuation to be run multiple times, which would mean that ``s`` is not guaranteed to be accessed linearly, and ``storeProg`` would not type check. We can safely use ``getStr`` and ``putStr`` because they are guaranteed not to throw by the ``Path`` parameter in their types."
msgstr ""

#: ../source/app/linear.rst:130
#: 16a59a302f574fa0a743dc875b04f637
msgid "App1: Linear Interfaces"
msgstr ""

#: ../source/app/linear.rst:132
#: a84075c3fd214d90ac3b9e12d1f747a1
msgid "Adding the ``bindL`` function to allow locally rebinding the ``(>>=)`` operator allows us to combine existing linear resource programs with operations in ``App`` - at least, those that don't throw. It would nevertheless be nice to interoperate more directly with ``App``. One advantage of defining interfaces is that we can provide multiple implementations for different contexts, but our implementation of the data store uses primitive functions (which we left undefined in any case) to access the store."
msgstr ""

#: ../source/app/linear.rst:141
#: d520685d209e4c47a9aa7500db3bb4a8
msgid "To allow control over linear resources, ``Control.App`` provides an alternative parameterised type ``App1``:"
msgstr ""

#: ../source/app/linear.rst:149
#: 95830cb8e95f4ded895f4c147b01e959
msgid "There is no need for a ``Path`` argument, since linear programs can never throw. The ``Usage`` argument states whether the value returned is to be used once, or has unrestricted usage, with the default in ``App1`` being to use once:"
msgstr ""

#: ../source/app/linear.rst:158
#: 85a885101b5e4db5ac41f1b8b37507d5
msgid "The main difference from ``App`` is the ``(>>=)`` operator, which has a different multiplicity for the variable bound by the continuation depending on the usage of the first action:"
msgstr ""

#: ../source/app/linear.rst:171
#: 9975ae63407043b0b3f679cd465bf8d7
msgid "``Cont1Type`` returns a continuation which uses the argument linearly, if the first ``App1`` program has usage ``One``, otherwise it returns a continuation where argument usage is unrestricted. Either way, because there may be linear resources in scope, the continuation is run exactly once and there can be no exceptions thrown."
msgstr ""

#: ../source/app/linear.rst:177
#: 66921b1528674047b0cc87d4740f1743
msgid "Using ``App1``, we can define all of the data store operations in a single interface, as shown in the following listing. Each operation other than ``disconnect`` returns a `linear` resource."
msgstr ""

#: ../source/app/linear.rst:193
#: f2c1369cd97f40689634b41fd1ac4fa7
msgid "We can explicitly move between ``App`` and ``App1``:"
msgstr ""

#: ../source/app/linear.rst:200
#: 01b1e4a37b1c4a288acf3472c8e502dd
msgid "We can run an ``App`` program using ``app``, inside ``App1``, provided that it is guaranteed not to throw. Similarly, we can run an ``App1`` program using ``app1``, inside ``App``, provided that the value it returns has unrestricted usage. So, for example, we can write:"
msgstr ""

#: ../source/app/linear.rst:214
#: 96a6cdbd7f084805b62ad21e252670cb
msgid "This uses ``app1`` to state that the body of the program is linear, then ``app`` to state that the ``putStr`` operation is in ``App``. We can see that ``connect`` returns a linear resource by inspecting the hole ``what_next``, which also shows that we are running inside ``App1``:"
msgstr ""

#: ../source/app/linear.rst:227
#: fedb4ca58e474230981d24424567fe39
msgid "For completeness, one way to implement the interface is as follows, with hard coded password and internal data:"
msgstr ""

#: ../source/app/linear.rst:247
#: 93054fe65c524ed4b9ab84960ca87139
msgid "Then we can run it in ``main``:"
msgstr ""
