# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-23 12:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/implementation/overview.rst:3
#: 8d5c10f7f9bb4f71b299842b40e043c4
msgid "Implementation Overview"
msgstr ""

#: ../source/implementation/overview.rst:5
#: 5e7fae778a764873a39c306b187960ab
msgid "These are some unsorted notes on aspects of the implementation. Sketchy, and not always completely up to date, but hopefully give some hints as to what's going on and some ideas where to look in the code to see how certain features work."
msgstr ""

#: ../source/implementation/overview.rst:11
#: 5a281c2007114102ab8c3035cfa605d1
msgid "Introduction"
msgstr ""

#: ../source/implementation/overview.rst:13
#: 3d4d307282fc4c9c81b72d1461c490f4
msgid "Core language TT (defined in ``Core.TT``), based on quantitative type theory (see https://bentnib.org/quantitative-type-theory.html). Binders have \"multiplicities\" which are either *0*, *1* or *unlimited*."
msgstr ""

#: ../source/implementation/overview.rst:17
#: 20e1013b18214f55b8edab8058c0bfc8
msgid "Terms are indexed over the names in scope so that we know terms are always well scoped. Values (i.e. normal forms) are defined in ``Core.Value`` as ``NF``; constructors do not evaluate their arguments until explicitly requested."
msgstr ""

#: ../source/implementation/overview.rst:21
#: 417a63c149b242ea94fc4e7044151fd5
msgid "Elaborate to *TT* from a higher level language *TTImp* (defined in ``TTImp.TTImp``), which is TT with implicit arguments, local function definitions, case blocks, as patterns, qualified names with automatic type-directed disambiguation, and proof search."
msgstr ""

#: ../source/implementation/overview.rst:26
#: d785dc2b41f34f02b822faf835c3ff0b
msgid "Elaboration relies on unification (in ``Core.Unify``), which allows postponing of unification problems. Essentially works the same way as Agda as described in Ulf Norell's thesis."
msgstr ""

#: ../source/implementation/overview.rst:30
#: af74f43bca054314b2a11c1ff932e376
msgid "General idea is that high level languages will provide a translation to TT. In the ``Idris/`` namespace we define the high level syntax for Idris, which translates to TTImp by desugaring operators, do notation, etc."
msgstr ""

#: ../source/implementation/overview.rst:34
#: 904ee4cbe64a45ad899247db9b62eb24
msgid "There is a separate linearity check after elaboration, which updates types of holes (and is aware of case blocks). This is implemented in ``Core.LinearCheck``. During this check, we also recalculate the multiplicities in hole applications so that they are displayed appropriately (e.g. if a linear variable is unused elsewhere, it will always appear with multiplicity 1 in holes)."
msgstr ""

#: ../source/implementation/overview.rst:42
#: 0aba8bb750a948438323d3ee40bdf35d
msgid "Where to find things:"
msgstr ""

#: ../source/implementation/overview.rst:44
#: ec91b2b56f59479b90dcdc8c88b1a445
msgid "``Core/`` -- anything related to the core TT, typechecking and unification"
msgstr ""

#: ../source/implementation/overview.rst:45
#: b4c0f7203387439bb1ba34b4ca4408fe
msgid "``TTImp/`` -- anything related to the implicit TT and its elaboration"
msgstr ""

#: ../source/implementation/overview.rst:47
#: 6cd637aa9ce640ad919f18d229cc2cec
msgid "``TTImp/Elab/`` -- Elaboration state and elaboration of terms"
msgstr ""

#: ../source/implementation/overview.rst:48
#: 27b0497e5c474890b20fa211d553ab87
msgid "``TTImp/Interactive/`` -- Interactive editing infrastructure"
msgstr ""

#: ../source/implementation/overview.rst:50
#: cd3fb1f10b9143309f80d8afc6f8670d
msgid "``Parser/`` -- various utilities for parsing and lexing TT and TTImp (and other things)"
msgstr ""

#: ../source/implementation/overview.rst:51
#: 17b45f8334614d34a91635f6589fcbd7
msgid "``Utils/`` -- some generally useful utilities"
msgstr ""

#: ../source/implementation/overview.rst:52
#: 43854d680ed44153a4b82b0c662fb39d
msgid "``Idris/`` -- anything relating to the high level language, translating to TTImp"
msgstr ""

#: ../source/implementation/overview.rst:54
#: f4c37180cff44b3888485294001c237f
msgid "``Idris/Elab/`` -- High level construct elaboration machinery (e.g. interfaces)"
msgstr ""

#: ../source/implementation/overview.rst:56
#: 7110c61e4d7b4754948b667068c24fda
msgid "``Compiler/`` -- back ends"
msgstr ""

#: ../source/implementation/overview.rst:59
#: de88e167c0514b03baacd33eccb7cdc3
msgid "The Core Type, and Ref"
msgstr ""

#: ../source/implementation/overview.rst:61
#: cd49cb91ffca4ac99e776af39e14635d
msgid "``Core`` is a \"monad\" (not really, for efficiency reasons, at the moment...) supporting ``Error``'s and ``IO`` (I did originally plan to allow restricting this to some specific IO operations, but haven't yet).  The raw syntax is defined by a type ``RawImp`` which has a source location at each node, and any errors in elaboration note the location at the point where the error occurred, as a file context ``FC``."
msgstr ""

#: ../source/implementation/overview.rst:68
#: 5e72905da7f2472aac6abb16a236d024
msgid "``Ref`` is essentially an ``IORef``. Typically we pass them implicitly and use labels to disambiguate which one we mean. See ``Core.Core`` for their definition. Again, ``IORef`` is for efficiency - even if it would be neater to use a state monad this turned out to be about 2-3 times faster, so I'm going with the \"ugly\" choice..."
msgstr ""

#: ../source/implementation/overview.rst:75
#: 931514501deb41358e71bbe6cd7bf01c
msgid "Term representation"
msgstr ""

#: ../source/implementation/overview.rst:77
#: a9d1edaeb6d341398014884cfeeab148
msgid "Terms in the core language are indexed by a list of the names in scope, most recently defined first:"
msgstr ""

#: ../source/implementation/overview.rst:84
#: 767292e74a3143ca8217ba86ac22a071
msgid "This means that terms are always well scoped, and we can use the type system to keep us right when manipulating names. For example, we have:"
msgstr ""

#: ../source/implementation/overview.rst:92
#: ac6e4e11c0ad4cfb93fdb45886c07884
msgid "So local variables are represented by an index into the local context (a de Bruijn index, ``idx``), and a proof, erased at run time, that the index is valid. So everything is de Bruijn indexed, but the type checker still keeps track of the indices so that we don't have to think too hard!"
msgstr ""

#: ../source/implementation/overview.rst:97
#: 645a64541ce74fb4a76ef2d4c1c3d1ac
msgid "``Core.TT`` contains various handy tools for manipulating terms with their indices, such as:"
msgstr ""

#: ../source/implementation/overview.rst:108
#: 553ce2664c564f589e6fc15e163af5f2
msgid "Note that the types are explicit about when the ``vars`` needs to be passed at run time, and when it isn't. Mostly where it's needed it's to help with displaying names, or name generation, rather than any fundamental reason in the core. In general, this isn't expensive at run time."
msgstr ""

#: ../source/implementation/overview.rst:113
#: f86762b1760d45159b931409e7728927
msgid "Environments, defined in ``Core.Env``, map local variables to binders:"
msgstr ""

#: ../source/implementation/overview.rst:119
#: fe0c3ea13e50421c82fb941407db61a9
msgid "A binders is typically a *lambda*, a *pi*, or a *let* (with a value), but can also be a *pattern variable*. See the definition of ``TT`` for more details. Where we have a term, we usually also need an ``Env``."
msgstr ""

#: ../source/implementation/overview.rst:123
#: b49e1d4a70004202ad9cba6d7d1b412e
msgid "We also have values, which are in head normal form, and defined in ``Core.Value``:"
msgstr ""

#: ../source/implementation/overview.rst:130
#: ff5ff735e2e547d781bcbc2327cc9735
msgid "We can convert a term to a value by normalising..."
msgstr ""

#: ../source/implementation/overview.rst:137
#: 436e7036a28e48e391c60246a544e7e4
msgid "...and back again, by quoting:"
msgstr ""

#: ../source/implementation/overview.rst:144
#: 5e8711a8073a465b818cd6470f3552e3
msgid "Both ``nf`` and ``quote`` are defined in ``Core.Normalise``. We don't always know whether we'll need to work with ``NF`` or ``Term``, so we also have a \"glued\" representation, ``Glued vars``, again defined in ``Core.Normalise``, which lazily computes either a ``NF`` or ``Term`` as required. Elaborating a term returns the type as a ``Glued vars``."
msgstr ""

#: ../source/implementation/overview.rst:150
#: 43b70800898d4ed3915964614f2f9a90
msgid "``Term`` separates ``Ref`` (global user defined names) from ``Meta``, which are globally defined metavariables. For efficiency, metavariables are only substituted into terms if they have non-0 multiplicity, to preserve sharing as much as possible."
msgstr ""

#: ../source/implementation/overview.rst:156
#: 7547c04b2b9a46798f36ca5ebad68ac3
msgid "Unification"
msgstr ""

#: ../source/implementation/overview.rst:157
#: 600c8e5029a04cab81956de08d26e038
msgid "Unification is probably the most important part of the elaboration process, and infers values for implicit arguments. That is, it finds values for the things which are referred to by ``Meta`` in ``Term``. It is defined in ``Core.Unify``, as the top level unification function has the following type:"
msgstr ""

#: ../source/implementation/overview.rst:174
#: e45c751491cf457e98662b328bf6af3f
msgid "The ``Unify`` interface is there because it is convenient to be able to define unification on ``Term`` and ``NF``, as well as ``Closure`` (which is part of ``NF`` to represent unevaluated arguments to constructors)."
msgstr ""

#: ../source/implementation/overview.rst:178
#: 9105a84da7fb42f88d9fdebb40b40cfc
msgid "This is one place where indexing over ``vars`` is extremely valuable: we have to keep the environment consistent, so unification won't accidentally introduce any scoping bugs!"
msgstr ""

#: ../source/implementation/overview.rst:182
#: 58802aad79d1496799e0f57c3f30aef1
msgid "Idris 2 implements pattern unification - see Adam Gundry's thesis for an accessible introduction."
msgstr ""

#: ../source/implementation/overview.rst:186
#: 1229b83491234b40821068c5e0e1ece6
msgid "Context"
msgstr ""

#: ../source/implementation/overview.rst:188
#: 82bfeedd1d114a2383b574be0c491b56
msgid "``Core.Context`` defines all the things needed for TT. Most importantly: ``Def`` gives definitions of names (case trees, builtins, constructors and holes, mostly); ``GlobalDef`` is a definition with all the other information about it (type, visibility, totality, etc); ``Context`` is a context mapping names to ``GlobalDef``, and ``Defs`` is the core data structure with everything needed to typecheck more definitions."
msgstr ""

#: ../source/implementation/overview.rst:195
#: 3fa9ef37d83b4cf78a0f99fe4328989c
msgid "The main Context type stores definitions in an array, indexed by a \"resolved name id\", an integer, for fast look up. This means that it also needs to be able to convert between resolved names and full names. The ``HasNames`` interface defines methods for going back and forth between structures with human readable names, and structures with resolved integer names."
msgstr ""

#: ../source/implementation/overview.rst:201
#: 9ebb7dcb55384b02bf3447fa358a3548
msgid "Since we store names in an array, all the lookup functions need to be in the ``Core`` monad. This also turns out to help with loading checked files (see below)."
msgstr ""

#: ../source/implementation/overview.rst:206
#: 4b8bd84e2f6a4f968efc69e7c7941e66
msgid "Elaboration Overview"
msgstr ""

#: ../source/implementation/overview.rst:208
#: b29e8f7eb4014fa3affdb553ff1b350b
msgid "Elaboration of ``RawImp`` to ``TT`` is driven by ``TTImp.Elab``, with the top level function for elaborating terms defined in ``TTImp.Elab.Term``, support functions defined in ``TTImp.Elab.Check``, and elaborators for the various TTImp constructs defined in separate files under ``TTImp.Elab.*``."
msgstr ""

#: ../source/implementation/overview.rst:214
#: cc8ce013caf74667953a79d8cb085636
msgid "Laziness"
msgstr ""

#: ../source/implementation/overview.rst:216
#: 1bf9846bd86640889da38f84814f7de5
msgid "Like Idris 1, laziness is marked in types using ``Lazy``, ``Delay`` and ``Force``, or ``Inf`` (instead of ``Lazy``) for codata. Unlike Idris 1, these are language primitives rather than special purpose names."
msgstr ""

#: ../source/implementation/overview.rst:220
#: 72e7f505ead1444db7e665a786b1d3c0
msgid "Implicit laziness resolution is handled during unification (in ``Core.Unify``). When unification is invoked (by ``convert`` in ``TTImp.Elab.Check``) with the ``withLazy`` flag set, it checks whether it is converting a lazy type with a non-lazy type. If so, it continues with unification, but returning that either a ``Force`` or ``Delay`` needs inserting as appropriate."
msgstr ""

#: ../source/implementation/overview.rst:227
#: fbc98746965c4df08c865a0a66dc6da0
msgid "TTC format"
msgstr ""

#: ../source/implementation/overview.rst:229
#: 0be03e6ef49f4184bf00c39baf2caa94
msgid "We can save things to binary if we have an implementation of the TTC interface for it. See ``Utils.Binary`` to see how this is done. It uses a global reference ``Ref Bin Binary`` which uses ``Data.Buffer`` underneath."
msgstr ""

#: ../source/implementation/overview.rst:233
#: e81ee765863747c4ba5beeb3f693da82
msgid "When we load checked TTC files, we don't process the definitions immediately, but rather store them as a ``ContextEntry``, which is either a ``Binary`` blob, or a processed definition. We only process the definitions the first time they are looked up, since converting Binary to the definition is fairly costly (due to having to construct a lot of AST nodes), and often definitions in an imported file are never used."
msgstr ""

#: ../source/implementation/overview.rst:241
#: 6137c922297f478abadf1bde1515ab24
msgid "Bound Implicits"
msgstr ""

#: ../source/implementation/overview.rst:243
#: 3e8ec43222184c8bbde8c1487d21aa36
msgid "The ``RawImp`` type has a constructor ``IBindVar``. The first time we encounter an ``IBindVar``, we record the name as one which will be implicitly bound. At the end of elaboration, we decide which holes should turn into bound variables (Pi bound in types, Pattern bound on a LHS, still holes on the RHS) by looking at the list of names bound as ``IBindVar``, the things they depend on, and sorting them so that they are bound in dependency order. This happens in ``TTImp.Implicit.getToBind``."
msgstr ""

#: ../source/implementation/overview.rst:251
#: 3b2c0e7f65944fa191c089a4fd702def
msgid "Once we know what the bound implicits need to be, we bind them in ``bindImplicits``. Any application of a hole which stands for a bound implicit gets turned into a local binding (either Pi or Pat as appropriate, or PLet for @-patterns)."
msgstr ""

#: ../source/implementation/overview.rst:257
#: a834df2f758a43fbae746cf385002fa5
msgid "Unbound Implicits"
msgstr ""

#: ../source/implementation/overview.rst:259
#: beb681b9c2324143bd465a8aafa474e6
msgid "Any name beginning with a lower case letter is considered an unbound implicit. They are elaborated as holes, which may depend on the initial environment of the elaboration, and after elaboration they are converted to an implicit pi binding, with multiplicity 0. So, for example:"
msgstr ""

#: ../source/implementation/overview.rst:268
#: c61cfc391a9a476180b2366589b86fde
msgid "becomes:"
msgstr ""

#: ../source/implementation/overview.rst:274
#: 0fe87c6141ce469abb27c2d2ad9df69b
msgid "Bindings are ordered according to dependency. It'll infer any additional names, e.g. in:"
msgstr ""

#: ../source/implementation/overview.rst:281
#: 66d48736658a43f08fc6e5b929138e10
msgid "... where ``xs`` is a ``Vect n a``, it infers bindings for ``n`` and ``a``."
msgstr ""

#: ../source/implementation/overview.rst:283
#: 133f1259d99546fab6fa28fa7e5f0041
msgid "The ``%unbound_implicits`` directive means that it will no longer automatically bind names (that is, ``a`` and ``b`` in ``map`` above) but it will still infer the types for any additional names, e.g. if you write:"
msgstr ""

#: ../source/implementation/overview.rst:291
#: 952dc55933b5456e9fbfb83983ae6b20
msgid "... it will still infer a type for ``xs`` and infer bindings for ``n`` and ``a``."
msgstr ""

#: ../source/implementation/overview.rst:295
#: be7894e7c33b4953a8fa2764341f972e
msgid "Implicit arguments"
msgstr ""

#: ../source/implementation/overview.rst:297
#: 4a7a0bb10d6744a4b5d910883bd18dad
msgid "When we encounter an implicit argument (``_`` in the raw syntax, or added when we elaborate an application and see that there is an implicit needed) we make a new hole which is a fresh name applied to the current environment, and return that as the elaborated term. This happens in ``TTImp.Elab.Check``, with the function ``metaVar``.  If there's enough information elsewhere we'll find the definition of the hole by unification."
msgstr ""

#: ../source/implementation/overview.rst:304
#: 1d522a967abc4b20bcd1827dcc38e893
msgid "We never substitute holes in a term during elaboration and rely on normalisation if we need to look inside it. If there are holes remaining after elaboration of a definition, report an error (it's okay for a hole in a type as long as it's resolved by the time the definition is done)."
msgstr ""

#: ../source/implementation/overview.rst:309
#: 7a603ac5378348dba2a4cd9fe107289d
msgid "See ``Elab.App.makeImplicit``, ``Elab.App.makeAutoImplicit`` to see where we add holes for the implicit arguments in applications."
msgstr ""

#: ../source/implementation/overview.rst:312
#: 7d883dce7853458ea5cfa30598f54fca
msgid "``Elab.App`` does quite a lot of tricky stuff! In an attempt to help with resolving ambiguous names and record updates, it will sometimes delay elaboration of an argument (see ``App.checkRestApp``) so that it can get more information about its type first."
msgstr ""

#: ../source/implementation/overview.rst:317
#: f699e9423a3347c885bdc4a8864fd7c7
msgid "``Core.Unify.solveConstraints`` revisits all of the currently unsolved holes and constrained definitions, and tries again to unify any constraints which they require. It also tries to resolve anything defined by proof search. The current state of unification is defined in ``Core.UnifyState``, and unification constraints record which metavariables are blocking them. This improves performance, since we'll only retry a constraint if one of the blocking metavariables has been resolved."
msgstr ""

#: ../source/implementation/overview.rst:326
#: ba19920b43b64bf89973a42a722423ba
msgid "Additional type inference"
msgstr ""

#: ../source/implementation/overview.rst:328
#: e7a03d6b96104819b9cd1a59818dfb4b
msgid "A ``?`` in a type means \"infer this part of the type\".  This is distinct from ``_`` in types, which means \"I don't care what this is\". The distinction is in what happens when inference fails.  If inference fails for ``_``, we implicitly bind a new name (just like pattern matching on the lhs - i.e. it means match anything). If inference fails for ``?``, we leave it as a hole and try to fill it in later. As a result, we can say:"
msgstr ""

#: ../source/implementation/overview.rst:340
#: 858b5405ec5441598995e79a9aa2d89d
msgid "... and the ``?`` will be inferred to be 4. But if we say:"
msgstr ""

#: ../source/implementation/overview.rst:347
#: b0c53cb9928f4fa2a2e582ff6b9b555e
msgid "... we'll get an error, because the ``_`` has been bound as a new name. Both ``?`` and ``_`` are represented in ``RawImp`` by the ``Implicit`` constructor, which has a boolean flag meaning \"bind if unresolved\"."
msgstr ""

#: ../source/implementation/overview.rst:351
#: 7d02199290114814b03866061708104a
msgid "So the meaning of ``_`` is now consistent on the lhs and in types (i.e. it means infer a value and bind a variable on failure to infer anything). In practice, using ``_`` will get you the old Idris behaviour, but ``?`` might get you a bit more type inference."
msgstr ""

#: ../source/implementation/overview.rst:357
#: 2cf668287db5484eae2aa7b729afc82c
msgid "Auto Implicits"
msgstr ""

#: ../source/implementation/overview.rst:359
#: 2bf9b5fa27e24b609925eab334b22244
msgid "Auto implicits are resolved by proof search, and can be given explicit arguments in the same way as ordinary implicits: i.e. ``{x = exp}`` to give ``exp`` as the value for auto implicit ``x``. Interfaces are syntactic sugar for auto implicits (it is the same resolution mechanism - interfaces translate into records, and implementations translate into hints for the search)."
msgstr ""

#: ../source/implementation/overview.rst:365
#: 787ac26be2c4483991ec4563e169eb89
msgid "The argument syntax ``@{exp}`` means that the value of the next auto implicit in the application should be ``exp`` - this is the same as the syntax for invoking named implementations in Idris 1, but interfaces and auto implicits have been combined now."
msgstr ""

#: ../source/implementation/overview.rst:370
#: 838bf7798d814a2592457b5715bd4bd0
msgid "Implicit search is defined in ``Core.AutoSearch``. It will only begin a search if all the *determining arguments* of the goal are defined, meaning that they don't contain *any* holes. This avoids committing too early to the solution of a hole by resolving it by search, rather than unification, unless a programmer has explicitly said (via a ``search`` option on a data type) that that's what they want."
msgstr ""

#: ../source/implementation/overview.rst:378
#: 2ed6f1470aeb446fbbea8bd050b0b519
msgid "Dot Patterns"
msgstr ""

#: ../source/implementation/overview.rst:380
#: 9eb6a14408fe4c9c8ae5fe3ac9d1e9ec
msgid "``IMustUnify`` is a constructor of ``RawImp``. When we elaborate this, we generate a hole, then elaborate the term, and add a constraint that the generated hole must unify with the term which was explicitly given (in ``UnifyState.addDot``), without resolving any holes. This is finally checked in ``UnifyState.checkDots``."
msgstr ""

#: ../source/implementation/overview.rst:386
#: 4a49e62e50784496aacf758ffa24aa24
msgid "Proof Search"
msgstr ""

#: ../source/implementation/overview.rst:388
#: b0e0a79605a54ac4951808d1307c5730
msgid "A definition constructed with ``Core.Context.BySearch`` is a hole which will be resolved by searching for something which fits the type. This happens in ``Core.AutoSearch``. It checks all possible hints for a term, to ensure that only one is possible."
msgstr ""

#: ../source/implementation/overview.rst:394
#: 339e966aa7b4464181afa028c0f11a44
msgid "@-Patterns"
msgstr ""

#: ../source/implementation/overview.rst:396
#: 2de68f56991a4961afe26a45db81b6ab
msgid "Names which are bound in types are also bound as @-patterns, meaning that functions have access to them. For example, we can say:"
msgstr ""

#: ../source/implementation/overview.rst:405
#: a5a3e40aa05e4ee98a7898adfa1fa66a
msgid "As patterns are implemented as a constructor of ``TT``, which makes a lot of things more convenient (especially case tree compilation)."
msgstr ""

#: ../source/implementation/overview.rst:409
#: fa84c61f921a4d1d9f418c053831f53f
msgid "Linear Types"
msgstr ""

#: ../source/implementation/overview.rst:411
#: 21202610bfb44cbd80a7fe6bdba404b5
msgid "Following Conor McBride and Bob Atkey's work, all binders have a multiplicity annotation (``RigCount``). After elaboration in ``TTImp.Elab``, we do a separate linearity check which: a) makes sure that linear variables are used exactly once; b) updates hole types to properly reflect usage information."
msgstr ""

#: ../source/implementation/overview.rst:417
#: bc01b7eb43c74a188c9108967df9ebea
msgid "Local definitions"
msgstr ""

#: ../source/implementation/overview.rst:419
#: cef74c6e2c3942bb86dc5e9d6cb9361b
msgid "We elaborate relative to an environment, meaning that we can elaborate local function definitions. We keep track of the names being defined in a nested block of declarations, and ensure that they are lifted to top level definitions in TT by applying them to every name in scope."
msgstr ""

#: ../source/implementation/overview.rst:424
#: ee6f14c53b12422cbf930863fe349b13
msgid "Since we don't know how many times a local definition will be applied, in general, anything bound with multiplicity 1 is passed to the local definition with multiplicity 0, so if you want to use it in a local definition, you need to pass it explicitly."
msgstr ""

#: ../source/implementation/overview.rst:430
#: 5d6a2b274d93410985bed88cd633f8e5
msgid "Case blocks"
msgstr ""

#: ../source/implementation/overview.rst:432
#: 457ceda99208494da76fd10174ce2a3a
msgid "Similar to local definitions, these are lifted to top level definitions which represent the case block, which is immediately applied to the scrutinee of the case. We don't attempt to calculate the multiplicities of arguments when elaborating the case block, since we'll probably get it wrong - instead, these are checked during linearity checking, which knows about case functions."
msgstr ""

#: ../source/implementation/overview.rst:438
#: 46cca259c00b4eff830ee469e9c28fa9
msgid "Case blocks in the scope of local definitions are tricky, because the names need to match up, and the types might be refined, but we also still need to apply the local names to the scope in which they were defined. This is a bit fiddly, and dealt with by the ``ICaseLocal`` constructor of ``RawImp``."
msgstr ""

#: ../source/implementation/overview.rst:443
#: 857bdd6976434b559891a81b71d2bb07
msgid "Various parts of the system treat case blocks specially, even though they aren't strictly part of the core. In particular, these are linearity checking and totality checking."
msgstr ""

#: ../source/implementation/overview.rst:448
#: 7b0629f6e7ad4291af8fa79136717e0f
msgid "Parameters"
msgstr ""

#: ../source/implementation/overview.rst:450
#: 5f9d812073854306ae30147fc901867a
msgid "The parameters to a data type are taken to be the arguments which appear, unchanged, in the same position, everywhere across a data definition."
msgstr ""

#: ../source/implementation/overview.rst:454
#: 15c93c8d8b0445f6a13af45aeef2bbd7
msgid "Erasure"
msgstr ""

#: ../source/implementation/overview.rst:456
#: 72421474e05446ab8b8016d303b12559
msgid "Unbound implicits are given ``0`` multiplicity, so the rule is now that if you don't explicitly write it in the type of a function or constructor, the argument is erased at run time."
msgstr ""

#: ../source/implementation/overview.rst:460
#: c56d87f0c5fa4914a2d923f8bf4d4521
msgid "Elaboration and the case tree compiler check ensure that 0-multiplicity arguments are not inspected in case trees. In the compiler, 0-multiplicity arguments to constructors are erased completely, whereas 0-multiplicity arguments to functions are replaced with a placeholder erased value."
msgstr ""

#: ../source/implementation/overview.rst:466
#: 82fbaa39f3364d318e6da9c7f6ce974b
msgid "Namespaces and name visibility"
msgstr ""

#: ../source/implementation/overview.rst:468
#: 87aff121053946368858c9a6ba73eea9
msgid "Same rules mostly apply as in Idris 1. The difference is that visibility is *per namespace* not *per file* (that is, files have no relevance other except in that they introduce their own namespace, and in that they allow separate typechecking)."
msgstr ""

#: ../source/implementation/overview.rst:473
#: 5f71bbfa63f14c15a15915f3f1b9b46f
msgid "One effect of this is that when a file defines nested namespaces, the inner namespace can see what's in the outer namespace, but not vice versa unless names defined in the inner namespace are explicitly exported. The visibility modifiers ``export``, ``public export``, and ``private`` control whether the name can be seen in any other namespace, and it's nothing to do with the file they're defined in at all."
msgstr ""

#: ../source/implementation/overview.rst:480
#: 919e743eb42844d5b6dd1910da296dc7
msgid "Unlike Idris 1, there is no restriction on whether public definitions can refer to private names. The only restriction on ``private`` names is that they can't be referred to directly (i.e. in code) outside the namespace."
msgstr ""

#: ../source/implementation/overview.rst:485
#: 8ef39ccae701459e8b6c25fccbb2b081
msgid "Records"
msgstr ""

#: ../source/implementation/overview.rst:487
#: b2650b745afd462a83eac4d0d4e754c5
msgid "Records are part of TTImp (rather than the surface language). Elaborating a record declaration creates a data type and associated projection functions. Record setters are generated on demand while elaborating TTImp (in ``TTImp.Elab.Record``). Setters are translated directly to ``case`` blocks, which means that update of dependent fields works as one might expect (i.e. it's safe as long as all of the fields are updated at the same time consistently)."
msgstr ""
