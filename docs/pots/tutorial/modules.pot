# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-23 12:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/tutorial/modules.rst:5
#: 41978b8211cf470ca03a19bf7b3c64ae
msgid "Modules and Namespaces"
msgstr ""

#: ../source/tutorial/modules.rst:7
#: 39a6052f665843caa73477fa76a545ab
msgid "An Idris program consists of a collection of modules. Each module includes an optional ``module`` declaration giving the name of the module, a list of ``import`` statements giving the other modules which are to be imported, and a collection of declarations and definitions of types, interfaces and functions. For example, the listing below gives a module which defines a binary tree type ``BTree`` (in a file ``BTree.idr``):"
msgstr ""

#: ../source/tutorial/modules.rst:39
#: ab5a369dd6a743c29bb961fcdbfe1071
msgid "The modifiers ``export`` and ``public export`` say which names are visible from other namespaces. These are explained further below."
msgstr ""

#: ../source/tutorial/modules.rst:42
#: c23794fdec024cf3a3ecadf90fb41774
msgid "Then, this gives a main program (in a file ``bmain.idr``) which uses the ``BTree`` module to sort a list:"
msgstr ""

#: ../source/tutorial/modules.rst:55
#: 8b9838ea20324a19bdb28fbebb5eb46b
msgid "The same names can be defined in multiple modules: names are *qualified* with the name of the module. The names defined in the ``BTree`` module are, in full:"
msgstr ""

#: ../source/tutorial/modules.rst:58
#: bebd6da875c24e5d943b070136fd19b4
msgid "``BTree.BTree``"
msgstr ""

#: ../source/tutorial/modules.rst:59
#: 2367cccfbad44d2cbcf5a82dc8e2f673
msgid "``BTree.Leaf``"
msgstr ""

#: ../source/tutorial/modules.rst:60
#: 4b0a53180c42467799ab9bb61c237954
msgid "``BTree.Node``"
msgstr ""

#: ../source/tutorial/modules.rst:61
#: 3dc0eefa6a4340f49448132483551c0e
msgid "``BTree.insert``"
msgstr ""

#: ../source/tutorial/modules.rst:62
#: 4b0aab6685c445cab52dad35be89e689
msgid "``BTree.toList``"
msgstr ""

#: ../source/tutorial/modules.rst:63
#: 0da72ba82af042f78bf764ce91dabf5b
msgid "``BTree.toTree``"
msgstr ""

#: ../source/tutorial/modules.rst:65
#: 055182d054ca45f798221fb6882e9dcb
msgid "If names are otherwise unambiguous, there is no need to give the fully qualified name. Names can be disambiguated either by giving an explicit qualification, using the ``with`` keyword, or according to their type."
msgstr ""

#: ../source/tutorial/modules.rst:69
#: ae2c666d25f74b93acb6c838bc1d7779
msgid "The ``with`` keyword in expressions comes in two variants:"
msgstr ""

#: ../source/tutorial/modules.rst:71
#: f0d3f6ffa3814a2d8ba0cc9a35a668bd
msgid "``with BTree.insert (insert x empty)`` for one name"
msgstr ""

#: ../source/tutorial/modules.rst:72
#: de4d4f1b9fd94666bda18ca4d3ce65ff
msgid "``with [BTree.insert, BTree.empty] (insert x empty)`` for multiple names"
msgstr ""

#: ../source/tutorial/modules.rst:74
#: c2ce298f2c0b430aa32ac9d2c59afd8b
msgid "This is particularly useful with ``do`` notation, where it can often improve error messages: ``with MyModule.(>>=) do ...``"
msgstr ""

#: ../source/tutorial/modules.rst:77
#: 36590ec72b964f9daf9e50631514b953
msgid "There is no formal link between the module name and its filename, although it is generally advisable to use the same name for each. An ``import`` statement refers to a filename, using dots to separate directories. For example, ``import foo.bar`` would import the file ``foo/bar.idr``, which would conventionally have the module declaration ``module foo.bar``. The only requirement for module names is that the main module, with the ``main`` function, must be called ``Main`` â€” although its filename need not be ``Main.idr``."
msgstr ""

#: ../source/tutorial/modules.rst:87
#: 4ff636bcf2e94409b751f11c78e2b014
msgid "Export Modifiers"
msgstr ""

#: ../source/tutorial/modules.rst:89
#: fe78c2945a9143cfb6d1ff2661bfd6ff
msgid "Idris allows for fine-grained control over the visibility of a namespace's contents. By default, all names defined in a namespace are kept private.  This aids in specification of a minimal interface and for internal details to be left hidden. Idris allows for functions, types, and interfaces to be marked as: ``private``, ``export``, or ``public export``. Their general meaning is as follows:"
msgstr ""

#: ../source/tutorial/modules.rst:96
#: b6b35b42706e486d9b895e09f6e30313
msgid "``private`` meaning that it is not exported at all. This is the default."
msgstr ""

#: ../source/tutorial/modules.rst:98
#: 44f47d253ba54752ac8a3e840f0f1847
msgid "``export`` meaning that its top level type is exported."
msgstr ""

#: ../source/tutorial/modules.rst:100
#: 4496487f9b4a493393f4ac1e98b98718
msgid "``public export`` meaning that the entire definition is exported."
msgstr ""

#: ../source/tutorial/modules.rst:102
#: 62f867773d0046a4a99d4b1359acb360
msgid "A further restriction in modifying the visibility is that definitions must not refer to anything within a lower level of visibility. For example, ``public export`` definitions cannot use ``private`` or ``export`` names, and ``export`` types cannot use ``private`` names. This is to prevent private names leaking into a module's interface."
msgstr ""

#: ../source/tutorial/modules.rst:109
#: 3af52186896b4c69834dccbc4b803229
msgid "Meaning for Functions"
msgstr ""

#: ../source/tutorial/modules.rst:111
#: b3e7ad90db2344ef85a73430c230f7ce
msgid "``export`` the type is exported"
msgstr ""

#: ../source/tutorial/modules.rst:113
#: 31f61305ca2347e28d8e571bb80853f1
msgid "``public export`` the type and definition are exported, and the definition can be used after it is imported. In other words, the definition itself is considered part of the module's interface. The long name ``public export`` is intended to make you think twice about doing this."
msgstr ""

#: ../source/tutorial/modules.rst:121
#: d037093d8bcf4217a0f49e74f071e12a
msgid "Type synonyms in Idris are created by writing a function. When setting the visibility for a module, it is usually a good idea to ``public export`` all type synonyms if they are to be used outside the module. Otherwise, Idris won't know what the synonym is a synonym for."
msgstr ""

#: ../source/tutorial/modules.rst:127
#: e37a0366fad0436d90d4a7b17749ab16
msgid "Since ``public export`` means that a function's definition is exported, this effectively makes the function definition part of the module's API. Therefore, it's generally a good idea to avoid using ``public export`` for functions unless you really mean to export the full definition."
msgstr ""

#: ../source/tutorial/modules.rst:133
#: 332b9263d1b54b24a16a2f5a89e21a39
msgid "*For beginners*: If the function needs to be accessed only at runtime, use ``export``. However, if it's also meant to be used at *compile* time (e.g. to prove a theorem), use ``public export``. For example, consider the function ``plus : Nat -> Nat -> Nat`` discussed previously, and the following theorem: ``thm : plus Z m = m``. In order to prove it, the type checker needs to reduce ``plus Z m`` to ``m`` (and hence obtain ``thm : m = m``). To achieve this, it will need access to the *definition* of ``plus``, which includes the equation ``plus Z m = m``. Therefore, in this case, ``plus`` has to be marked as ``public export``."
msgstr ""

#: ../source/tutorial/modules.rst:146
#: 3984158af3594fa1a3df8a643b442b01
msgid "Meaning for Data Types"
msgstr ""

#: ../source/tutorial/modules.rst:148
#: d7ad3f4c9c7549778fbf1ea776116212
msgid "For data types, the meanings are:"
msgstr ""

#: ../source/tutorial/modules.rst:150
#: a838b25613674ec1b1e6ac6f074d1c7a
msgid "``export`` the type constructor is exported"
msgstr ""

#: ../source/tutorial/modules.rst:152
#: 41cb22d4dd074496b6b9d4bea3f1a867
msgid "``public export`` the type constructor and data constructors are exported"
msgstr ""

#: ../source/tutorial/modules.rst:156
#: f803259802d947509e0bfbbc59cea460
msgid "Meaning for Interfaces"
msgstr ""

#: ../source/tutorial/modules.rst:158
#: 72455bca71af4746bf7588dba6db55d3
msgid "For interfaces, the meanings are:"
msgstr ""

#: ../source/tutorial/modules.rst:160
#: d3404470ffac4984bd5825aa969c9c64
msgid "``export`` the interface name is exported"
msgstr ""

#: ../source/tutorial/modules.rst:162
#: 9a3716574bb042c9b5c6b0f8ce5cad4e
msgid "``public export`` the interface name, method names and default definitions are exported"
msgstr ""

#: ../source/tutorial/modules.rst:166
#: d81336e4d04b4e05a55154779cf4246d
msgid "Propagating Inner Module API's"
msgstr ""

#: ../source/tutorial/modules.rst:168
#: 612364b4f83347eb97f89844cec066b5
msgid "Additionally, a module can re-export a module it has imported, by using the ``public`` modifier on an ``import``. For example:"
msgstr ""

#: ../source/tutorial/modules.rst:178
#: 5e0b2c7a9aa0416d8fca6fded88dfe17
msgid "The module ``A`` will export the name ``a``, as well as any public or abstract names in module ``C``, but will not re-export anything from module ``B``."
msgstr ""

#: ../source/tutorial/modules.rst:183
#: 095935ef14dd4563846018b160381ae0
msgid "Renaming imports"
msgstr ""

#: ../source/tutorial/modules.rst:185
#: 1617e2be58364163bba566548cc73844
msgid "Sometimes it is convenient to be able to access the names in another module via a different namespace (typically, a shorter one). For this, you can use `import...as`. For example:"
msgstr ""

#: ../source/tutorial/modules.rst:195
#: 9c714fd6712b444286851e29253bde0c
msgid "This module ``A`` has access to the exported names from module ``Data.List``, but can also explicitly access them via the module name ``L``. ``import...as`` can also be combined with ``import public`` to create a module which exports a larger API from other sub-modules:"
msgstr ""

#: ../source/tutorial/modules.rst:207
#: 0381d05da7bf40418178193f812a77a5
msgid "Here, any module which imports ``Books`` will have access to the exported interfaces of ``Books.Hardback`` and ``Books.Comic`` both under the namespace ``Books``."
msgstr ""

#: ../source/tutorial/modules.rst:212
#: 2aed837148a047dc98f5e6bb5042eed2
msgid "Explicit Namespaces"
msgstr ""

#: ../source/tutorial/modules.rst:214
#: 1a118b3d1f3d4effb9cb62af26f0482a
msgid "Defining a module also defines a namespace implicitly. However, namespaces can also be given *explicitly*. This is most useful if you wish to overload names within the same module:"
msgstr ""

#: ../source/tutorial/modules.rst:232
#: 0a22d5a37e42456986ffd0916fd12f88
msgid "This (admittedly contrived) module defines two functions with fully qualified names ``Foo.X.test`` and ``Foo.Y.test``, which can be disambiguated by their types:"
msgstr ""

#: ../source/tutorial/modules.rst:243
#: db9224a16bb04ba89418ee24e11f2e18
msgid "The export rules, ``public export`` and ``export``, are *per namespace*, not *per file*, so the two ``test`` definitions above need the ``export`` flag to be visible outside their own namespaces."
msgstr ""

#: ../source/tutorial/modules.rst:248
#: b1d064f82b784d28a3f9c8ff87a6f6a5
msgid "Parameterised blocks"
msgstr ""

#: ../source/tutorial/modules.rst:250
#: a21a18507132459cba8b27fed64b8c78
msgid "Groups of functions can be parameterised over a number of arguments using a ``parameters`` declaration, for example:"
msgstr ""

#: ../source/tutorial/modules.rst:259
#: c8d300b311524486a23c9b732d506a56
msgid "The effect of a ``parameters`` block is to add the declared parameters to every function, type and data constructor within the block. Specifically, adding the parameters to the front of the argument list. Outside the block, the parameters must be given explicitly. The ``addAll`` function, when called from the REPL, will thus have the following type signature."
msgstr ""

#: ../source/tutorial/modules.rst:271
#: 3349d63cc5484e069150cb0e8fdac08f
msgid "and the following definition."
msgstr ""

#: ../source/tutorial/modules.rst:278
#: 39ea3c7f7ef54bf99d889e869176e60a
msgid "Parameters blocks can be nested, and can also include data declarations, in which case the parameters are added explicitly to all type and data constructors. They may also be dependent types with implicit arguments:"
msgstr ""

#: ../source/tutorial/modules.rst:291
#: b7f44541837d40f1bc1a85db4370f75e
msgid "To use ``Vects`` or ``append`` outside the block, we must also give the ``xs`` and ``y`` arguments. Here, we can use placeholders for the values which can be inferred by the type checker:"
msgstr ""
