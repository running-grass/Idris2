# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-23 12:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/tutorial/views.rst:5
#: 6db3b28a28fc4a4283492629b9c585cc
msgid "Views and the “``with``” rule"
msgstr ""

#: ../source/tutorial/views.rst:9
#: 5c44302b7ac044a9a6bc6b15a673be02
msgid "NOT UPDATED FOR IDRIS 2 YET"
msgstr ""

#: ../source/tutorial/views.rst:12
#: 8f4401ff04f9433998600bb195f04853
msgid "Dependent pattern matching"
msgstr ""

#: ../source/tutorial/views.rst:14
#: 818e2eb45a5d4234bb86880723cecc88
msgid "Since types can depend on values, the form of some arguments can be determined by the value of others. For example, if we were to write down the implicit length arguments to ``(++)``, we’d see that the form of the length argument was determined by whether the vector was empty or not:"
msgstr ""

#: ../source/tutorial/views.rst:26
#: 9198f1ce9ee24b92bff959f36165ffde
msgid "If ``n`` was a successor in the ``[]`` case, or zero in the ``::`` case, the definition would not be well typed."
msgstr ""

#: ../source/tutorial/views.rst:32
#: c438613df4884593829625f3464c7cd6
msgid "The ``with`` rule — matching intermediate values"
msgstr ""

#: ../source/tutorial/views.rst:34
#: 9c767ad1ce054b96adef229087046b34
msgid "Very often, we need to match on the result of an intermediate computation. Idris provides a construct for this, the ``with`` rule, inspired by views in ``Epigram`` [#McBridgeMcKinna]_, which takes account of the fact that matching on a value in a dependently typed language can affect what we know about the forms of other values. In its simplest form, the ``with`` rule adds another argument to the function being defined."
msgstr ""

#: ../source/tutorial/views.rst:42
#: f768a8868d8b4f7a881e4ad64be2d494
msgid "We have already seen a vector filter function. This time, we define it using ``with`` as follows:"
msgstr ""

#: ../source/tutorial/views.rst:52
#: 999e80db1d4f45c1a7c147e649e0c6dd
msgid "Here, the ``with`` clause allows us to deconstruct the result of ``filter p xs``. The view refined argument pattern ``filter p (x :: xs)`` goes beneath the ``with`` clause, followed by a vertical bar ``|``, followed by the deconstructed intermediate result ``( _ ** xs' )``. If the view refined argument pattern is unchanged from the original function argument pattern, then the left side of ``|`` is extraneous and may be omitted with an underscore ``_``:"
msgstr ""

#: ../source/tutorial/views.rst:65
#: 90f30091457b4d7098bc53212db878fb
msgid "``with`` clauses can also be nested:"
msgstr ""

#: ../source/tutorial/views.rst:76
#: ee8fa1e22761488b8d06128ee71318fa
msgid "and left hand sides that are the same as their parent's can be skipped by using ``_`` to focus on the patterns for the most local ``with``. Meaning that the above ``foo`` can be rewritten as follows:"
msgstr ""

#: ../source/tutorial/views.rst:89
#: ed673d2a87b94c8dabbe334e955d34b4
msgid "If the intermediate computation itself has a dependent type, then the result can affect the forms of other arguments — we can learn the form of one value by testing another. In these cases, view refined argument patterns must be explicit. For example, a ``Nat`` is either even or odd. If it is even it will be the sum of two equal ``Nat``. Otherwise, it is the sum of two equal ``Nat`` plus one:"
msgstr ""

#: ../source/tutorial/views.rst:102
#: 1b5d45e9f2fe407f866a812e61028974
msgid "We say ``Parity`` is a *view* of ``Nat``. It has a *covering function* which tests whether it is even or odd and constructs the predicate accordingly. Note that we're going to need access to ``n`` at run time, so although it's an implicit argument, it has unrestricted multiplicity."
msgstr ""

#: ../source/tutorial/views.rst:111
#: d8ef5d4dd01f416aa2950263435ccb85
msgid "We’ll come back to the definition of ``parity`` shortly. We can use it to write a function which converts a natural number to a list of binary digits (least significant first) as follows, using the ``with`` rule:"
msgstr ""

#: ../source/tutorial/views.rst:124
#: 6a2701f86bec45cbb7eb6de7ba495ddb
msgid "The value of ``parity k`` affects the form of ``k``, because the result of ``parity k`` depends on ``k``. So, as well as the patterns for the result of the intermediate computation (``Even`` and ``Odd``) right of the ``|``, we also write how the results affect the other patterns left of the ``|``. That is:"
msgstr ""

#: ../source/tutorial/views.rst:130
#: 5fa930fc6b1549b68c410f76afda1b7a
msgid "When ``parity k`` evaluates to ``Even``, we can refine the original argument ``k`` to a refined pattern ``(j + j)`` according to ``Parity (n + n)`` from the ``Even`` constructor definition. So ``(j + j)`` replaces ``k`` on the left side of ``|``, and the ``Even`` constructor appears on the right side. The natural number ``j`` in the refined pattern can be used on the right side of the ``=`` sign."
msgstr ""

#: ../source/tutorial/views.rst:138
#: a2291b2375b347198a7842d56cd2b795
msgid "Otherwise, when ``parity k`` evaluates to ``Odd``, the original argument ``k`` is refined to ``S (j + j)`` according to ``Parity (S (n + n))`` from the ``Odd`` constructor definition, and ``Odd`` now appears on the right side of ``|``, again with the natural number ``j`` used on the right side of the ``=`` sign."
msgstr ""

#: ../source/tutorial/views.rst:144
#: 0aacb56cc7084c58bb07eb97e564edff
msgid "Note that there is a function in the patterns (``+``) and repeated occurrences of ``j`` - this is allowed because another argument has determined the form of these patterns."
msgstr ""

#: ../source/tutorial/views.rst:149
#: 5803d3753ddf4760aa83c269a8881122
msgid "Defining ``parity``"
msgstr ""

#: ../source/tutorial/views.rst:151
#: d0212fc452b648dc9354af76db879811
msgid "The definition of ``parity`` is a little tricky, and requires some knowledge of theorem proving (see Section :ref:`sect-theorems`), but for completeness, here it is:"
msgstr ""

#: ../source/tutorial/views.rst:166
#: 0485399e7f8a4cedb76e54f6febff4a4
msgid "For full details on ``rewrite`` in particular, please refer to the theorem proving tutorial, in Section :ref:`proofs-index`."
msgstr ""

#: ../source/tutorial/views.rst:169
#: 3b9a60aafd44404aa8dac2c71545180d
msgid "Conor McBride and James McKinna. 2004. The view from the left. J. Funct. Program. 14, 1 (January 2004), 69-111. https://doi.org/10.1017/S0956796803004829"
msgstr ""
