# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-23 12:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/tutorial/multiplicities.rst:5
#: 2bdd4a67cba94f2891bd25dcebad8de4
msgid "Multiplicities"
msgstr ""

#: ../source/tutorial/multiplicities.rst:7
#: 401efeb3fff04f5987316eeaeaf10b38
msgid "Idris 2 is based on `Quantitative Type Theory (QTT) <https://bentnib.org/quantitative-type-theory.html>`_, a core language developed by Bob Atkey and Conor McBride. In practice, this means that every variable in Idris 2 has a *quantity* associated with it. A quantity is one of:"
msgstr ""

#: ../source/tutorial/multiplicities.rst:13
#: 5ad738ddf4534e1c83734820f4d923b3
msgid "``0``, meaning that the variable is *erased* at run time"
msgstr ""

#: ../source/tutorial/multiplicities.rst:14
#: 6f0c4b4e9e7149bb909b14405bdd9a90
msgid "``1``, meaning that the variable is used *exactly once* at run time"
msgstr ""

#: ../source/tutorial/multiplicities.rst:15
#: ec59315619de474aa895df870d871ce0
msgid "*Unrestricted*, which is the same behaviour as Idris 1"
msgstr ""

#: ../source/tutorial/multiplicities.rst:17
#: afe24d458ffd43ccb1b9143f1c66f3b6
msgid "We can see the multiplicities of variables by inspecting holes. For example, if we have the following skeleton definition of ``append`` on vectors..."
msgstr ""

#: ../source/tutorial/multiplicities.rst:25
#: f16398febeb947268a158ede3e365c89
msgid "...we can look at the hole ``append_rhs``:"
msgstr ""

#: ../source/tutorial/multiplicities.rst:38
#: 857d91bd1f3e46e7a1e57f58043e8df6
msgid "The ``0`` next to ``m``, ``a`` and ``n`` mean that they are in scope, but there will be ``0`` occurrences at run-time. That is, it is **guaranteed** that they will be erased at run-time."
msgstr ""

#: ../source/tutorial/multiplicities.rst:42
#: f5bf306a278a483dbfd14003e0c17663
msgid "Multiplicities can be explicitly written in function types as follows:"
msgstr ""

#: ../source/tutorial/multiplicities.rst:44
#: e84f4bfd5d774d3d8e6bf5bb9aa69ad8
msgid "``ignoreN : (0 n : Nat) -> Vect n a -> Nat`` - this function cannot look at ``n`` at run time"
msgstr ""

#: ../source/tutorial/multiplicities.rst:46
#: e765d46ac8d04914a930718af3249698
msgid "``duplicate : (1 x : a) -> (a, a)`` - this function must use ``x`` exactly once (so good luck implementing it, by the way. There is no implementation because it would need to use ``x`` twice!)"
msgstr ""

#: ../source/tutorial/multiplicities.rst:50
#: 850a93d1192b4820b5dbba469cdaa49b
msgid "If there is no multiplicity annotation, the argument is unrestricted. If, on the other hand, a name is implicitly bound (like ``a`` in both examples above) the argument is erased. So, the above types could also be written as:"
msgstr ""

#: ../source/tutorial/multiplicities.rst:54
#: 0896d6acba9f4737912582df2eb15bd6
msgid "``ignoreN : {0 a : _} -> (0 n : Nat) -> Vect n a -> Nat``"
msgstr ""

#: ../source/tutorial/multiplicities.rst:55
#: 599150cb7ab443f390a9dd7c14109173
msgid "``duplicate : {0 a : _} -> (1 x : a) -> (a, a)``"
msgstr ""

#: ../source/tutorial/multiplicities.rst:57
#: b8e0f704091641249bbb65fa6316002f
msgid "This section describes what this means for your Idris 2 programs in practice, with several examples. In particular, it describes:"
msgstr ""

#: ../source/tutorial/multiplicities.rst:60
#: 60d63e9f1f88488fa202cdf96886e347
msgid ":ref:`sect-erasure` - how to know what is relevant at run time and what is erased"
msgstr ""

#: ../source/tutorial/multiplicities.rst:61
#: 848d0787423b4998b83de5051d3569d9
msgid ":ref:`sect-linearity` - using the type system to encode *resource usage protocols*"
msgstr ""

#: ../source/tutorial/multiplicities.rst:62
#: 57b0b3d37ad04380913a9971a8eeeee2
msgid ":ref:`sect-pmtypes` - truly first class types"
msgstr ""

#: ../source/tutorial/multiplicities.rst:64
#: 37663306d03c42e0b6114c2088d10e01
msgid "The most important of these for most programs, and the thing you'll need to know about if converting Idris 1 programs to work with Idris 2, is erasure_. The most interesting, however, and the thing which gives Idris 2 much more expressivity, is linearity_, so we'll start there."
msgstr ""

#: ../source/tutorial/multiplicities.rst:72
#: ba297a4256684662907509c075bd8387
msgid "Linearity"
msgstr ""

#: ../source/tutorial/multiplicities.rst:74
#: 7283023ea4e2480c96067eadd61e5cd3
msgid "The ``1`` multiplicity expresses that a variable must be used exactly once. By \"used\" we mean either:"
msgstr ""

#: ../source/tutorial/multiplicities.rst:77
#: 8bc9a2a426c14097812c1db5318fc8d6
msgid "if the variable is a data type or primitive value, it is pattern matched against, ex. by being the subject of a *case* statement, or a function argument that is pattern matched against, etc.,"
msgstr ""

#: ../source/tutorial/multiplicities.rst:78
#: 34fc9a30494d4c1288af8607448d1086
msgid "if the variable is a function, that function is applied (i.e. ran with an argument)"
msgstr ""

#: ../source/tutorial/multiplicities.rst:80
#: 34c0266ae2334c8a96590154f9d354a9
msgid "First, we'll see how this works on some small examples of functions and data types, then see how it can be used to encode `resource protocols`_."
msgstr ""

#: ../source/tutorial/multiplicities.rst:83
#: 342b5e2d35f741648c59e90b96d8a06d
msgid "Above, we saw the type of ``duplicate``. Let's try to write it interactively, and see what goes wrong. We'll start by giving the type and a skeleton definition with a hole"
msgstr ""

#: ../source/tutorial/multiplicities.rst:92
#: 5375423f1b104db195cf766bc0710800
msgid "Checking the type of a hole tells us the multiplicity of each variable in scope. If we check the type of ``?help`` we'll see that we can't use ``a`` at run time, and we have to use ``x`` exactly once::"
msgstr ""

#: ../source/tutorial/multiplicities.rst:102
#: b32a1d5e00234ba5b5c80dcce991c33f
msgid "If we use ``x`` for one part of the pair..."
msgstr ""

#: ../source/tutorial/multiplicities.rst:109
#: aa8e50ec88164d609689a27dd03ce1e0
msgid "...then the type of the remaining hole tells us we can't use it for the other::"
msgstr ""

#: ../source/tutorial/multiplicities.rst:117
#: be324b68dace489f9c4fa1e081f0daad
msgid "The same happens if we try defining ``duplicate x = (?help, x)`` (try it!)."
msgstr ""

#: ../source/tutorial/multiplicities.rst:119
#: 795c91355b92438ebea286abd7af4d5f
msgid "In order to avoid parsing ambiguities, if you give an explicit multiplicity for a variable as with the argument to ``duplicate``, you need to give it a name too. But, if the name isn't used in the scope of the type, you can use ``_`` instead of a name, as follows:"
msgstr ""

#: ../source/tutorial/multiplicities.rst:128
#: 84063e743301409184dcb220df027f6a
msgid "The intution behind multiplicity ``1`` is that if we have a function with a type of the following form..."
msgstr ""

#: ../source/tutorial/multiplicities.rst:135
#: d88d1993b5b84cff834246c40c88864c
msgid "...then the guarantee given by the type system is that *if* ``f x`` *is used exactly once, then* ``x`` *is used exactly once*. So, if we insist on trying to define ``duplicate``...::"
msgstr ""

#: ../source/tutorial/multiplicities.rst:141
#: 0bf39bbfa7a54a92b407572016ac8af9
msgid "...then Idris will complain::"
msgstr ""

#: ../source/tutorial/multiplicities.rst:146
#: da6f29a984c94b1789e5f1d6d3f2e217
msgid "A similar intuition applies for data types. Consider the following types, ``Lin`` which wraps an argument that must be used once, and ``Unr`` which wraps an argument with unrestricted use"
msgstr ""

#: ../source/tutorial/multiplicities.rst:158
#: 17d39827fec54500b4eb804e40692f28
msgid "If ``MkLin x`` is used once, then ``x`` is used once. But if ``MkUnr x`` is used once, there is no guarantee on how often ``x`` is used. We can see this a bit more clearly by starting to write projection functions for ``Lin`` and ``Unr`` to extract the argument"
msgstr ""

#: ../source/tutorial/multiplicities.rst:171
#: 9776970eb2884eae8a38e991024b8b7d
msgid "Checking the types of the holes shows us that, for ``getLin``, we must use ``x`` exactly once (Because the ``val`` argument is used once, by pattern matching on it as ``MkLin x``, and if ``MkLin x`` is used once, ``x`` must be used once)::"
msgstr ""

#: ../source/tutorial/multiplicities.rst:182
#: d308e9e9403f46fe9447a86e1ed7534f
msgid "For ``getUnr``, however, we still have to use ``val`` once, again by pattern matching on it, but using ``MkUnr x`` once doesn't place any restrictions on ``x``. So, ``x`` has unrestricted use in the body of ``getUnr``::"
msgstr ""

#: ../source/tutorial/multiplicities.rst:192
#: 767f8632c1354924a0a2e4111c1ebd8b
msgid "If ``getLin`` has an unrestricted argument..."
msgstr ""

#: ../source/tutorial/multiplicities.rst:199
#: 18b28b0da05b45c0b67315fcba2d35b8
msgid "...then ``x`` is unrestricted in ``howmanyLin``::"
msgstr ""

#: ../source/tutorial/multiplicities.rst:207
#: 02ee5c21093d4f799a14cad6c10df0a8
msgid "Remember the intuition from the type of ``MkLin`` is that if ``MkLin x`` is used exactly once, ``x`` is used exactly once. But, we didn't say that ``MkLin x`` would be used exactly once, so there is no restriction on ``x``."
msgstr ""

#: ../source/tutorial/multiplicities.rst:212
#: e28c048e03fe445cb477a4f70898ba8c
msgid "Resource protocols"
msgstr ""

#: ../source/tutorial/multiplicities.rst:214
#: 05b9c34056c34f5f805227e202b521da
msgid "One way to take advantage of being able to express linear usage of an argument is in defining resource usage protocols, where we can use linearity to ensure that any unique external resource has only one instance, and we can use functions which are linear in their arguments to represent state transitions on that resource. A door, for example, can be in one of two states, ``Open`` or ``Closed``"
msgstr ""

#: ../source/tutorial/multiplicities.rst:228
#: fa735d4a5d394b349f132e1859d9ff26
msgid "(Okay, we're just pretending here - imagine the ``doorId`` is a reference to an external resource!)"
msgstr ""

#: ../source/tutorial/multiplicities.rst:231
#: 39af648f56974be3b24c5554ba3832c9
msgid "We can define functions for opening and closing the door which explicitly describe how they change the state of a door, and that they are linear in the door"
msgstr ""

#: ../source/tutorial/multiplicities.rst:240
#: 26f1a3ba423247e0a501fa6bb09c3022
msgid "Remember, the intuition is that if ``openDoor d`` is used exactly once, then ``d`` is used exactly once. So, provided that a door ``d`` has multiplicity ``1`` when it's created, we *know* that once we call ``openDoor`` on it, we won't be able to use ``d`` again. Given that ``d`` is an external resource, and ``openDoor`` has changed it's state, this is a good thing!"
msgstr ""

#: ../source/tutorial/multiplicities.rst:247
#: 8dadfd25c402434886c3f6eee7c5d96a
msgid "We can ensure that any door we create has multiplicity ``1`` by creating them with a ``newDoor`` function with the following type"
msgstr ""

#: ../source/tutorial/multiplicities.rst:254
#: 6cce7133565e45aa91fd6391c2db92a9
msgid "That is, ``newDoor`` takes a function, which it runs exactly once. That function takes a door, which is used exactly once. We'll run it in ``IO`` to suggest that there is some interaction with the outside world going on when we create the door. Since the multiplicity ``1`` means the door has to be used exactly once, we need to be able to delete the door when we're finished"
msgstr ""

#: ../source/tutorial/multiplicities.rst:265
#: 27a0d3f2006a441d9f6a9b609b771270
msgid "So an example correct door protocol usage would be"
msgstr ""

#: ../source/tutorial/multiplicities.rst:276
#: 9adc43f506bc46428652e1ad30e2ac26
msgid "It's instructive to build this program interactively, with holes along the way, and see how the multiplicities of ``d``, ``d'`` etc change. For example"
msgstr ""

#: ../source/tutorial/multiplicities.rst:288
#: 560ce44d306a4b7395e5a9a35843f547
msgid "Checking the type of ``?whatnow`` shows that ``d`` is now spent, but we still have to use ``d'`` exactly once::"
msgstr ""

#: ../source/tutorial/multiplicities.rst:297
#: 669617a67e774bf792d43d9d628b64e9
msgid "Note that the ``0`` multiplicity for ``d`` means that we can still *talk* about it - in particular, we can still reason about it in types - but we can't use it again in a relevant position in the rest of the program. It's also fine to shadow the name ``d`` throughout"
msgstr ""

#: ../source/tutorial/multiplicities.rst:311
#: 85d60146b69c4aebb11f6d18c8ccc084
msgid "If we don't follow the protocol correctly - create the door, open it, close it, then delete it - then the program won't type check. For example, we can try not to delete the door before finishing"
msgstr ""

#: ../source/tutorial/multiplicities.rst:324
#: 984e4ccb14ac46919e2f9c2cdd06cf98
msgid "This gives the following error::"
msgstr ""

#: ../source/tutorial/multiplicities.rst:329
#: 037cfa86c12f4baeb5b90ef758cbce30
msgid "There's a lot more to be said about the details here! But, this shows at a high level how we can use linearity to capture resource usage protocols at the type level. If we have an external resource which is guaranteed to be used linearly, like ``Door``, we don't need to run operations on that resource in an ``IO`` monad, since we're already enforcing an ordering on operations and don't have access to any out of date resource states. This is similar to the way interactive programs work in `the Clean programming language <https://clean.cs.ru.nl/Clean>`_, and in fact is how ``IO`` is implemented internally in Idris 2, with a special ``%World`` type for representing the state of the outside world that is always used linearly"
msgstr ""

#: ../source/tutorial/multiplicities.rst:351
#: 45a25ba6be77425e8a659d9071979747
msgid "Having multiplicities in the type system raises several interesting questions, such as:"
msgstr ""

#: ../source/tutorial/multiplicities.rst:354
#: 460218f509eb4fd890b36c2df225ce22
msgid "Can we use linearity information to inform memory management and, for example, have type level guarantees about functions which will not need to perform garbage collection?"
msgstr ""

#: ../source/tutorial/multiplicities.rst:357
#: 1ab2e8c3efbf4365807e48d57827dc91
msgid "How should multiplicities be incorporated into interfaces such as ``Functor``, ``Applicative`` and ``Monad``?"
msgstr ""

#: ../source/tutorial/multiplicities.rst:359
#: fc4269a622fe4b67b55eec266cbc8891
msgid "If we have ``0``, and ``1`` as multiplicities, why stop there? Why not have ``2``, ``3`` and more (like `Granule <https://granule-project.github.io/granule.html>`_)"
msgstr ""

#: ../source/tutorial/multiplicities.rst:362
#: 0d8b0734f8844c989ea30534ce2a8ebc
msgid "What about multiplicity polymorphism, as in the `Linear Haskell proposal <https://arxiv.org/abs/1710.09756>`_?"
msgstr ""

#: ../source/tutorial/multiplicities.rst:363
#: 398f0ed9c5ee4cfcbbe5d2382d90866b
msgid "Even without all of that, what can we do *now*?"
msgstr ""

#: ../source/tutorial/multiplicities.rst:368
#: 61d31cdb18054e5ca23e58a7653db294
msgid "Erasure"
msgstr ""

#: ../source/tutorial/multiplicities.rst:370
#: 2fafdc48ee164dea85ba89fe6f188815
msgid "The ``1`` multiplicity give us many possibilities in the kinds of properties we can express. But, the ``0`` multiplicity is perhaps more important in that it allows us to be precise about which values are relevant at run time, and which are compile time only (that is, which are erased). Using the ``0`` multiplicity means a function's type now tells us exactly what it needs at run time."
msgstr ""

#: ../source/tutorial/multiplicities.rst:377
#: c4f2adf5275d4fdb84f41b60b8d7462c
msgid "For example, in Idris 1 you could get the length of a vector as follows"
msgstr ""

#: ../source/tutorial/multiplicities.rst:384
#: adbb423517ce40d7b47f3d5867cccee4
msgid "This is fine, since it runs in constant time, but the trade off is that ``n`` has to be available at run time, so at run time we always need the length of the vector to be available if we ever call ``vlen``. Idris 1 can infer whether the length is needed, but there's no easy way for a programmer to be sure."
msgstr ""

#: ../source/tutorial/multiplicities.rst:389
#: 078115c385b444b3b6010c74b39ae3ad
msgid "In Idris 2, we need to state explicitly that ``n`` is needed at run time"
msgstr ""

#: ../source/tutorial/multiplicities.rst:396
#: 8f52aeb40a2e476cb289061e0aabf9ed
msgid "(Incidentally, also note that in Idris 2, names bound in types are also available in the definition without explicitly rebinding them.)"
msgstr ""

#: ../source/tutorial/multiplicities.rst:399
#: 6006fcd80c554f82a834072cfe62cb28
msgid "This also means that when you call ``vlen``, you need the length available. For example, this will give an error"
msgstr ""

#: ../source/tutorial/multiplicities.rst:407
#: 7427a3619f4c4129ae138686e3ded2bf
msgid "Idris 2 reports::"
msgstr ""

#: ../source/tutorial/multiplicities.rst:412
#: 4554ebd3ba5a4e27b2c7134910e4d349
msgid "This means that it needs to use ``m`` as an argument to pass to ``vlen xs``, where it needs to be available at run time, but ``m`` is not available in ``sumLengths`` because it has multiplicity ``0``."
msgstr ""

#: ../source/tutorial/multiplicities.rst:416
#: 72c28120829044c1a9a4b7a6e22fa2d9
msgid "We can see this more clearly by replacing the right hand side of ``sumLengths`` with a hole..."
msgstr ""

#: ../source/tutorial/multiplicities.rst:424
#: c79af5a0e66a4bd6af6de99a787a18b6
msgid "...then checking the hole's type at the REPL::"
msgstr ""

#: ../source/tutorial/multiplicities.rst:435
#: 285249e39520452986cfc045134b4da1
msgid "Instead, we need to give bindings for ``m`` and ``n`` with unrestricted multiplicity"
msgstr ""

#: ../source/tutorial/multiplicities.rst:443
#: 23704de2432249faaa9730ff928d022f
msgid "Remember that giving no multiplicity on a binder, as with ``m`` and ``n`` here, means that the variable has unrestricted usage."
msgstr ""

#: ../source/tutorial/multiplicities.rst:446
#: d4a579391dca436d92bc650060d31051
msgid "If you're converting Idris 1 programs to work with Idris 2, this is probably the biggest thing you need to think about. It is important to note, though, that if you have bound implicits, such as..."
msgstr ""

#: ../source/tutorial/multiplicities.rst:454
#: 73924cb569674c818eeceb7e547ee98d
msgid "...then it's a good idea to make sure ``t`` really is needed, or performance might suffer due to the run time building the instance of ``t`` unnecessarily!"
msgstr ""

#: ../source/tutorial/multiplicities.rst:457
#: bc081d79d9f1495aaa957c1c93a9561e
msgid "One final note on erasure: it is an error to try to pattern match on an argument with multiplicity ``0``, unless its value is inferrable from elsewhere. So, the following definition is rejected"
msgstr ""

#: ../source/tutorial/multiplicities.rst:467
#: 43d14e91a8cf4ac395a4cb10c1aa0863
msgid "This is rejected with the error::"
msgstr ""

#: ../source/tutorial/multiplicities.rst:472
#: 80eb2825edb94e119c37e0a60b51512b
msgid "The following, however, is fine, because in ``sNot``, even though we appear to match on the erased argument ``x``, its value is uniquely inferrable from the type of the second argument"
msgstr ""

#: ../source/tutorial/multiplicities.rst:486
#: e22e752f77e84aed91471f16dc8a9bda
msgid "Experience with Idris 2 so far suggests that, most of the time, as long as you're using unbound implicits in your Idris 1 programs, they will work without much modification in Idris 2. The Idris 2 type checker will point out where you require an unbound implicit argument at run time - sometimes this is both surprising and enlightening!"
msgstr ""

#: ../source/tutorial/multiplicities.rst:495
#: 39d75b3eae0940e1ad0662abf63df1d7
msgid "Pattern Matching on Types"
msgstr ""

#: ../source/tutorial/multiplicities.rst:497
#: a92e287ded524d039b8c6a6b1a6d5f64
msgid "One way to think about dependent types is to think of them as \"first class\" objects in the language, in that they can be assigned to variables, passed around and returned from functions, just like any other construct. But, if they're truly first class, we should be able to pattern match on them too! Idris 2 allows us to do this. For example"
msgstr ""

#: ../source/tutorial/multiplicities.rst:510
#: ba721eac5ca349ae8fa94b0a532231d2
msgid "We can try this as follows::"
msgstr ""

#: ../source/tutorial/multiplicities.rst:519
#: 12af5ee908794022a1c7c25376328703
msgid "Pattern matching on function types is interesting, because the return type may depend on the input value. For example, let's add a case to ``showType``"
msgstr ""

#: ../source/tutorial/multiplicities.rst:527
#: 7bf155c3ebad4ea090e6b07b9917d8ad
msgid "Inspecting the type of ``help`` tells us::"
msgstr ""

#: ../source/tutorial/multiplicities.rst:534
#: 5a8e69fabcbe4ab090e93cfc465597ab
msgid "So, the return type ``a`` depends on the input value of type ``Nat``, and we'll need to come up with a value to use ``a``, for example"
msgstr ""

#: ../source/tutorial/multiplicities.rst:541
#: 37b49a1d832f4442b471049309e4d75f
msgid "Note that multiplicities on the binders, and the ability to pattern match on *non-erased* types mean that the following two types are distinct"
msgstr ""

#: ../source/tutorial/multiplicities.rst:549
#: 712c897137d74a2ea347138513ae71aa
msgid "In the case of ``notId``, we can match on ``a`` and get a function which is certainly not the identity function"
msgstr ""

#: ../source/tutorial/multiplicities.rst:564
#: 267ecd35a607418abc0136c741b9208e
msgid "There is an important consequence of being able to distinguish between relevant and irrelevant type arguments, which is that a function is *only* parametric in ``a`` if ``a`` has multiplicity ``0``. So, in the case of ``notId``, ``a`` is *not* a parameter, and so we can't draw any conclusions about the way the function will behave because it is polymorphic, because the type tells us it might pattern match on ``a``."
msgstr ""

#: ../source/tutorial/multiplicities.rst:571
#: 8c30087d936049c2ac8e9919cd98df5e
msgid "On the other hand, it is merely a coincidence that, in non-dependently typed languages, types are *irrelevant* and get erased, and values are *relevant* and remain at run time. Idris 2, being based on QTT, allows us to make the distinction between relevant and irrelevant arguments precise. Types can be relevant, values (such as the ``n`` index to vectors) can be irrelevant."
msgstr ""

#: ../source/tutorial/multiplicities.rst:577
#: 40e105bd859d434382469291e8e7acb8
msgid "For more details on multiplicities, see `Idris 2: Quantitative Type Theory in Action <https://www.type-driven.org.uk/edwinb/idris-2-quantitative-type-theory-in-action.html>`_."
msgstr ""
