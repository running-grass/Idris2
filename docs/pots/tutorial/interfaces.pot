# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-23 12:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/tutorial/interfaces.rst:5
#: 0990d55a652c498d81506e86df277485
msgid "Interfaces"
msgstr ""

#: ../source/tutorial/interfaces.rst:7
#: d458f2b9510046b696afa81ab6222800
msgid "We often want to define functions which work across several different data types. For example, we would like arithmetic operators to work on ``Int``, ``Integer`` and ``Double`` at the very least. We would like ``==`` to work on the majority of data types. We would like to be able to display different types in a uniform way."
msgstr ""

#: ../source/tutorial/interfaces.rst:13
#: bf1274a833264b59bc240a3029c72086
msgid "To achieve this, we use *interfaces*, which are similar to type classes in Haskell or traits in Rust. To define an interface, we provide a collection of overloadable functions. A simple example is the ``Show`` interface, which is defined in the prelude and provides an interface for converting values to ``String``:"
msgstr ""

#: ../source/tutorial/interfaces.rst:24
#: 05bc728c417d4351895381fd159ed1de
msgid "This generates a function of the following type (which we call a *method* of the ``Show`` interface):"
msgstr ""

#: ../source/tutorial/interfaces.rst:31
#: 4dfee611e44341f1913d38bbf88fc695
msgid "We can read this as: “under the constraint that ``a`` has an implementation of ``Show``, take an input ``a`` and return a ``String``.” An implementation of an interface is defined by giving definitions of the methods of the interface. For example, the ``Show`` implementation for ``Nat`` could be defined as:"
msgstr ""

#: ../source/tutorial/interfaces.rst:47
#: a37cf431a2a948d49e6c06114abf566c
msgid "Only one implementation of an interface can be given for a type — implementations may not overlap. Implementation declarations can themselves have constraints. To help with resolution, the arguments of an implementation must be constructors (either data or type constructors) or variables (i.e. you cannot give an implementation for a function). For example, to define a ``Show`` implementation for vectors, we need to know that there is a ``Show`` implementation for the element type, because we are going to use it to convert each element to a ``String``:"
msgstr ""

#: ../source/tutorial/interfaces.rst:65
#: 18907e2c55b248b7be635564b63912c3
msgid "Note that we need the explicit ``forall n .`` in the ``show'`` function because otherwise the ``n`` is already in scope, and fixed to the value of the top level ``n``."
msgstr ""

#: ../source/tutorial/interfaces.rst:70
#: 639c3191509348a6b51d36605b9ef2eb
msgid "Default Definitions"
msgstr ""

#: ../source/tutorial/interfaces.rst:72
#: 5689616401534f49bd5ec81a1c7fae43
msgid "The Prelude defines an ``Eq`` interface which provides methods for comparing values for equality or inequality, with implementations for all of the built-in types:"
msgstr ""

#: ../source/tutorial/interfaces.rst:82
#: 4c382b89f65347cf84bdd3230ec7faab
msgid "To declare an implementation for a type, we have to give definitions of all of the methods. For example, for an implementation of ``Eq`` for ``Nat``:"
msgstr ""

#: ../source/tutorial/interfaces.rst:95
#: 856bc82a563f47dfba88b8d220dc7217
msgid "It is hard to imagine many cases where the ``/=`` method will be anything other than the negation of the result of applying the ``==`` method. It is therefore convenient to give a default definition for each method in the interface declaration, in terms of the other method:"
msgstr ""

#: ../source/tutorial/interfaces.rst:109
#: e8a2df14f41e47e78fe93e0e39517374
msgid "A minimal complete implementation of ``Eq`` requires either ``==`` or ``/=`` to be defined, but does not require both. If a method definition is missing, and there is a default definition for it, then the default is used instead."
msgstr ""

#: ../source/tutorial/interfaces.rst:115
#: df41556f60fd4e5ba1346853093ca0a0
msgid "Extending Interfaces"
msgstr ""

#: ../source/tutorial/interfaces.rst:117
#: 05cc6ddb0f274919952209dad45e9d23
msgid "Interfaces can also be extended. A logical next step from an equality relation ``Eq`` is to define an ordering relation ``Ord``. We can define an ``Ord`` interface which inherits methods from ``Eq`` as well as defining some of its own:"
msgstr ""

#: ../source/tutorial/interfaces.rst:138
#: f3780239d655480e879418b75fc27ce5
msgid "The ``Ord`` interface allows us to compare two values and determine their ordering. Only the ``compare`` method is required; every other method has a default definition. Using this we can write functions such as ``sort``, a function which sorts a list into increasing order, provided that the element type of the list is in the ``Ord`` interface. We give the constraints on the type variables left of the fat arrow ``=>``, and the function type to the right of the fat arrow:"
msgstr ""

#: ../source/tutorial/interfaces.rst:150
#: 33e0f09926b7496aa96d4c2b2f4f03de
msgid "Functions, interfaces and implementations can have multiple constraints. Multiple constraints are written in brackets in a comma separated list, for example:"
msgstr ""

#: ../source/tutorial/interfaces.rst:159
#: 2334b84e2c5b4ef9b56113f16e27e6df
msgid "Constraints are, like types, first class objects in the language. You can see this at the REPL:"
msgstr ""

#: ../source/tutorial/interfaces.rst:167
#: d0a9b529effe4333b04e3f99057fcc78
msgid "So, ``(Ord a, Show a)`` is an ordinary pair of ``Types``, with two constraints as the first and second element of the pair."
msgstr ""

#: ../source/tutorial/interfaces.rst:171
#: d6cb1130efd94b4d8585c8b22681b0b7
msgid "Note: Interfaces and ``mutual`` blocks"
msgstr ""

#: ../source/tutorial/interfaces.rst:173
#: dff582cc506a41aea5f38f0054b39982
msgid "Idris is strictly \"define before use\", except in ``mutual`` blocks. In a ``mutual`` block, Idris elaborates in two passes: types on the first pass and definitions on the second. When the mutual block contains an interface declaration, it elaborates the interface header but none of the method types on the first pass, and elaborates the method types and any default definitions on the second pass."
msgstr ""

#: ../source/tutorial/interfaces.rst:181
#: 8435872bb0ce495f9b593450bb468071
msgid "Quantities for Parameters"
msgstr ""

#: ../source/tutorial/interfaces.rst:183
#: 02ce079e159b42c6a05970d4a3c547de
msgid "By default parameters that are not explicitly ascribed a type in an ``interface`` declaration are assigned the quantity ``0``. This means that the parameter is not available to use at runtime in the methods' definitions."
msgstr ""

#: ../source/tutorial/interfaces.rst:187
#: 66dd5f00889a49c19d322227fff585af
msgid "For instance, ``Show a`` gives rise to a ``0``-quantified type variable ``a`` in the type of the ``show`` method:"
msgstr ""

#: ../source/tutorial/interfaces.rst:196
#: 5a4e8472790b45d2b20fa8895a5b0be1
msgid "However some use cases require that some of the parameters are available at runtime. We may for instance want to declare an interface for ``Storable`` types. The constraint ``Storable a size`` means that we can store values of type ``a`` in a ``Buffer`` in exactly ``size`` bytes."
msgstr ""

#: ../source/tutorial/interfaces.rst:201
#: 833f3620ea044505a459e97633608719
msgid "If the user provides a method to read a value for such a type ``a`` at a given offset, then we can read the ``k`` th element stored in the buffer by computing the appropriate offset from ``k`` and ``size``. This is demonstrated by providing a default implementation for the method ``peekElementOff`` implemented in terms of ``peekByteOff`` and the parameter ``size``."
msgstr ""

#: ../source/tutorial/interfaces.rst:219
#: 6fab44650f7b4becadd2fc9ff9580e70
msgid "Note that ``a`` is explicitly marked as runtime irrelevant so that it is erased by the compiler. Equivalently we could have written ``interface Storable a (size : Nat)``. The meaning of ``| a`` is explained in :ref:`DeterminingParameters`."
msgstr ""

#: ../source/tutorial/interfaces.rst:225
#: 50892bb4ba30453cb60aa32a4786c6cb
msgid "Functors and Applicatives"
msgstr ""

#: ../source/tutorial/interfaces.rst:227
#: 152001cfa81446adb22603cac6e049b4
msgid "So far, we have seen single parameter interfaces, where the parameter is of type ``Type``. In general, there can be any number of parameters (even zero), and the parameters can have *any* type. If the type of the parameter is not ``Type``, we need to give an explicit type declaration. For example, the ``Functor`` interface is defined in the prelude:"
msgstr ""

#: ../source/tutorial/interfaces.rst:240
#: 466d569c545149059d71bcd5c20d5375
msgid "A functor allows a function to be applied across a structure, for example to apply a function to every element in a ``List``:"
msgstr ""

#: ../source/tutorial/interfaces.rst:254
#: 732bd55e475a46e980757a5b5db2fb31
msgid "Having defined ``Functor``, we can define ``Applicative`` which abstracts the notion of function application:"
msgstr ""

#: ../source/tutorial/interfaces.rst:268
#: 2bb3ce8dc52047c5a7b19d50a323efea
msgid "Monads and ``do``-notation"
msgstr ""

#: ../source/tutorial/interfaces.rst:270
#: 728d0e0746e0414cbc28146d10d72b12
msgid "The ``Monad`` interface allows us to encapsulate binding and computation, and is the basis of ``do``-notation introduced in Section :ref:`sect-do`. It extends ``Applicative`` as defined above, and is defined as follows:"
msgstr ""

#: ../source/tutorial/interfaces.rst:280
#: 30459fa542d343128cee1acb8468525c
msgid "There is also a non-binding sequencing operator, defined for ``Monad`` as:"
msgstr ""

#: ../source/tutorial/interfaces.rst:286
#: a3d52a67639744bfaf40af7cd5b3ffa3
msgid "Inside a ``do`` block, the following syntactic transformations are applied:"
msgstr ""

#: ../source/tutorial/interfaces.rst:289
#: 32a8db94d41a4ccbb3373d173e661780
msgid "``x <- v; e`` becomes ``v >>= (\\x => e)``"
msgstr ""

#: ../source/tutorial/interfaces.rst:291
#: 5b27eced647a4770ad95ce75c0d976be
msgid "``v; e`` becomes ``v >> e``"
msgstr ""

#: ../source/tutorial/interfaces.rst:293
#: 8fa40e5f35e445dc8ed42d0ed31465e3
msgid "``let x = v; e`` becomes ``let x = v in e``"
msgstr ""

#: ../source/tutorial/interfaces.rst:295
#: 231914d9bc8e428b92bab40939714267
msgid "``IO`` has an implementation of ``Monad``, defined using primitive functions. We can also define an implementation for ``Maybe``, as follows:"
msgstr ""

#: ../source/tutorial/interfaces.rst:304
#: 7c48bbaa699a45879c017de8f16e8360
msgid "Using this we can, for example, define a function which adds two ``Maybe Int``, using the monad to encapsulate the error handling:"
msgstr ""

#: ../source/tutorial/interfaces.rst:314
#: 9f1024db9a674ce6b7a9e683a8112196
msgid "This function will extract the values from ``x`` and ``y``, if they are both available, or return ``Nothing`` if one or both are not (\"fail fast\"). Managing the ``Nothing`` cases is achieved by the ``>>=`` operator, hidden by the ``do`` notation."
msgstr ""

#: ../source/tutorial/interfaces.rst:326
#: 497ff1dc0a2d46bcbd0f1a5bf9569854
msgid "The translation of ``do`` notation is entirely syntactic, so there is no need for the ``(>>=)`` and ``(>>)`` operators to be the operator defined in the ``Monad`` interface. Idris will, in general, try to disambiguate which operators you mean by type, but you can explicitly choose with qualified do notation, for example:"
msgstr ""

#: ../source/tutorial/interfaces.rst:340
#: 1943a43ee17544acb026497f69e4ce50
msgid "The ``Prelude.do`` means that Idris will use the ``(>>=)`` and ``(>>)`` operators defined in the ``Prelude``."
msgstr ""

#: ../source/tutorial/interfaces.rst:344
#: 9c5013608ae2435f9a0a73bc72916b59
msgid "Pattern Matching Bind"
msgstr ""

#: ../source/tutorial/interfaces.rst:346
#: 83739bfa02954bb5869dcc74446fc3db
msgid "Sometimes we want to pattern match immediately on the result of a function in ``do`` notation. For example, let's say we have a function ``readNumber`` which reads a number from the console, returning a value of the form ``Just x`` if the number is valid, or ``Nothing`` otherwise:"
msgstr ""

#: ../source/tutorial/interfaces.rst:362
#: 989f869f9a244a80974c197c2daaee39
msgid "If we then use it to write a function to read two numbers, returning ``Nothing`` if neither are valid, then we would like to pattern match on the result of ``readNumber``:"
msgstr ""

#: ../source/tutorial/interfaces.rst:378
#: a16d021ceca6451db57d5a8d23678db2
msgid "If there's a lot of error handling, this could get deeply nested very quickly! So instead, we can combine the bind and the pattern match in one line. For example, we could try pattern matching on values of the form ``Just x_ok``:"
msgstr ""

#: ../source/tutorial/interfaces.rst:390
#: e1427b89b2fd45bf896757086336fdf9
msgid "There is still a problem, however, because we've now omitted the case for ``Nothing`` so ``readNumbers`` is no longer total! We can add the ``Nothing`` case back as follows:"
msgstr ""

#: ../source/tutorial/interfaces.rst:404
#: 92a58859c75b417f8da3d01ccf49e371
msgid "The effect of this version of ``readNumbers`` is identical to the first (in fact, it is syntactic sugar for it and directly translated back into that form). The first part of each statement (``Just x_ok <-`` and ``Just y_ok <-``) gives the preferred binding - if this matches, execution will continue with the rest of the ``do`` block. The second part gives the alternative bindings, of which there may be more than one."
msgstr ""

#: ../source/tutorial/interfaces.rst:412
#: b6bc70201dd54e2baffe323fec644e32
msgid "``!``-notation"
msgstr ""

#: ../source/tutorial/interfaces.rst:414
#: 92d80e1fc600414d9ed88eda6a0394dd
msgid "In many cases, using ``do``-notation can make programs unnecessarily verbose, particularly in cases such as ``m_add`` above where the value bound is used once, immediately. In these cases, we can use a shorthand version, as follows:"
msgstr ""

#: ../source/tutorial/interfaces.rst:424
#: 75a3f58d38874f10af85e818d5f62def
msgid "The notation ``!expr`` means that the expression ``expr`` should be evaluated and then implicitly bound. Conceptually, we can think of ``!`` as being a prefix function with the following type:"
msgstr ""

#: ../source/tutorial/interfaces.rst:432
#: d7fbb0ca650f4f6d81127a586042e47e
msgid "Note, however, that it is not really a function, merely syntax! In practice, a subexpression ``!expr`` will lift ``expr`` as high as possible within its current scope, bind it to a fresh name ``x``, and replace ``!expr`` with ``x``. Expressions are lifted depth first, left to right. In practice, ``!``-notation allows us to program in a more direct style, while still giving a notational clue as to which expressions are monadic."
msgstr ""

#: ../source/tutorial/interfaces.rst:440
#: d83be0e09f5c4437aef7147c68797ca2
msgid "For example, the expression:"
msgstr ""

#: ../source/tutorial/interfaces.rst:446
#: 85819d81f0c04cc9878130de068b1c4d
msgid "is lifted to:"
msgstr ""

#: ../source/tutorial/interfaces.rst:456
#: 891329b7729e48df88a3db5612d813b0
msgid "Monad comprehensions"
msgstr ""

#: ../source/tutorial/interfaces.rst:458
#: dcb47b05839b462cbef0506ebfd3ad76
msgid "The list comprehension notation we saw in Section :ref:`sect-more-expr` is more general, and applies to anything which has an implementation of both ``Monad`` and ``Alternative``:"
msgstr ""

#: ../source/tutorial/interfaces.rst:468
#: 03184b8e0fad458aa568a022a47b25d7
msgid "In general, a comprehension takes the form ``[ exp | qual1, qual2, …, qualn ]`` where ``quali`` can be one of:"
msgstr ""

#: ../source/tutorial/interfaces.rst:471
#: f7b2c4120b3d4933aede428f507b5682
msgid "A generator ``x <- e``"
msgstr ""

#: ../source/tutorial/interfaces.rst:473
#: b22bfd48802847a6846c6fc31fb990ef
msgid "A *guard*, which is an expression of type ``Bool``"
msgstr ""

#: ../source/tutorial/interfaces.rst:475
#: 4b4b789fec04494db9865ac2c72d9932
msgid "A let binding ``let x = e``"
msgstr ""

#: ../source/tutorial/interfaces.rst:477
#: 70dd9217a9ca488391ac18bc87064ce5
msgid "To translate a comprehension ``[exp | qual1, qual2, …, qualn]``, first any qualifier ``qual`` which is a *guard* is translated to ``guard qual``, using the following function:"
msgstr ""

#: ../source/tutorial/interfaces.rst:485
#: b063f23bf1cf4f04a9a1ee23ba9372bb
msgid "Then the comprehension is converted to ``do`` notation:"
msgstr ""

#: ../source/tutorial/interfaces.rst:491
#: 87080011bf0f47b48da868153292137f
msgid "Using monad comprehensions, an alternative definition for ``m_add`` would be:"
msgstr ""

#: ../source/tutorial/interfaces.rst:500
#: 2d1e2fff0fb84a52af0f58b7d783f8b3
msgid "Interfaces and IO"
msgstr ""

#: ../source/tutorial/interfaces.rst:502
#: 2b54b90ebda64d77b338df27b2decf83
msgid "In general, ``IO`` operations in the libraries aren't written using ``IO`` directly, but rather via the ``HasIO`` interface:"
msgstr ""

#: ../source/tutorial/interfaces.rst:510
#: ed07a21a37654c16b588c2067f761634
msgid "``HasIO`` explains, via ``liftIO``, how to convert a primitive ``IO`` operation to an operation in some underlying type, as long as that type has a ``Monad`` implementation.  These interface allows a programmer to define some more expressive notion of interactive program, while still giving direct access to ``IO`` primitives."
msgstr ""

#: ../source/tutorial/interfaces.rst:517
#: a4871ca0852941c3b0f5942dffb59dad
msgid "Idiom brackets"
msgstr ""

#: ../source/tutorial/interfaces.rst:519
#: c08f23fbc4274f069b18cef087076f93
msgid "While ``do`` notation gives an alternative meaning to sequencing, idioms give an alternative meaning to *application*. The notation and larger example in this section is inspired by Conor McBride and Ross Paterson’s paper “Applicative Programming with Effects” [#ConorRoss]_."
msgstr ""

#: ../source/tutorial/interfaces.rst:524
#: 3f293234ade54c86bf8ccbda5eca319c
msgid "First, let us revisit ``m_add`` above. All it is really doing is applying an operator to two values extracted from ``Maybe Int``. We could abstract out the application:"
msgstr ""

#: ../source/tutorial/interfaces.rst:534
#: 93110f56686746dbbd1a2988329e0a51
msgid "Using this, we can write an alternative ``m_add`` which uses this alternative notion of function application, with explicit calls to ``m_app``:"
msgstr ""

#: ../source/tutorial/interfaces.rst:543
#: 1a0f2bc0de844e11ac80e3e48c2ce553
msgid "Rather than having to insert ``m_app`` everywhere there is an application, we can use idiom brackets to do the job for us. To do this, we can give ``Maybe`` an implementation of ``Applicative`` as follows, where ``<*>`` is defined in the same way as ``m_app`` above (this is defined in the Idris library):"
msgstr ""

#: ../source/tutorial/interfaces.rst:557
#: 12a4f30d661048d38b8a44c7d3b10732
msgid "Using ``<*>`` we can use this implementation as follows, where a function application ``[| f a1 …an |]`` is translated into ``pure f <*> a1 <*> … <*> an``:"
msgstr ""

#: ../source/tutorial/interfaces.rst:567
#: d884f71b62d94313a47bf4c5481fdf53
msgid "An error-handling interpreter"
msgstr ""

#: ../source/tutorial/interfaces.rst:569
#: 0458255a8d0641c49ce2fd13227fe581
msgid "Idiom notation is commonly useful when defining evaluators. McBride and Paterson describe such an evaluator [#ConorRoss]_, for a language similar to the following:"
msgstr ""

#: ../source/tutorial/interfaces.rst:579
#: 40b1db6b5ede4a6c9e115850a42d5161
msgid "Evaluation will take place relative to a context mapping variables (represented as ``String``\\s) to ``Int`` values, and can possibly fail. We define a data type ``Eval`` to wrap an evaluator:"
msgstr ""

#: ../source/tutorial/interfaces.rst:588
#: dd03f662bf2248179785bdbbc4c5bc4d
msgid "Wrapping the evaluator in a data type means we will be able to provide implementations of interfaces for it later. We begin by defining a function to retrieve values from the context during evaluation:"
msgstr ""

#: ../source/tutorial/interfaces.rst:602
#: 9998081983cf463491d047eb825216f3
msgid "When defining an evaluator for the language, we will be applying functions in the context of an ``Eval``, so it is natural to give ``Eval`` an implementation of ``Applicative``. Before ``Eval`` can have an implementation of ``Applicative`` it is necessary for ``Eval`` to have an implementation of ``Functor``:"
msgstr ""

#: ../source/tutorial/interfaces.rst:621
#: 6b52379eae9a4559915cf6bec0234e70
msgid "Evaluating an expression can now make use of the idiomatic application to handle errors:"
msgstr ""

#: ../source/tutorial/interfaces.rst:635
#: bdf9635690b1417c853493def903059c
msgid "For example:"
msgstr ""

#: ../source/tutorial/interfaces.rst:645
#: 7fe8f130bca24fd2b62e404310d732c3
msgid "Named Implementations"
msgstr ""

#: ../source/tutorial/interfaces.rst:647
#: 1ad399fa439e4e789f815b316668fe01
msgid "It can be desirable to have multiple implementations of an interface for the same type, for example to provide alternative methods for sorting or printing values. To achieve this, implementations can be *named* as follows:"
msgstr ""

#: ../source/tutorial/interfaces.rst:659
#: 5feef40298674d8382d115e6839d1da4
msgid "This declares an implementation as normal, but with an explicit name, ``myord``. The syntax ``compare @{myord}`` gives an explicit implementation to ``compare``, otherwise it would use the default implementation for ``Nat``. We can use this, for example, to sort a list of ``Nat`` in reverse. Given the following list:"
msgstr ""

#: ../source/tutorial/interfaces.rst:670
#: a51a19122c654c2c87e2fe29b583ca8d
msgid "We can sort it using the default ``Ord`` implementation, by using the ``sort`` function available with ``import Data.List``, then we can try with the named implementation ``myord`` as follows, at the Idris prompt:"
msgstr ""

#: ../source/tutorial/interfaces.rst:681
#: d691fa8e7ef44e559a3247e1fd5cf74f
msgid "Sometimes, we also need access to a named parent implementation. For example, the prelude defines the following ``Semigroup`` interface:"
msgstr ""

#: ../source/tutorial/interfaces.rst:689
#: 187c75340ae44ef4b2127d9db81f38eb
msgid "Then it defines ``Monoid``, which extends ``Semigroup`` with a “neutral” value:"
msgstr ""

#: ../source/tutorial/interfaces.rst:697
#: c940f886723a4bf693919c7616f30bdf
msgid "We can define two different implementations of ``Semigroup`` and ``Monoid`` for ``Nat``, one based on addition and one on multiplication:"
msgstr ""

#: ../source/tutorial/interfaces.rst:708
#: 3c3455f5ef094f22a687e4d6b5114c79
msgid "The neutral value for addition is ``0``, but the neutral value for multiplication is ``1``. It's important, therefore, that when we define implementations of ``Monoid`` they extend the correct ``Semigroup`` implementation. We can do this with a ``using`` clause in the implementation as follows:"
msgstr ""

#: ../source/tutorial/interfaces.rst:721
#: 943467ae44a54e39b069a965075aeaf1
msgid "The ``using PlusNatSemi`` clause indicates that ``PlusNatMonoid`` should extend ``PlusNatSemi`` specifically."
msgstr ""

#: ../source/tutorial/interfaces.rst:727
#: 36d39112c4944d17bbd4c3e201d7deb9
msgid "Interface Constructors"
msgstr ""

#: ../source/tutorial/interfaces.rst:729
#: f76cf73bcc5e415bbb1dfe1b61602048
msgid "Interfaces, just like records, can be declared with a user-defined constructor."
msgstr ""

#: ../source/tutorial/interfaces.rst:741
#: 07f5e2ff513e4916aba1c4e753a2e63a
msgid "Then ``MkB : A t => t -> B t``."
msgstr ""

#: ../source/tutorial/interfaces.rst:746
#: 54f4608c49ba40ac9f29e1ee998b3060
msgid "Determining Parameters"
msgstr ""

#: ../source/tutorial/interfaces.rst:748
#: d2f6a601124944eeb7ab909482dda732
msgid "When an interface has more than one parameter, it can help resolution if the parameters used to find an implementation are restricted. For example:"
msgstr ""

#: ../source/tutorial/interfaces.rst:757
#: 0fe6a66526064df7b61f70a929498978
msgid "In this interface, only ``m`` needs to be known to find an implementation of this interface, and ``s`` can then be determined from the implementation. This is declared with the ``| m`` after the interface declaration. We call ``m`` a *determining parameter* of the ``MonadState`` interface, because it is the parameter used to find an implementation. This is similar to the concept of *functional dependencies* `in Haskell <https://wiki.haskell.org/Functional_dependencies>`_."
msgstr ""

#: ../source/tutorial/interfaces.rst:764
#: e1eee732ffce4ba5a2a2bea1e3743246
msgid "Conor McBride and Ross Paterson. 2008. Applicative programming with effects. J. Funct. Program. 18, 1 (January 2008), 1-13. DOI=10.1017/S0956796807006326 https://dx.doi.org/10.1017/S0956796807006326"
msgstr ""
