# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-23 12:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/tutorial/theorems.rst:5
#: 85c990e79f4b4136b88d1b022ad25e85
msgid "Theorem Proving"
msgstr ""

#: ../source/tutorial/theorems.rst:8
#: 4f60e62550bf471898414d5263e5914c
msgid "Equality"
msgstr ""

#: ../source/tutorial/theorems.rst:10
#: 72b147569e654fffa4c5f807f4a675f4
msgid "Idris allows propositional equalities to be declared, allowing theorems about programs to be stated and proved. An equality type is defined as follows in the Prelude:"
msgstr ""

#: ../source/tutorial/theorems.rst:19
#: e5adfcac6b83465db52aa13497e36eed
msgid "As a notational convenience, ``Equal x y`` can be written as ``x = y``. Equalities can be proposed between any values of any types, but the only way to construct a proof of equality is if values actually are equal. For example:"
msgstr ""

#: ../source/tutorial/theorems.rst:32
#: 806b225d10db4ee7bf73e23cf519c736
msgid "If we try..."
msgstr ""

#: ../source/tutorial/theorems.rst:39
#: d34f20849a824ee7a3f33a086ef45b60
msgid "...then we'll get an error:"
msgstr ""

#: ../source/tutorial/theorems.rst:53
#: fc5a5dfcc147425aa84e64f3ba8d9273
msgid "The Empty Type"
msgstr ""

#: ../source/tutorial/theorems.rst:55
#: 59567b0b564541278a2b88eb068b90fa
msgid "There is an empty type, ``Void``, which has no constructors. It is therefore impossible to construct a canonical element of the empty type. We can therefore use the empty type to prove that something is impossible, for example zero is never equal to a successor:"
msgstr ""

#: ../source/tutorial/theorems.rst:69
#: 69a1bdd69f3849aaa9e4620dd2251ee9
msgid "Don't worry if you don't get all the details of how this works just yet - essentially, it applies the library function ``replace``, which uses an equality proof to transform a predicate. Here we use it to transform a value of a type which can exist, the empty tuple, to a value of a type which can’t, by using a proof of something which can’t exist."
msgstr ""

#: ../source/tutorial/theorems.rst:75
#: 88cd6fb7d4e54deb95dfeeaf91189215
msgid "Once we have an element of the empty type, we can prove anything. ``void`` is defined in the library, to assist with proofs by contradiction."
msgstr ""

#: ../source/tutorial/theorems.rst:84
#: 84c2a480d9224ca6ae195b4f03869927
msgid "Proving Theorems"
msgstr ""

#: ../source/tutorial/theorems.rst:86
#: 21fea9899cdd4c50961c6620ab76b7bf
msgid "When type checking dependent types, the type itself gets *normalised*. So imagine we want to prove the following theorem about the reduction behaviour of ``plus``:"
msgstr ""

#: ../source/tutorial/theorems.rst:94
#: 6922f1938966443fb11afd25ee12598c
msgid "We’ve written down the statement of the theorem as a type, in just the same way as we would write the type of a program. In fact there is no real distinction between proofs and programs. A proof, as far as we are concerned here, is merely a program with a precise enough type to guarantee a particular property of interest."
msgstr ""

#: ../source/tutorial/theorems.rst:100
#: 1af735e965234ebc8e23777ad95d2408
msgid "We won’t go into details here, but the Curry-Howard correspondence [#Timothy]_ explains this relationship. The proof itself is immediate, because ``plus Z n`` normalises to ``n`` by the definition of ``plus``:"
msgstr ""

#: ../source/tutorial/theorems.rst:108
#: 99a1fbd048ac445d8710465677dd8cc7
msgid "It is slightly harder if we try the arguments the other way, because plus is defined by recursion on its first argument. The proof also works by recursion on the first argument to ``plus``, namely ``n``."
msgstr ""

#: ../source/tutorial/theorems.rst:118
#: 20d7bec8238e4e7ca67447e2456d3e46
msgid "``cong`` is a function defined in the library which states that equality respects function application:"
msgstr ""

#: ../source/tutorial/theorems.rst:125
#: 30fdedfb1d7b46888e25e00c831ded4c
msgid "To see more detail on what's going on, we can replace the recursive call to ``plusReducesZ`` with a hole:"
msgstr ""

#: ../source/tutorial/theorems.rst:132
#: 7b92dc5215cd462f9a07b3ba685a6d21
msgid "Then inspecting the type of the hole at the REPL shows us:"
msgstr ""

#: ../source/tutorial/theorems.rst:141
#: a4c34b4b07764964badd48244db6fea5
msgid "We can do the same for the reduction behaviour of plus on successors:"
msgstr ""

#: ../source/tutorial/theorems.rst:149
#: e0d6629105164258a0888ede21a06fbb
msgid "Even for small theorems like these, the proofs are a little tricky to construct in one go. When things get even slightly more complicated, it becomes too much to think about to construct proofs in this “batch mode”."
msgstr ""

#: ../source/tutorial/theorems.rst:154
#: b2f628bfd89e4a1b9038f52ab9f7b7b7
msgid "Idris provides interactive editing capabilities, which can help with building proofs. For more details on building proofs interactively in an editor, see :ref:`proofs-index`."
msgstr ""

#: ../source/tutorial/theorems.rst:161
#: abf4c987af724be98879cc5f0051e2e0
msgid "Theorems in Practice"
msgstr ""

#: ../source/tutorial/theorems.rst:163
#: 21b56dcbe78544b58f56cbce38468cbc
msgid "The need to prove theorems can arise naturally in practice. For example, previously (:ref:`sec-views`) we implemented ``natToBin`` using a function ``parity``:"
msgstr ""

#: ../source/tutorial/theorems.rst:171
#: 51083129bfa04fb788786155ab0839da
msgid "We provided a definition for ``parity``, but without explanation.  We might have hoped that it would look something like the following:"
msgstr ""

#: ../source/tutorial/theorems.rst:183
#: 004e771b7b704e38868aade7d4ea17f3
msgid "Unfortunately, this fails with a type error:"
msgstr ""

#: ../source/tutorial/theorems.rst:193
#: 02b8b342eb844c22a4f9b219650c6030
msgid "The problem is that normalising ``S j + S j``, in the type of ``Even`` doesn't result in what we need for the type of the right hand side of ``Parity``. We know that ``S (S (plus j j))`` is going to be equal to ``S j + S j``, but we need to explain it to Idris with a proof. We can begin by adding some *holes* (see :ref:`sect-holes`) to the definition:"
msgstr ""

#: ../source/tutorial/theorems.rst:210
#: b07c5dbcc6b748dfa05b7089ddac2bb9
msgid "Checking the type of ``helpEven`` shows us what we need to prove for the ``Even`` case:"
msgstr ""

#: ../source/tutorial/theorems.rst:220
#: 15da44499032454dbbef6213e76d44a1
msgid "We can therefore write a helper function to *rewrite* the type to the form we need:"
msgstr ""

#: ../source/tutorial/theorems.rst:228
#: 9483144fa49148c0b9aef12c083fbb08
msgid "The ``rewrite ... in`` syntax allows you to change the required type of an expression by rewriting it according to an equality proof. Here, we have used ``plusSuccRightSucc``, which has the following type:"
msgstr ""

#: ../source/tutorial/theorems.rst:236
#: 9d480adb4d42422092a3ff9d1017851b
msgid "We can see the effect of ``rewrite`` by replacing the right hand side of ``helpEven`` with a hole, and working step by step. Beginning with the following:"
msgstr ""

#: ../source/tutorial/theorems.rst:244
#: 73a9f03b242c47788471dffb82722171
msgid "We can look at the type of ``helpEven_rhs``:"
msgstr ""

#: ../source/tutorial/theorems.rst:253
#: e45bf30d372848c3931bf61dcb7e01e8
msgid "Then we can ``rewrite`` by applying ``plusSuccRightSucc j j``, which gives an equation ``S (j + j) = j + S j``, thus replacing ``S (j + j)`` (or, in this case, ``S (plus j j)`` since ``S (j + j)`` reduces to that) in the type with ``j + S j``:"
msgstr ""

#: ../source/tutorial/theorems.rst:263
#: ffc3c4f38d25441b8ca73d89c075a906
msgid "Checking the type of ``helpEven_rhs`` now shows what has happened, including the type of the equation we just used (as the type of ``_rewrite_rule``):"
msgstr ""

#: ../source/tutorial/theorems.rst:274
#: e1ee361293b640ab9e63d831413bc594
msgid "Using ``rewrite`` and another helper for the ``Odd`` case, we can complete ``parity`` as follows:"
msgstr ""

#: ../source/tutorial/theorems.rst:292
#: 8fae13b0be09402b8f266399d58eb6cd
msgid "Full details of ``rewrite`` are beyond the scope of this introductory tutorial, but it is covered in the theorem proving tutorial (see :ref:`proofs-index`)."
msgstr ""

#: ../source/tutorial/theorems.rst:298
#: 3bec92acfc2540218b821dc851e1a002
msgid "Totality Checking"
msgstr ""

#: ../source/tutorial/theorems.rst:300
#: d0b1d7cd3cc9409b96e6cfa65800fd5c
msgid "If we really want to trust our proofs, it is important that they are defined by *total* functions — that is, a function which is defined for all possible inputs and is guaranteed to terminate. Otherwise we could construct an element of the empty type, from which we could prove anything:"
msgstr ""

#: ../source/tutorial/theorems.rst:318
#: 8bfb08bbe0b348a8afad6580976153b8
msgid "Internally, Idris checks every definition for totality, and we can check at the prompt with the ``:total`` command. We see that neither of the above definitions is total:"
msgstr ""

#: ../source/tutorial/theorems.rst:329
#: 1679959e3293472a8b531e853438f01d
msgid "Note the use of the word “possibly” — a totality check can never be certain due to the undecidability of the halting problem. The check is, therefore, conservative. It is also possible (and indeed advisable, in the case of proofs) to mark functions as total so that it will be a compile time error for the totality check to fail:"
msgstr ""

#: ../source/tutorial/theorems.rst:340
#: 0c9c412870db4cc39fbf53af1002cec0
msgid "Reassuringly, our proof in Section :ref:`sect-empty` that the zero and successor constructors are disjoint is total:"
msgstr ""

#: ../source/tutorial/theorems.rst:348
#: f59e67dcb3074cc29f88fe68ca8da69e
msgid "The totality check is, necessarily, conservative. To be recorded as total, a function ``f`` must:"
msgstr ""

#: ../source/tutorial/theorems.rst:351
#: b3f7c4ae7cba407b9d774e43f912c610
msgid "Cover all possible inputs"
msgstr ""

#: ../source/tutorial/theorems.rst:353
#: eddfad38119043b9a2ff2b409b685c33
msgid "Be *well-founded* — i.e. by the time a sequence of (possibly mutually) recursive calls reaches ``f`` again, it must be possible to show that one of its arguments has decreased."
msgstr ""

#: ../source/tutorial/theorems.rst:357
#: 85f788787d3f4d1c994310657dc18d01
msgid "Not use any data types which are not *strictly positive*"
msgstr ""

#: ../source/tutorial/theorems.rst:359
#: 6d9931e3cf234b2aa74a3a274abb79ab
msgid "Not call any non-total functions"
msgstr ""

#: ../source/tutorial/theorems.rst:362
#: cda107c2b9224808a0932547e170a0bb
msgid "Directives and Compiler Flags for Totality"
msgstr ""

#: ../source/tutorial/theorems.rst:366
#: 98dd836816c847ba8249168dbb37736a
msgid "Not all of this is implemented yet for Idris 2"
msgstr ""

#: ../source/tutorial/theorems.rst:368
#: e1ba2278f92d46c0ab09ad85a1b7847b
msgid "By default, Idris allows all well-typed definitions, whether total or not. However, it is desirable for functions to be total as far as possible, as this provides a guarantee that they provide a result for all possible inputs, in finite time. It is possible to make total functions a requirement, either:"
msgstr ""

#: ../source/tutorial/theorems.rst:373
#: 403332a60f70438fa1d544d1df1bdabf
msgid "By using the ``--total`` compiler flag."
msgstr ""

#: ../source/tutorial/theorems.rst:375
#: cedfa37320ed4aaaa3b731bc4b6f9078
msgid "By adding a ``%default total`` directive to a source file. All definitions after this will be required to be total, unless explicitly flagged as ``partial``."
msgstr ""

#: ../source/tutorial/theorems.rst:379
#: f74f38c729e048af9d7ffaf90a0a723c
msgid "All functions *after* a ``%default total`` declaration are required to be total. Correspondingly, after a ``%default partial`` declaration, the requirement is relaxed."
msgstr ""

#: ../source/tutorial/theorems.rst:383
#: 79c7b548e652467aaae8b7294a5eabba
msgid "Finally, the compiler flag ``--warnpartial`` causes to print a warning for any undeclared partial function."
msgstr ""

#: ../source/tutorial/theorems.rst:387
#: 3b475179592743179b40ac104a36f293
msgid "Totality checking issues"
msgstr ""

#: ../source/tutorial/theorems.rst:389
#: 6b3ac7ac93f34091afdff6d84fca0b9d
msgid "Please note that the totality checker is not perfect! Firstly, it is necessarily conservative due to the undecidability of the halting problem, so many programs which *are* total will not be detected as such. Secondly, the current implementation has had limited effort put into it so far, so there may still be cases where it believes a function is total which is not. Do not rely on it for your proofs yet!"
msgstr ""

#: ../source/tutorial/theorems.rst:397
#: 224799809e8a40e09c0b4d0e08fe65e9
msgid "Hints for totality"
msgstr ""

#: ../source/tutorial/theorems.rst:399
#: 520f66665fb441389299b1457fe79a96
msgid "In cases where you believe a program is total, but Idris does not agree, it is possible to give hints to the checker to give more detail for a termination argument. The checker works by ensuring that all chains of recursive calls eventually lead to one of the arguments decreasing towards a base case, but sometimes this is hard to spot. For example, the following definition cannot be checked as ``total`` because the checker cannot decide that ``filter (< x) xs`` will always be smaller than ``(x :: xs)``:"
msgstr ""

#: ../source/tutorial/theorems.rst:415
#: c57574f2a99240b19facc803cef1c5d4
msgid "The function ``assert_smaller``, defined in the prelude, is intended to address this problem:"
msgstr ""

#: ../source/tutorial/theorems.rst:423
#: ec932e8b9c88470d9db418c88a7df2f0
msgid "It simply evaluates to its second argument, but also asserts to the totality checker that ``y`` is structurally smaller than ``x``. This can be used to explain the reasoning for totality if the checker cannot work it out itself. The above example can now be written as:"
msgstr ""

#: ../source/tutorial/theorems.rst:437
#: 571d285974784c3589250d03c967d110
msgid "The expression ``assert_smaller (x :: xs) (filter (<= x) xs)`` asserts that the result of the filter will always be smaller than the pattern ``(x :: xs)``."
msgstr ""

#: ../source/tutorial/theorems.rst:441
#: f8b5263e6b1843ef8c255a47ba062a54
msgid "In more extreme cases, the function ``assert_total`` marks a subexpression as always being total:"
msgstr ""

#: ../source/tutorial/theorems.rst:449
#: 03cba6e7abee417caa5f4599457b315e
msgid "In general, this function should be avoided, but it can be very useful when reasoning about primitives or externally defined functions (for example from a C library) where totality can be shown by an external argument."
msgstr ""

#: ../source/tutorial/theorems.rst:455
#: fd8db052e0a54b64bb6c180644c09717
msgid "Timothy G. Griffin. 1989. A formulae-as-type notion of control. In Proceedings of the 17th ACM SIGPLAN-SIGACT symposium on Principles of programming languages (POPL '90). ACM, New York, NY, USA, 47-58. DOI=10.1145/96709.96714 https://doi.acm.org/10.1145/96709.96714"
msgstr ""
