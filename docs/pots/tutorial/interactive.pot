# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-23 12:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/tutorial/interactive.rst:5
#: e5462ff60e85459cac511d2761901bd9
msgid "Interactive Editing"
msgstr ""

#: ../source/tutorial/interactive.rst:7
#: d20ee02283fa4d4a95eadbd90b838826
msgid "By now, we have seen several examples of how Idris’ dependent type system can give extra confidence in a function’s correctness by giving a more precise description of its intended behaviour in its *type*. We have also seen an example of how the type system can help with embedded DSL development by allowing a programmer to describe the type system of an object language. However, precise types give us more than verification of programs — we can also use the type system to help write programs which are *correct by construction*, interactively."
msgstr ""

#: ../source/tutorial/interactive.rst:16
#: af96c8d0c5264e739356ca8330514ff7
msgid "The Idris REPL provides several commands for inspecting and modifying parts of programs, based on their types, such as case splitting on a pattern variable, inspecting the type of a hole, and even a basic proof search mechanism. In this section, we explain how these features can be exploited by a text editor, and specifically how to do so in `Vim <https://github.com/edwinb/idris2-vim>`_. An interactive mode for `Emacs <https://github.com/idris-hackers/idris-mode>`_ is also available, updated for Idris 2 compatibility as of 23 February 2021."
msgstr ""

#: ../source/tutorial/interactive.rst:27
#: 326f904b12e649ee92104f0d5f069715
msgid "Editing at the REPL"
msgstr ""

#: ../source/tutorial/interactive.rst:30
#: 6eddb1da5e964f73bcbe6380d1d838e1
msgid "The Idris2 repl does not support readline in the interest of keeping dependencies minimal. Unfortunately this precludes some niceties such as line editing, persistent history and completion. A useful work around is to install `rlwrap <https://linux.die.net/man/1/rlwrap>`_, this utility provides all the aforementioned features simply by invoking the Idris2 repl as an argument to the utility ``rlwrap idris2``"
msgstr ""

#: ../source/tutorial/interactive.rst:37
#: b1391a3295194b0eacc1108e74a6d620
msgid "The REPL provides a number of commands, which we will describe shortly, which generate new program fragments based on the currently loaded module. These take the general form:"
msgstr ""

#: ../source/tutorial/interactive.rst:45
#: 16e935a9fe5a42ac86a53c929b0363d7
msgid "That is, each command acts on a specific source line, at a specific name, and outputs a new program fragment. Each command has an alternative form, which *updates* the source file in-place:"
msgstr ""

#: ../source/tutorial/interactive.rst:53
#: a29525296e604d32a8fd4cd99456123d
msgid "It is also possible to invoke Idris in a mode which runs a REPL command, displays the result, then exits, using ``idris2 --client``. For example:"
msgstr ""

#: ../source/tutorial/interactive.rst:63
#: c8465c513a974efd9044816ea2e13c36
msgid "A text editor can take advantage of this, along with the editing commands, in order to provide interactive editing support."
msgstr ""

#: ../source/tutorial/interactive.rst:67
#: f9639307f9dd4a0abee1b9defceb304e
msgid "Editing Commands"
msgstr ""

#: ../source/tutorial/interactive.rst:70
#: f98d879370044a22959d74913eadf0fc
msgid ":addclause"
msgstr ""

#: ../source/tutorial/interactive.rst:72
#: e68e0111e1a2427385b4fa6ddb1c51d7
msgid "The ``:addclause n f`` command, abbreviated ``:ac n f``, creates a template definition for the function named ``f`` declared on line ``n``. For example, if the code beginning on line 94 contains:"
msgstr ""

#: ../source/tutorial/interactive.rst:81
#: 098b1faba3824e17bdf14593b8eccbd8
msgid "then ``:ac 94 vzipWith`` will give:"
msgstr ""

#: ../source/tutorial/interactive.rst:87
#: a68dcb635ef94d69b92a39d8fa3343b1
msgid "The names are chosen according to hints which may be given by a programmer, and then made unique by the machine by adding a digit if necessary. Hints can be given as follows:"
msgstr ""

#: ../source/tutorial/interactive.rst:95
#: 6cc5600222ca42fe843ca211968d79b3
msgid "This declares that any names generated for types in the ``Vect`` family should be chosen in the order ``xs``, ``ys``, ``zs``, ``ws``."
msgstr ""

#: ../source/tutorial/interactive.rst:99
#: 16982781a19c4091b54bb9cca8740807
msgid ":casesplit"
msgstr ""

#: ../source/tutorial/interactive.rst:101
#: a644c944607d466586d7915f2a910e49
msgid "The ``:casesplit n x`` command, abbreviated ``:cs n x``, splits the pattern variable ``x`` on line ``n`` into the various pattern forms it may take, removing any cases which are impossible due to unification errors. For example, if the code beginning on line 94 is:"
msgstr ""

#: ../source/tutorial/interactive.rst:112
#: 6ed615ececf44b0a8bb883e3e0424b26
msgid "then ``:cs 96 xs`` will give:"
msgstr ""

#: ../source/tutorial/interactive.rst:119
#: 685f9f1b76834ce3a6c86b75868a8b6d
msgid "That is, the pattern variable ``xs`` has been split into the two possible cases ``[]`` and ``x :: xs``. Again, the names are chosen according to the same heuristic. If we update the file (using ``:cs!``) then case split on ``ys`` on the same line, we get:"
msgstr ""

#: ../source/tutorial/interactive.rst:128
#: 43b25edd8c0442559a7d00ffb267f925
msgid "That is, the pattern variable ``ys`` has been split into one case ``[]``, Idris having noticed that the other possible case ``y :: ys`` would lead to a unification error."
msgstr ""

#: ../source/tutorial/interactive.rst:133
#: 76aad952f69d4a72b7da002f86629616
msgid ":addmissing"
msgstr ""

#: ../source/tutorial/interactive.rst:135
#: 007bfc965640415884a3a1caf2c8b7a7
msgid "The ``:addmissing n f`` command, abbreviated ``:am n f``, adds the clauses which are required to make the function ``f`` on line ``n`` cover all inputs. For example, if the code beginning on line 94 is:"
msgstr ""

#: ../source/tutorial/interactive.rst:145
#: 4d2b39fc7a7d4eeab366641e77bae4c3
msgid "then ``:am 96 vzipWith`` gives:"
msgstr ""

#: ../source/tutorial/interactive.rst:151
#: 2b680a01808143d4b6afd8ac2ddda811
msgid "That is, it notices that there are no cases for empty vectors, generates the required clauses, and eliminates the clauses which would lead to unification errors."
msgstr ""

#: ../source/tutorial/interactive.rst:156
#: 7a1c3353e2844fef83273cbc312f28c3
msgid ":proofsearch"
msgstr ""

#: ../source/tutorial/interactive.rst:158
#: bdd32cf79c764e70be0385ae33dead54
msgid "The ``:proofsearch n f`` command, abbreviated ``:ps n f``, attempts to find a value for the hole ``f`` on line ``n`` by proof search, trying values of local variables, recursive calls and constructors of the required family. Optionally, it can take a list of *hints*, which are functions it can try applying to solve the hole. For example, if the code beginning on line 94 is:"
msgstr ""

#: ../source/tutorial/interactive.rst:172
#: da6797eb2d9049f59dd6e9433e0ed73d
msgid "then ``:ps 96 vzipWith_rhs_1`` will give"
msgstr ""

#: ../source/tutorial/interactive.rst:178
#: 70f097836f83422282ec4ec9acec5089
msgid "This works because it is searching for a ``Vect`` of length 0, of which the empty vector is the only possibility. Similarly, and perhaps surprisingly, there is only one possibility if we try to solve ``:ps 97 vzipWith_rhs_2``:"
msgstr ""

#: ../source/tutorial/interactive.rst:187
#: 68fbf670cce04103b982be0fe432801f
msgid "This works because ``vzipWith`` has a precise enough type: The resulting vector has to be non-empty (a ``::``); the first element must have type ``c`` and the only way to get this is to apply ``f`` to ``x`` and ``y``; finally, the tail of the vector can only be built recursively."
msgstr ""

#: ../source/tutorial/interactive.rst:194
#: 270261717d624da99f75b67d0e6c0856
msgid ":makewith"
msgstr ""

#: ../source/tutorial/interactive.rst:196
#: 16a592fba6ba48079fb4b46f1a329b63
msgid "The ``:makewith n f`` command, abbreviated ``:mw n f``, adds a ``with`` to a pattern clause. For example, recall ``parity``. If line 10 is:"
msgstr ""

#: ../source/tutorial/interactive.rst:204
#: 9b4c898c52ab472095e7b22bfe9c5ee8
msgid "then ``:mw 10 parity`` will give:"
msgstr ""

#: ../source/tutorial/interactive.rst:211
#: d1a4a51fb5a3434aa8f3ccb3d741eeac
msgid "If we then fill in the placeholder ``_`` with ``parity k`` and case split on ``with_pat`` using ``:cs 11 with_pat`` we get the following patterns:"
msgstr ""

#: ../source/tutorial/interactive.rst:220
#: 8fca635e41b24e9bb86831aaf1125bb9
msgid "Note that case splitting has normalised the patterns here (giving ``plus`` rather than ``+``). In any case, we see that using interactive editing significantly simplifies the implementation of dependent pattern matching by showing a programmer exactly what the valid patterns are."
msgstr ""

#: ../source/tutorial/interactive.rst:227
#: aadb92ab9b184a92821d482600ef7f5c
msgid "Interactive Editing in Vim"
msgstr ""

#: ../source/tutorial/interactive.rst:229
#: fbe4349ea782459b866df4b55f23d4f7
msgid "The editor mode for Vim provides syntax highlighting, indentation and interactive editing support using the commands described above. Interactive editing is achieved using the following editor commands, each of which update the buffer directly:"
msgstr ""

#: ../source/tutorial/interactive.rst:235
#: aa34346afe70412a94d474697fd8730d
msgid "``\\a`` adds a template definition for the name declared on the"
msgstr ""

#: ../source/tutorial/interactive.rst:235
#: 338cfcf77d79423d84e9496f5a3ecdae
msgid "current line (using ``:addclause``)."
msgstr ""

#: ../source/tutorial/interactive.rst:238
#: da1a63dada92416b9b14b2ba179d85b6
msgid "``\\c`` case splits the variable at the cursor (using"
msgstr ""

#: ../source/tutorial/interactive.rst:238
#: c521e441d6f443c6bca740f5eb23d6ad
msgid "``:casesplit``)."
msgstr ""

#: ../source/tutorial/interactive.rst:241
#: 00b203407c294604b29e00de65ec4391
msgid "``\\m`` adds the missing cases for the name at the cursor (using"
msgstr ""

#: ../source/tutorial/interactive.rst:241
#: 9bb1e3fc38ef4d59bb146b8ec5d49708
msgid "``:addmissing``)."
msgstr ""

#: ../source/tutorial/interactive.rst:243
#: ef35f29d8842481d86aa67f4c28c701e
msgid "``\\w`` adds a ``with`` clause (using ``:makewith``)."
msgstr ""

#: ../source/tutorial/interactive.rst:246
#: b842cdd0ef9b4a7595c12dd4203a3c38
msgid "``\\s`` invokes a proof search to solve the hole under the"
msgstr ""

#: ../source/tutorial/interactive.rst:246
#: 17f96c0b35f045819b55ba9184636795
msgid "cursor (using ``:proofsearch``)."
msgstr ""

#: ../source/tutorial/interactive.rst:248
#: 2619a0a9c3904f51846d7cd96eb780f9
msgid "There are also commands to invoke the type checker and evaluator:"
msgstr ""

#: ../source/tutorial/interactive.rst:252
#: 4efc2eddf59149f2a11161edd9d8e4e8
msgid "``\\t`` displays the type of the (globally visible) name under the"
msgstr ""

#: ../source/tutorial/interactive.rst:251
#: e0b3277636a0461b9a7fad2fac2b3123
msgid "cursor. In the case of a hole, this displays the context and the expected type."
msgstr ""

#: ../source/tutorial/interactive.rst:254
#: 5054c3a495d34a07985e640a3c02e451
msgid "``\\e`` prompts for an expression to evaluate."
msgstr ""

#: ../source/tutorial/interactive.rst:256
#: 1715ed110e154f239601198977014781
msgid "``\\r`` reloads and type checks the buffer."
msgstr ""

#: ../source/tutorial/interactive.rst:258
#: 34b37e951bc246eb892ded78610db49d
msgid "Corresponding commands are also available in the Emacs mode. Support for other editors can be added in a relatively straightforward manner by using ``idris2 -–client``. More sophisticated support can be added by using the IDE protocol (yet to be documented for Idris 2, but which mostly extends to protocol documented for `Idris 1 <https://docs.idris-lang.org/en/latest/reference/ide-protocol.html>`_."
msgstr ""
