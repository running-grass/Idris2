# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-23 12:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/reference/strings.rst:2
#: 03034962a42949328931c07274984101
msgid "String literals in Idris"
msgstr ""

#: ../source/reference/strings.rst:4
#: 240d43a76d7143e4bd273989877b3bf9
msgid "To facilitate the use of string literals, idris provides three features in addition to plain string literals: multiline strings, raw strings and interpolated strings."
msgstr ""

#: ../source/reference/strings.rst:9
#: c299fa23aa82484aa1f87fdde3d45351
msgid "Plain string literals"
msgstr ""

#: ../source/reference/strings.rst:11
#: 34ddff6536cf494c9dcd66b85ab40b07
msgid "String literals behave the way you expect from other programming language. Use quotation marks ``\"`` around the piece of text that you want to use as a string:"
msgstr ""

#: ../source/reference/strings.rst:14
#: 781ef6d14d754c75af99d3d397ef5bfe
msgid "``\"hello world\"``"
msgstr ""

#: ../source/reference/strings.rst:16
#: e2a7ca9734b14ccdad0658a0cbf97eb2
msgid "As explained in :doc:`overloadedlit`, string literals can be overloaded to return a type different than string."
msgstr ""

#: ../source/reference/strings.rst:19
#: 16c8137d102644efad52860790abd32d
msgid "Multiline string literals"
msgstr ""

#: ../source/reference/strings.rst:21
#: 1d7ce83c82134bbfbf5aaaccdd907c22
msgid "In some cases you will have to display a large string literal that spans multiple lines. For this you can use *multiline string literals*, they allow you to span a string across multiple vertical lines, preserving the line returns and the indentation. Additionally they allow you to indent your multiline string with the surrounding code, without breaking the intended format of the string."
msgstr ""

#: ../source/reference/strings.rst:26
#: a7aba5d9c88046b1b168a63728c35d82
msgid "To use multiline strings, start with a triple quote ``\"\"\"`` followed by a line return, then enter your text and close it with another triple quote ``\"\"\"`` with whitespace on its left. The indentation of the closing triple quote will determine how much whitespace should be cropped from each line of the text."
msgstr ""

#: ../source/reference/strings.rst:33
#: 63fdc6e7712b4d15890df268619ac638
msgid "Multiline strings use triple quotes to enable the automatic cropping of leading whitespace when the multiline block is indented."
msgstr ""

#: ../source/reference/strings.rst:48
#: 95ab5dfa8d84419a90c7917bf021ca7c
msgid "printing the variable `welcome` will result in the following text:"
msgstr ""

#: ../source/reference/strings.rst:58
#: a87c3417fd9a4f38a6596757d1500404
msgid "As you can see, each line has been stripped of its leading 4 space, that is because the closing delimiter was indented with 4 spaces."
msgstr ""

#: ../source/reference/strings.rst:61
#: a8a05a6d0ef0409c83f4597f6701d3f9
msgid "In order to use multiline string literals, remember the following:"
msgstr ""

#: ../source/reference/strings.rst:63
#: 4e8345fe02454dfd85f165b37b81992f
msgid "The starting delimited must be followed by a line return"
msgstr ""

#: ../source/reference/strings.rst:64
#: ce4336e7769f43709425d6bdf8270d61
msgid "The ending delimiter's intendation level must not exceed the indentation of any line"
msgstr ""

#: ../source/reference/strings.rst:67
#: 81d02c1a46374465a6bbe9697b4e4014
msgid "Raw string literals"
msgstr ""

#: ../source/reference/strings.rst:69
#: 8b4dfbe2680a417f96f67a1dcfa6adc4
msgid "It is not uncommon to write string literals that require some amount of escaping. For plain string literals the characters ``\\\\`` and ``\"`` must be escaped, for multiline strings the characters ``\"\"\"`` must be escaped. Raw string literals allow you to dynamically change the required escaped sequence in order to avoid having to escape those very common sets of characters. For this, use ``#\"`` as starting delimiter and ``\"#`` as closing delimiter. The number of ``#`` symbols can be increased in order to accomodate for edge cases where ``\"#`` would be a valid symbol. In the following example we are able to match on ``\\{`` by using half as many ``\\\\`` characters as if we didn't use raw string literals:"
msgstr ""

#: ../source/reference/strings.rst:84
#: ab5ce5a38f37460da6db7e52ca3a4334
msgid "If you need to escape characters you still can by using a ``\\\\`` followed by the same number of ``#`` that you used for your string delimiters. In the following example we are using two ``#`` characters as our escape sequence and want to print a line return:"
msgstr ""

#: ../source/reference/strings.rst:93
#: 13c178c9858c4c34a9c2c45f0c0bafd5
msgid "This last example could be implemented by combining raw string literals with multiline strings:"
msgstr ""

#: ../source/reference/strings.rst:105
#: 277a7cb1403247b184c164229d0add0b
msgid "Interpolated strings"
msgstr ""

#: ../source/reference/strings.rst:107
#: 0355640ec5354bec8b7469f5241e345d
msgid "Concatenating string literals with runtime values happens all the time, but sprinkling our code with lots of ``\"`` and ``++`` symbols sometimes hurts legibility which in turn can introduce bugs that are hard to detect for human eyes. Interpolated strings allow to inline the execution of programs that evaluate to strings with a string literals in order to avoid manually writing out the concatenation of those expressions. To use interpolated strings, use ``\\{`` to start an interpolation slice in which you can write an idris expression. Close it with ``}``"
msgstr ""

#: ../source/reference/strings.rst:130
#: cb38c686e58740c0bf837acd4a33376b
msgid "As you can see in the second line, raw string literals and interpolated strings can be combined. The starting and closing delimiters indicate how many ``#`` must be used as escape sequence in the string, since interpolated strings require the first ``{`` to be escaped, an interpolated slice in a raw string uses ``\\#{`` as starting delimiter."
msgstr ""

#: ../source/reference/strings.rst:135
#: ae2f798a2777418383b8c76000542f73
msgid "Additionally multiline strings can also be combined with string interpolation in the way you expect, as shown with the ``Decl`` pattern. Finally all three features can be combined together in the last branch of the example, where a multiline string has a custom escape sequence and includes an interpolated slice."
msgstr ""

#: ../source/reference/strings.rst:141
#: 66f602ffca2d48649aa5e04cbc506bad
msgid "Interpolation Interface"
msgstr ""

#: ../source/reference/strings.rst:143
#: d5536af46dbf44f0821bb47dc44e20fb
msgid "The Prelude exposes an ``Interpolation`` interface with one function ``interpolate``. This function is used within every interpolation slice to convert an arbitrary expression into a string that can be concatenated with the rest of the interpolated string."
msgstr ""

#: ../source/reference/strings.rst:147
#: 07711af4c33b4bb7a282fe797332ccc6
msgid "To go into more details, when you write ``\"hello \\{username}\"`` the compiler translates the expression into ``concat [interpolate \"hello \", interpolate username]`` so that the concatenation is fast and so that if ``username`` implement the ``Interpolation`` interface, you don't have to convert it to a string manually."
msgstr ""

#: ../source/reference/strings.rst:151
#: f4c40b1d68cd481682c6f61ea071d99a
msgid "Here is an example where we reuse the ``Expr`` type but instead of implementing a ``print`` function we implement ``Interpolation``:"
msgstr ""

#: ../source/reference/strings.rst:170
#: 7a1f2a30407e4baeae273ed5b0c380ce
msgid "As you can see we avoid repeated calls to ``print`` since the slices are automatically applied to ``interpolate``."
msgstr ""

#: ../source/reference/strings.rst:173
#: afb3ffd2ee8848b9a8d5ba540641ab31
msgid "We use ``Interpolation`` instead of ``Show`` for interpolation slices because the semantics of ``show`` are not necessarily the same as ``interpolate``. Typically the implementation of ``show`` for ``String`` adds double quotes around the text, but for ``interpolate`` what we want is to return the string as is. In the previous example, ``\"hello \\{username}\"``, if we were to use ``show`` we would end up with the string ``\"hello \"Susan`` which displays an extra pair of double quotes. That is why the implementation of ``interpolate`` for ``String`` is the identity function: ``interpolate x = x``. This way the desugared code looks like: ``concat [id \"hello \", interpolate username]``."
msgstr ""
