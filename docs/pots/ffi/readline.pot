# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-23 12:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/ffi/readline.rst:5
#: 7cce367552864c45b99251a561fa631b
msgid "Example: Minimal Readline Bindings"
msgstr ""

#: ../source/ffi/readline.rst:7
#: 5b6a3f8efc8046748091284eb77240ef
msgid "In this section, we'll see how to create bindings for a C library (the `GNU Readline <https://tiswww.case.edu/php/chet/readline/rltop.html>`_ library) in Idris, and make them available in a package. We'll only create the most minimal bindings, but nevertheless they demonstrate some of the trickier problems in creating bindings to a C library, in that they need to handle memory allocation of ``String``."
msgstr ""

#: ../source/ffi/readline.rst:14
#: 59a7cf0f84df47dbb6fb97c957967ce8
msgid "You can find the example in full in the Idris 2 source repository, in `samples/FFI-readline <https://github.com/edwinb/Idris2/tree/master/samples/FFI-readline>`_. As a minimal example, this can be used as a starting point for other C library bindings."
msgstr ""

#: ../source/ffi/readline.rst:20
#: dc3a8ae2c19441cd838de6dcecb7529a
msgid "We are going to provide bindings to the following functions in the Readline API, available via ``#include <readline/readline.h>``:"
msgstr ""

#: ../source/ffi/readline.rst:28
#: 84024cdb6efa4ecfa6d78baf74da1097
msgid "Additionally, we are going to support tab completion, which in the Readline API is achieved by setting a global variable to a callback function (see Section :ref:`sect-callbacks`) which explains how to handle the completion:"
msgstr ""

#: ../source/ffi/readline.rst:38
#: 9b6343eeb45e4ec99009762fb0579d2b
msgid "A completion function takes a ``String``, which is the text to complete, and an ``Int``, which is the number of times it has asked for a completion so far. In Idris, this could be a function ``complete : String -> Int -> IO String``. So, for example, if the text so far is ``\"id\"``, and the possible completions are ``idiomatic`` and ``idris``, then ``complete \"id\" 0`` would produce the string ``\"idiomatic\"`` and ``complete \"id\" 1`` would produce ``\"idris\"``."
msgstr ""

#: ../source/ffi/readline.rst:45
#: 61d79f674b344ecc834aa7b814f5da94
msgid "We will define *glue* functions in a C file ``idris_readline.c``, which compiles to a shared object ``libidrisreadline``, so we write a function for locating the C functions:"
msgstr ""

#: ../source/ffi/readline.rst:54
#: 9284e2c8c1474209b6696dd3af6a77b5
msgid "Each of the foreign bindings will have a ``%foreign`` specifier which locates functions via ``rlib``."
msgstr ""

#: ../source/ffi/readline.rst:58
#: c628e3c7532c442e96d72ff74b9e5df1
msgid "Basic behaviour: Reading input, and history"
msgstr ""

#: ../source/ffi/readline.rst:60
#: e5cdbd915fe14fb5ba594146273ce272
msgid "We can start by writing a binding for ``readline`` directly. It's interactive, so needs to return a ``PrimIO``:"
msgstr ""

#: ../source/ffi/readline.rst:68
#: 4e36f9a67d4b47dc9286e26a2fc30c13
msgid "Then, we can write an ``IO`` wrapper:"
msgstr ""

#: ../source/ffi/readline.rst:75
#: ae401df0cbce416b845465eba91b0755
msgid "Unfortunately, this isn't quite good enough! The C ``readline`` function returns a ``NULL`` string if there is no input due to encountering an end of file. So, we need to handle that - if we don't, we'll get a crash on encountering end of file (remember: it's the Idris programmer's responsibility to give an appropriate type to the C binding!)"
msgstr ""

#: ../source/ffi/readline.rst:81
#: 717869697a294d2eba1a9714166306cc
msgid "Instead, we need to use a ``Ptr`` to say that it might be a ``NULL`` pointer (see Section :ref:`sect-ffi-string`):"
msgstr ""

#: ../source/ffi/readline.rst:89
#: ca124258fa6644f1885a273daf06d47f
msgid "We also need to provide a way to check whether the returned ``Ptr String`` is ``NULL``. To do so, we'll write some glue code to convert back and forth between ``Ptr String`` and ``String``, in a file ``idris_readline.c`` and a corresponding header ``idris_readline.h``. In ``idris_readline.h`` we have:"
msgstr ""

#: ../source/ffi/readline.rst:101
#: 8ae862342eb24aad9d8e2d09da4e3c88
msgid "Correspondingly, in ``idris_readline.c``:"
msgstr ""

#: ../source/ffi/readline.rst:121
#: 200536b49d4c43e7ab12914b669112b2
msgid "Now, we can use ``prim__readline`` as follows, with a safe API, checking whether the result it returns is ``NULL`` or a concrete ``String``:"
msgstr ""

#: ../source/ffi/readline.rst:141
#: 22c93e6f9d05433ba8ab733a62f320aa
msgid "We'll need ``nullString`` and ``mkString`` later, for dealing with completions."
msgstr ""

#: ../source/ffi/readline.rst:143
#: 13a9389b658847d39516f88c60f50618
msgid "Once we've read a string, we'll want to add it to the input history. We can provide a binding to ``add_history`` as follows:"
msgstr ""

#: ../source/ffi/readline.rst:155
#: 02c569be8d974702938d8e2260ff8c8a
msgid "In this case, since Idris is in control of the ``String``, we know it's not going to be ``NULL``, so we can add it directly."
msgstr ""

#: ../source/ffi/readline.rst:158
#: 1d592797b1c24186ab3c2c8426bf0381
msgid "A small ``readline`` program that reads input, and echoes it, recording input history for non-empty inputs, can be written as follows:"
msgstr ""

#: ../source/ffi/readline.rst:173
#: d62b372df0504fc493905b514b6364ba
msgid "This gives us command history, and command line editing, but Readline becomes much more useful when we add tab completion. The default tab completion, which is available even in the small example above, is to tab complete file names in the current working directory. But for any realistic application, we probably want to tab complete other commands, such as function names, references to local data, or anything that is appropriate for the application."
msgstr ""

#: ../source/ffi/readline.rst:181
#: d602ba22065d441d8a8f56e7de2d6c8d
msgid "Completions"
msgstr ""

#: ../source/ffi/readline.rst:183
#: 0da557c74f6f4bb7ac623b625d8d43da
msgid "Readline has a large API, with several ways of supporting tab completion, typically involving setting a global variable to an appropriate completion function. We'll use the following:"
msgstr ""

#: ../source/ffi/readline.rst:192
#: a65527f749964bfaa3925e1be242c528
msgid "The completion function takes the prefix of the completion, and the number of times it has been called so far on this prefix, and returns the next completion, or ``NULL`` if there are no more completions. An Idris equivalent would therefore have the following type:"
msgstr ""

#: ../source/ffi/readline.rst:201
#: 2ba1fd12f9cf4c339604718570b79459
msgid "The function returns ``Nothing`` if there are no more completions, or ``Just str`` for some ``str`` if there is another one for the current input."
msgstr ""

#: ../source/ffi/readline.rst:205
#: e269edbc98cc4c41b140123107a6bfbe
msgid "We might hope that it's a matter of defining a function to assign the completion function..."
msgstr ""

#: ../source/ffi/readline.rst:214
#: 284fdd72706a4243a14db3625a6db620
msgid "...then defining the Idris binding, which needs to take into account that the Readline library expects ``NULL`` when there are no more completions:"
msgstr ""

#: ../source/ffi/readline.rst:231
#: 4c6b03f147394d60af8330b6d759862c
msgid "So, we turn ``Nothing`` into ``nullString`` and ``Just str`` into ``mkString str``. Unfortunately, this doesn't quite work. To see what goes wrong, let's try it for the most basic completion function that returns one completion no matter what the input:"
msgstr ""

#: ../source/ffi/readline.rst:242
#: 0630383dd94d4a57aa34910bfc2b4d9e
msgid "We'll try this in a small modification of ``echoLoop`` above, setting a completion function first:"
msgstr ""

#: ../source/ffi/readline.rst:251
#: 6c3dc18e08934fba981995e0e909d706
msgid "We see that there is a problem when we try running it, and hitting TAB before entering anything:"
msgstr ""

#: ../source/ffi/readline.rst:259
#: 02c2a61f629b4cbf89ed3130badfbf07
msgid "The Idris code which sets up the completion is fine, but there is a problem with the memory allocation in the C glue code."
msgstr ""

#: ../source/ffi/readline.rst:262
#: dac47a69db6b47f688f53ba75aa02b53
msgid "This problem arises because we haven't thought carefully enough about which parts of our program are responsible for allocating and freeing strings. When Idris calls a foreign function that returns a string, it copies the string to the Idris heap and frees it immediately. But, if the foreign library also frees the string, it ends up being freed twice. This is what's happening here: the callback passed to ``prim__setCompletion`` frees the string and puts it onto the Idris heap, but Readline also frees the string returned by ``prim__setCompletion`` once it has processed it. We can solve this problem by writing a wrapper for the completion function which reallocates the string, and using that in ``idrisrl_setCompletion`` instead."
msgstr ""

#: ../source/ffi/readline.rst:296
#: 341248320fe74660861799085922c856
msgid "So, we define the completion function in C, which calls the Idris completion function then makes sure the string returned by the Idris function is copied to the C heap."
msgstr ""

#: ../source/ffi/readline.rst:300
#: 3dd690fcde5d4382b084cb58f11c64e1
msgid "We now have a primitive API that covers the most fundamental features of the readline API:"
msgstr ""
