# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-23 12:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/ffi/ffi.rst:3
#: 1fb3a540634d490bad9b84056f20f9c9
msgid "FFI Overview"
msgstr ""

#: ../source/ffi/ffi.rst:5
#: f98cc1912672427280991a099ce0c90c
msgid "Foreign functions are declared with the ``%foreign`` directive, which takes the following general form:"
msgstr ""

#: ../source/ffi/ffi.rst:13
#: 6cd1769516ab433589e4f407b4f2dbe4
msgid "The specifier is an Idris ``String`` which says in which language the foreign function is written, what it's called, and where to find it. There may be more than one specifier, and a code generator is free to choose any specifier it understands - or even ignore the specifiers completely and use their own approach. In general, a specifier has the form \"Language:name,library\". For example, in C:"
msgstr ""

#: ../source/ffi/ffi.rst:25
#: 5b69d17e95174922b6a722662e772066
msgid "It is up to specific code generators to decide how to locate the function and the library. In this document, we will assume the default Chez Scheme code generator (the examples also work with the Racket or Gambit code generator) and that the foreign language is C."
msgstr ""

#: ../source/ffi/ffi.rst:31
#: 94b1bf2282a64578b1364709f3f69b61
msgid "Scheme Sidenote"
msgstr ""

#: ../source/ffi/ffi.rst:33
#: 993eb4a371ed49359330518640705d2d
msgid "Scheme foreign specifiers can be written to target particular flavors."
msgstr ""

#: ../source/ffi/ffi.rst:35
#: da48f694dac34072a664914dc5f62d18
msgid "The following example shows a foreign declaration that allocates memory in a way specific to the choice of code generator. In this example there is no general scheme specifier present that matches every flavor, e.g. ``scheme:foo``, so it  will only match the specific flavors listed:"
msgstr ""

#: ../source/ffi/ffi.rst:48
#: d8fc0cc844784682948b1c095eadd209
msgid "If your backend (code generator) is not specified but defines a C FFI it will be able to make use of the ``C:malloc,libc`` specifier."
msgstr ""

#: ../source/ffi/ffi.rst:52
#: da01834dec844c93913ab3e358a0bac9
msgid "C Sidenote"
msgstr ""

#: ../source/ffi/ffi.rst:54
#: f40fe99f325b4a459e1500cf6bdc461b
msgid "The ``C`` language specifier is used for common functions that may be used by any backend which can, in turn, FFI out to C. For example, Scheme."
msgstr ""

#: ../source/ffi/ffi.rst:57
#: 45bf289abfa7496fa1bb1e9bc7314d20
msgid "The common C functions do no automatic memory management, deferring that to the individual backends."
msgstr ""

#: ../source/ffi/ffi.rst:60
#: 1b77aab10c964931900730b38726b00e
msgid "The standard C backend is known as \"RefC\", and uses the ``RefC`` language specifier."
msgstr ""

#: ../source/ffi/ffi.rst:64
#: 6e6d8f79d6dc4b4ebb129f3da10ffb6d
msgid "FFI Example"
msgstr ""

#: ../source/ffi/ffi.rst:66
#: 5a6a627d152646babbadddae2abd8eae
msgid "As a running example, we are going to work with a small C file. Save the following content to a file ``smallc.c``"
msgstr ""

#: ../source/ffi/ffi.rst:82
#: cd8b334476ec4a3199e3b62c9c795672
msgid "Then, compile it to a shared library with::"
msgstr ""

#: ../source/ffi/ffi.rst:86
#: 1381006c4f8a44df8209c059e560155f
msgid "We can now write an Idris program which calls each of these. First, we'll write a small program which uses ``add`` to add two integers:"
msgstr ""

#: ../source/ffi/ffi.rst:97
#: b2f7d5b2aeff4ccca0c515cd29bf531c
msgid "The ``%foreign`` declaration states that ``add`` is written in C, with the name ``add`` in the library ``libsmall``. As long as the run time is able to locate ``libsmall.so`` (in practice it looks in the current directory and the system library paths) we can run this at the REPL:"
msgstr ""

#: ../source/ffi/ffi.rst:107
#: db9079da813042189ea1268fb890a883
msgid "Note that it is the programmer's responsibility to make sure that the Idris function and C function have corresponding types. There is no way for the machine to check this! If you get it wrong, you will get unpredictable behaviour."
msgstr ""

#: ../source/ffi/ffi.rst:112
#: ca8af434ad1c42e6bd10ff525152d09d
msgid "Since ``add`` has no side effects, we've given it a return type of ``Int``. But what if the function has some effect on the outside world, like ``addWithMessage``? In this case, we use ``PrimIO Int`` to say that it returns a primitive IO action:"
msgstr ""

#: ../source/ffi/ffi.rst:122
#: de889edcd3f04fb1a8eb66015ac56019
msgid "Internally, ``PrimIO Int`` is a function which takes the current (linear) state of the world, and returns an ``Int`` with an updated state of the world. In general, ``IO`` operations in an Idris program are defined as instances of the ``HasIO`` interface. We can convert a primitive operation to one usable in ``HasIO`` using ``primIO``:"
msgstr ""

#: ../source/ffi/ffi.rst:132
#: a79cf92866d74bc286dc41144024a8cd
msgid "So, we can extend our program as follows:"
msgstr ""

#: ../source/ffi/ffi.rst:145
#: 332ea592a8304bc0ab3eb9b879a1db65
msgid "It is up to the programmer to declare which functions are pure, and which have side effects, via ``PrimIO``. Executing this gives:"
msgstr ""

#: ../source/ffi/ffi.rst:154
#: 1e82cf22261c4a8494afee8054e9326d
msgid "We have seen two specifiers for foreign functions:"
msgstr ""

#: ../source/ffi/ffi.rst:161
#: 032761c79aa547b09f40f388c76f70bc
msgid "These both have the same form: ``\"C:[name],libsmall\"`` so instead of writing the concrete ``String``, we write a function to compute the specifier, and use that instead:"
msgstr ""

#: ../source/ffi/ffi.rst:179
#: d17e8e810a4c499292090a17391f412e
msgid "Primitive FFI Types"
msgstr ""

#: ../source/ffi/ffi.rst:181
#: d5ed30566c0746a38f266c2b6d0f5bc3
msgid "The types which can be passed to and returned from foreign functions are restricted to those which it is reasonable to assume any back end can handle. In practice, this means most primitive types, and a limited selection of others.  Argument types can be any of the following primitives:"
msgstr ""

#: ../source/ffi/ffi.rst:186
#: ../source/ffi/ffi.rst:414
#: 1d8d8fefc5ac4dc3a8729f9aa74fe76c
#: 19d03656e5d2449eacc8d461cb2cd56a
msgid "``Int``"
msgstr ""

#: ../source/ffi/ffi.rst:187
#: ../source/ffi/ffi.rst:415
#: a039b91f3e644d6bbe7622973c51d130
#: 0a543e6d842d4c17a4b1d680513e81ed
msgid "``Char``"
msgstr ""

#: ../source/ffi/ffi.rst:188
#: 56be652e95d74928ba77f036fadfc335
msgid "``Double`` (as ``double`` in C)"
msgstr ""

#: ../source/ffi/ffi.rst:189
#: ../source/ffi/ffi.rst:417
#: 49f419f9fb7942559eb0b281a134a3e0
#: 183f23d71f764366a80f6fcc4fdaa6c2
msgid "``Bits8``"
msgstr ""

#: ../source/ffi/ffi.rst:190
#: ../source/ffi/ffi.rst:418
#: 34ab388071d14c44b5a7334c414ed96d
#: 3a88038c08f64bf7826a2697cb4f9ec7
msgid "``Bits16``"
msgstr ""

#: ../source/ffi/ffi.rst:191
#: ../source/ffi/ffi.rst:419
#: f83218198d6d44e8b533d54209d8b869
#: f4ffe303ceae426085c22aa7b9ec072a
msgid "``Bits32``"
msgstr ""

#: ../source/ffi/ffi.rst:192
#: ../source/ffi/ffi.rst:420
#: 9d5e67ebc2e547f6818a361079a43881
#: b4e52a1822694187ada579ef654e437f
msgid "``Bits64``"
msgstr ""

#: ../source/ffi/ffi.rst:193
#: 6ed130f9029549238eff2e6835ea73d6
msgid "``String`` (as ``char*`` in C)"
msgstr ""

#: ../source/ffi/ffi.rst:194
#: c8bc7a84c87b4250868bb18f849efd31
msgid "``Ptr t`` and ``AnyPtr`` (both as ``void*`` in C)"
msgstr ""

#: ../source/ffi/ffi.rst:196
#: 3e0ada00b6134a299dbb6b7c7cc4b708
msgid "Return types can be any of the above, plus:"
msgstr ""

#: ../source/ffi/ffi.rst:198
#: 26508fe32bc14e54aa33f1d372bc6ad4
msgid "``()``"
msgstr ""

#: ../source/ffi/ffi.rst:199
#: 3f5ecd14104e4eddb351363dd5790be0
msgid "``PrimIO t``, where ``t`` is a valid return type other than a ``PrimIO``."
msgstr ""

#: ../source/ffi/ffi.rst:201
#: f9065b8470ee42e9a9a5c1ff4ba55de3
msgid "Handling ``String`` leads to some complications, for a number of reasons:"
msgstr ""

#: ../source/ffi/ffi.rst:203
#: 22031d3b418c4a10bd34c9bc92302192
msgid "Strings can have multiple encodings. In the Idris run time, Strings are encoded as UTF-8, but C makes no assumptions."
msgstr ""

#: ../source/ffi/ffi.rst:205
#: 31f0e0ca150f46988e69bf748f5acb60
msgid "It is not always clear who is responsible for freeing a ``String`` allocated by a C function."
msgstr ""

#: ../source/ffi/ffi.rst:207
#: 90467c3997024d79baeeea0bcdcc0743
msgid "In C, strings can be ``NULL``, but Idris strings always have a value."
msgstr ""

#: ../source/ffi/ffi.rst:209
#: fd0c610bfe64442c8ef3ac1a71e5c334
msgid "So, when passing ``String`` to and from C, remember the following:"
msgstr ""

#: ../source/ffi/ffi.rst:211
#: 6459bb5c0a13427386c861b9f05393bc
msgid "A ``char*`` returned by a C function will be copied to the Idris heap, and the Idris run time immediately calls ``free`` with the returned ``char*``."
msgstr ""

#: ../source/ffi/ffi.rst:213
#: 612442b4c1d744878b67f8174cfb1252
msgid "If a ``char*`` might be ``NULL`` in ``C``, use ``Ptr String`` rather than ``String``."
msgstr ""

#: ../source/ffi/ffi.rst:216
#: 6ded84f2aacb4828a191dbad267c75a8
msgid "When using ``Ptr String``, the value will be passed as a ``void*``, and therefore not accessible directly by Idris code. This is to protect against accidentally trying to use ``NULL`` as a ``String``. You can nevertheless work with them and convert to ``String`` via foreign functions of the following form:"
msgstr ""

#: ../source/ffi/ffi.rst:236
#: fc81908c54eb4759b66ae5a2b376992d
msgid "For an example, see the sample :ref:`sect-readline` bindings."
msgstr ""

#: ../source/ffi/ffi.rst:238
#: 244dc79782724f87b098c0c64b3b9538
msgid "Additionally, foreign functions can take *callbacks*, and take and return C ``struct`` pointers."
msgstr ""

#: ../source/ffi/ffi.rst:244
#: 0b0dabe2942543c6be3de533a35b3735
msgid "Callbacks"
msgstr ""

#: ../source/ffi/ffi.rst:246
#: 85afb54a94684df68bed2ad7e0838955
msgid "It is often useful in C for a function to take a *callback*, that is a function which is called after doing some work. For example, we can write a function which takes a callback that takes a ``char*`` and an ``int`` and returns a ``char*``, in C, as follows (added to ``smallc.c`` above):"
msgstr ""

#: ../source/ffi/ffi.rst:260
#: ffd7b1de2e3a4cae8770a29187079b12
msgid "Then, we can access this from Idris by declaring it as a ``%foreign`` function and wrapping it in the ``HasIO`` interface, with the C function calling the Idris function as the callback:"
msgstr ""

#: ../source/ffi/ffi.rst:273
#: 99a1e73347cf4db3ac690c3d097ef334
msgid "For example, we can try this as follows:"
msgstr ""

#: ../source/ffi/ffi.rst:291
#: ffa635fcd7d641d7a877c6adedca0bf9
msgid "As a variant, the callback could have a side effect:"
msgstr ""

#: ../source/ffi/ffi.rst:299
#: a52daaaee3a7406aaafec5d3b25b6c09
msgid "This is a little more fiddly to lift to a ``HasIO`` function, due to the callback, but we can do so using ``toPrim : IO a -> PrimIO a``:"
msgstr ""

#: ../source/ffi/ffi.rst:308
#: b8c9953d2637446ea7269c4fddf40776
msgid "Note that the callback is explicitly in ``IO`` here, since ``HasIO`` doesn't have a general method for extracting the primitive ``IO`` operation."
msgstr ""

#: ../source/ffi/ffi.rst:311
#: cd8b0fe326fb4c31914773c40ce409f0
msgid "For example, we can extend the above ``pluralise`` example to print a message in the callback:"
msgstr ""

#: ../source/ffi/ffi.rst:332
#: d61d6f93a0184752b80031770fb5a0c8
msgid "Structs"
msgstr ""

#: ../source/ffi/ffi.rst:334
#: 2e802831a1374b9b82b575c7919a7b45
msgid "Many C APIs pass around more complex data structures, as a ``struct``. We do not aim to be completely general in the C types we support, because this will make it harder to write code which is portable across multiple back ends. However, it is still often useful to be able to access a ``struct`` directly. For example, add the following to the top of ``smallc.c``, and rebuild ``libsmall.so``:"
msgstr ""

#: ../source/ffi/ffi.rst:361
#: 2c017625f8364d75b91b45692abac647
msgid "We can define a type for accessing ``point`` in Idris by importing ``System.FFI`` and using the ``Struct`` type, as follows:"
msgstr ""

#: ../source/ffi/ffi.rst:378
#: 8c66ff78aad044c9b515eb88ce990bf1
msgid "The ``Point`` type in Idris now corresponds to ``point*`` in C. Fields can be read and written using the following, also from ``System.FFI``:"
msgstr ""

#: ../source/ffi/ffi.rst:388
#: 5497c0ff242543cc94d27b21c4c25b64
msgid "Notice that fields are accessed by name, and must be available in the struct, given the constraint ``FieldType n ty fs``, which states that the field named ``n`` has type ``ty`` in the structure fields ``fs``. So, we can display a ``Point`` as follows by accessing the fields directly:"
msgstr ""

#: ../source/ffi/ffi.rst:401
#: 8e4c4304c0264497a4c71baf6edd9782
msgid "And, as a complete example, we can initialise, update, display and delete a ``Point`` as follows:"
msgstr ""

#: ../source/ffi/ffi.rst:412
#: 4c3a4709be6e476b80ef3345424abb1b
msgid "The field types of a ``Struct`` can be any of the following:"
msgstr ""

#: ../source/ffi/ffi.rst:416
#: bd6090ba85064ea3a3a9cb4a0bda272a
msgid "``Double`` (``double`` in C)"
msgstr ""

#: ../source/ffi/ffi.rst:421
#: b0efaf1d741b42acad32a0e3f0cde8dc
msgid "``Ptr a`` or ``AnyPtr`` (``void*`` in C)"
msgstr ""

#: ../source/ffi/ffi.rst:422
#: c93ce4e7a43440fab525283706117d25
msgid "Another ``Struct``, which is a pointer to a ``struct`` in C"
msgstr ""

#: ../source/ffi/ffi.rst:424
#: 7d17efe3263642ff90e2d32b6714a79d
msgid "Note that this doesn't include ``String`` or function types! This is primarily because these aren't directly supported by the Chez back end. However, you can use another pointer type and convert. For example, assuming you have, in C:"
msgstr ""

#: ../source/ffi/ffi.rst:435
#: cd2247ccf6d045f585972a120b41822e
msgid "You can represent this in Idris as:"
msgstr ""

#: ../source/ffi/ffi.rst:445
#: 28a39585b6cd4961958a47a55d35c55b
msgid "That is, using a ``Ptr String`` instead of a ``String`` directly. Then you can convert between a ``void*`` and a ``char*`` in C:"
msgstr ""

#: ../source/ffi/ffi.rst:454
#: 34558a72fe204cf88a1a2baf895dc619
msgid "...and use this to convert to a ``String`` in Idris:"
msgstr ""

#: ../source/ffi/ffi.rst:463
#: f0768e94e28a48e9a9f7bb0c349180a5
msgid "Finalisers"
msgstr ""

#: ../source/ffi/ffi.rst:465
#: 41d259c61dc64d0c93cc5624df6f1bac
msgid "In some libraries, a foreign function creates a pointer and the caller is responsible for freeing it. In this case, you can make an explicit foreign call to ``free``. However, this is not always convenient, or even possible. Instead, you can ask the Idris run-time to be responsible for freeing the pointer when it is no longer accessible, using ``onCollect`` (or its typeless variant ``onCollectAny``) defined in the Prelude:"
msgstr ""

#: ../source/ffi/ffi.rst:477
#: f8d03ab6458040a9a7703013d8b8136c
msgid "A ``GCPtr t`` behaves exactly like ``Ptr t`` when passed to a foreign function (and, similarly, ``GCAnyPtr`` behaves like ``AnyPtr``). A foreign function cannot return a ``GCPtr`` however, because then we can no longer assume the pointer is completely managed by the Idris run-time."
msgstr ""

#: ../source/ffi/ffi.rst:482
#: e6bfdf3307b0476daf82928b69ae0bd5
msgid "The finaliser is called either when the garbage collector determines that the pointer is no longer accessible, or at the end of execution."
msgstr ""

#: ../source/ffi/ffi.rst:485
#: 6d9fb96b3bdf488a9c338f9ffe3f9b00
msgid "Note that finalisers might not be supported by all back ends, since they depend on the facilities offered by a specific back end's run time system. They are certainly supported in the Chez Scheme and Racket back ends."
msgstr ""
